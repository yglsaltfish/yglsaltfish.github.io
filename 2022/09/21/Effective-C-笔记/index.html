<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yglsaltfish.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="记录我阅读Effective C++笔记的收获">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective C++ 笔记">
<meta property="og:url" content="https://yglsaltfish.github.io/2022/09/21/Effective-C-%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="ATT_POWER的博客">
<meta property="og:description" content="记录我阅读Effective C++笔记的收获">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-09-21T02:39:07.000Z">
<meta property="article:modified_time" content="2022-10-15T06:42:24.891Z">
<meta property="article:author" content="ATT_POWER">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://yglsaltfish.github.io/2022/09/21/Effective-C-%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Effective C++ 笔记 | ATT_POWER的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ATT_POWER的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yglsaltfish.github.io/2022/09/21/Effective-C-%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ATT_POWER">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ATT_POWER的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Effective C++ 笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-21 10:39:07" itemprop="dateCreated datePublished" datetime="2022-09-21T10:39:07+08:00">2022-09-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-15 14:42:24" itemprop="dateModified" datetime="2022-10-15T14:42:24+08:00">2022-10-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>26k</span>
            </span>
            <div class="post-description">记录我阅读Effective C++笔记的收获</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="让自己习惯C-：条款-1-4"><a href="#让自己习惯C-：条款-1-4" class="headerlink" title="让自己习惯C++ ：条款(1~4)"></a>让自己习惯C++ ：条款(1~4)</h1><h2 id="条款1-将C-看作一个语言联邦"><a href="#条款1-将C-看作一个语言联邦" class="headerlink" title="条款1 将C++看作一个语言联邦"></a>条款1 将C++看作一个语言联邦</h2><p>早期的C++只是叫”C with classes”，但发展到今天已经成为一个多重泛型编程语言，有四种次语言：</p>
<ul>
<li>C</li>
<li>面向对象 C++ ，也就是 C with class</li>
<li>template C++ ，也就是C++的泛型编程。由于template强大，带来了template metaprogramming（TMP，模板元编程）</li>
<li>STL。 template 程序库</li>
</ul>
<p>总结：C++高效编程守则视情况变化而变化，取决于使用C++的部分。</p>
<h2 id="条款2-尽量用const，enum，inline-替换-define"><a href="#条款2-尽量用const，enum，inline-替换-define" class="headerlink" title="条款2 尽量用const，enum，inline 替换 #define"></a>条款2 尽量用const，enum，inline 替换 #define</h2><p>也可以说是使用编译器替换预处理器</p>
<ol>
<li>例如：<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ASPECT</span> <span class="token expression"><span class="token number">1.653</span></span></span></code></pre>
 在上面这个语句中，字符串’ASPECT’是不会被编译器看到的，而编译器看到的是’1.653’，这就会导致在调试过程中，编译器的错误信息只显示’1.653’而不是’ASPECT’，对调试造成问题。<br> 可以使用如下替换： <pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">double</span> Aspect <span class="token operator">=</span> <span class="token number">1.653</span><span class="token punctuation">;</span>  <span class="token comment">//由于大写名称通常使用于宏，所以 ASPECT->Aspect</span></code></pre></li>
<li><p>当定义或声明全局变量时，常数指针和类的常数需要另加考虑</p>
<ul>
<li><p>对于指针要把指针本身和它指向的数据都定义为const。<br>例如</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> myWord <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span></code></pre>
<p>在C++中可以更方便地使用std::string这样基于char*类型的推广，例如</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token function">myWord</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><p>对于类的常数<br>为了将常量的作用域限制于class内，并且确保这个常量不会生成多个拷贝，可以声明为类的私有静态成员</p>
<pre class="language-c" data-language="c"><code class="language-c">class Player<span class="token punctuation">&#123;</span>
 private<span class="token operator">:</span>
  <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> NumTurns <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>因为此处是类的成员声明范围内，所以上面只是变量的声明和初始化，而并非定义，因此如果想获取变量的地址，需要在别处另加定义。这个定义不能有任何赋值语句，因为在类内已经规定为const:</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> Player<span class="token operator">::</span>numPlayer<span class="token punctuation">;</span></code></pre>
</li>
</ul>
</li>
<li><p>枚举技巧<br>假设存在这么一种情况：需要在一个类内声明某变量，但你的编译器不允许在声明时赋值初始化，同时接下来的某个语句却需要用到这个变量的具体数值，如：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> noPlayer<span class="token punctuation">;</span>
<span class="token keyword">int</span> scores<span class="token punctuation">[</span>noPlayer<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
<p>这个时候编译器会报错，可以使用以下方式解决：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token punctuation">&#123;</span>noPlayer <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> scores<span class="token punctuation">[</span>noPlayer<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
<p>但注意enum类型在内存中没有实体，无法取得enum类型的地址，因此这个方法更相当于取一个本地的#define数值</p>
</li>
<li><p>对于#define的宏函数，尽量使用inline修饰的函数来代替#define<br>inline关键字用来建议编译器把某频繁调用的函数当做内联函数，即在每次函数调用时，直接把函数代码放在函数调用语句的地址，减少堆栈浪费。<br>如果为了减少堆栈资源的使用，把某个频繁调用的函数规定为宏，例如用a和b的最大值来调用某函数f:</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">CALL_MAX</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span></code></pre>
<p>但是这样会产生一个新问题</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">CALL_MAX</span><span class="token punctuation">(</span><span class="token operator">++</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">//a增加了一次</span>
<span class="token function">CALL_MAX</span><span class="token punctuation">(</span><span class="token operator">++</span>a<span class="token punctuation">,</span> b<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">//a增加了两次 </span></code></pre>
<p>解决方法：</p>
<pre class="language-c" data-language="c"><code class="language-c">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">callMax</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">f</span><span class="token punctuation">(</span>a <span class="token operator">></span> b <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
</ol>
<h2 id="条款3-多用const"><a href="#条款3-多用const" class="headerlink" title="条款3 多用const"></a>条款3 多用const</h2><ol>
<li><p>如果要定义某指针或数据为常量不允许改变</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>  <span class="token comment">//数据是const ，数据不允许被改变</span>
<span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> p<span class="token punctuation">;</span>  <span class="token comment">//指针是const , 指针不允许被改变</span>
<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> <span class="token keyword">const</span> p<span class="token punctuation">;</span> <span class="token comment">//数据和指针都是const，都不可以被改变</span>

<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> p<span class="token punctuation">;</span>  <span class="token comment">//都表示指向常量char的指针</span>
<span class="token keyword">char</span> cosnt <span class="token operator">*</span>p<span class="token punctuation">;</span> </code></pre>
<p>const 在*号左边修饰数据，const在星号右边修饰指针</p>
</li>
<li><p>迭代器与const<br>迭代器在功能上相当于指向某类型T的指针T*</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator it <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//表示迭代器本身是常量</span>
<span class="token operator">*</span>it <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">//编译通过，迭代器是常量，但是数据可以被修改</span>
<span class="token operator">++</span>it<span class="token punctuation">;</span>   <span class="token comment">//编译失败！因为const迭代器不允许被改变！</span></code></pre>
<p>如果要更改数据，使用const_iterator</p>
<pre class="language-c" data-language="c"><code class="language-c">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>const_iterator it <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//无法使用，待解决TODO</span>
</code></pre>
</li>
<li><p>尽量使用const可以帮助调试<br>假设存在</p>
<pre class="language-c" data-language="c"><code class="language-c">class Rational<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
Rational operator<span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></code></pre>
<p>在某处使用此乘法操作符，误把比较操作符“==”打成了赋值操作符 “=” ：</p>
<pre class="language-c" data-language="c"><code class="language-c">Rational a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">*</span> b <span class="token operator">=</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>      </code></pre>
<p>但编译器在此并不会报错，因为只有当a,b,c是C++自有类型(比如int)才会报错，对于用户自定义的类，编译器会认为此操作是将一个Rational赋值给另一个Rational<br>如果将该操作符定义为返回const，这样赋值将会是非法操作。</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> Rational operator<span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p>类的成员函数与const<br>给成员函数使用const关键字是非常重要的，它可以让接口更加直观，直接告诉用户这个函数是不是只读(Read only)，会不会改变某变量。</p>
</li>
<li><p>成员函数的常量性<br>C++标准对成员函数”常量性”的规定是数据常量性(bitwise constness)，即不允许常量对象的成员数据被修改。C++编译器对此的检测也十分简单粗暴，只检查该成员函数有没有给成员数据的赋值操作。</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> Text <span class="token function">ct</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//构造某常量对象</span>
<span class="token keyword">char</span><span class="token operator">*</span> pc <span class="token operator">=</span> <span class="token operator">&amp;</span>ct<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token comment">//取其指针</span>
<span class="token operator">*</span>pc <span class="token operator">=</span> <span class="token char">'K'</span><span class="token punctuation">;</span>                     <span class="token comment">//通过指针修改常量对象，编译不会报错，结果为"Kello"</span></code></pre>
<p>还有另一个局限性，例如：</p>
<pre class="language-c" data-language="c"><code class="language-c">class Text<span class="token punctuation">&#123;</span>
  public<span class="token operator">:</span>
    std<span class="token operator">::</span><span class="token class-name">sizt_t</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  private<span class="token operator">:</span>
    <span class="token keyword">char</span><span class="token operator">*</span> pText<span class="token punctuation">;</span>
    std<span class="token operator">::</span><span class="token class-name">size_t</span> length<span class="token punctuation">;</span>
    bool lengthValid<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
std<span class="token operator">::</span><span class="token class-name">size_t</span> Text<span class="token operator">::</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>lengthValid<span class="token punctuation">)</span>           <span class="token comment">//做某些错误检测</span>
  <span class="token punctuation">&#123;</span>
    length <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">strlen</span><span class="token punctuation">(</span>pText<span class="token punctuation">)</span><span class="token punctuation">;</span>         
    lengthValid <span class="token operator">=</span> true<span class="token punctuation">;</span>                   
  <span class="token punctuation">&#125;</span>

  <span class="token keyword">return</span> length<span class="token punctuation">;</span>             <span class="token comment">//这行才是代码核心</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>在这段代码中，length()函数要做某些错误检测，因此可能会修改成员数据。即使真正的功能核心只是返回字符长度，编译器依然认为你可能会修改某些成员数据而报错。因此，更好的方法是逻辑常量性(Logical constness)，即允许某些数据被修改，只要这些改动不会反映在外，例如，以上问题可以用mutable关键字来解决:</p>
<pre class="language-c" data-language="c"><code class="language-c">mutable std<span class="token operator">::</span><span class="token class-name">size_t</span> length<span class="token punctuation">;</span>
mutable bool lengthValid<span class="token punctuation">;</span></code></pre></li>
<li>在定义常量与非常量成员函数时，避免代码重复<br>其实在这里指的是函数的实现要避免重复。试想某函数既要检查边界范围，又要记录读取历史，还要检查数据完整性，这样的代码复制一遍，既不显得美观，又增加了代码维护的难度和编译时间。因此，可以使用非常量的函数来调用常量函数。<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> operator<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token class-name">size_t</span> pos<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>
<span class="token keyword">char</span><span class="token operator">&amp;</span> operator<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token class-name">size_t</span> pos<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span>
    const_cast<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>                              <span class="token comment">//const_cast去掉const关键字，并转换为char&amp;</span>
      static_cast<span class="token operator">&lt;</span><span class="token keyword">const</span> Text<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">)</span><span class="token punctuation">[</span>position<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//给当前变量加上const关键字，才可以调用const操作符</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
为了避免无限递归调用当前非常量的操作符，可以需要将(*this)转换为const Text&amp;类型才能保证安全调用const的操作符，最后去掉const关键字再将其返回，巧妙避免了代码的大段复制。<br>但注意，如果使用相反的方法，用const函数来调用non-const函数，就可能会有未知结果，因为这样相当于non-const函数接触到了const对象的数据，就可能导致常量数据被改变。</li>
</ol>
<p>总结：</p>
<ul>
<li><p>指针，迭代器，引用，本地变量，全局变量，成员函数，返回值都可以使用const来实现数据只读的目的，const是C++一个非常强大的特性。</p>
</li>
<li><p>除此之外，它还能帮助加快调试过程</p>
</li>
<li><p>即使编译器使用数据常量性的标准，可以编程的时候应该采用逻辑常量性，对相关不可避免更改的成员数据加上mutable关键字来修饰</p>
</li>
<li><p>当有大段复制代码出现在const和non-const的成员函数中，可以使用non-const函数来调用const函数来避免复制。</p>
</li>
</ul>
<h2 id="条款4-确定对象被使用前已经被初始化"><a href="#条款4-确定对象被使用前已经被初始化" class="headerlink" title="条款4 确定对象被使用前已经被初始化"></a>条款4 确定对象被使用前已经被初始化</h2><p>C++并不能保证每个对象在定义时都被自动初始化。就像书中第一条提到的一样，C++包含多种子语言，例如定义一个C风格的整型数组(int[])时，其中就可能包含非零初始化的元素。到那时STL中的容器所有元素都是被0初始化的（默认条件）。</p>
<ol>
<li><p>自有类型(built-in type)的初始化<br>C++的自有类型继承于C，因此不能保证此类型的变量在定义时被初始化。使用未初始化的数据可能会导致程序不正常运作，因此在定义变量的时候，需要对其进行初始化。</p>
</li>
<li><p>类的初始化<br>对于用户自定义的类，可以需要构造函数(constructor)来完成此类的初始化<br>例如：</p>
<pre class="language-c" data-language="c"><code class="language-c">class PhoneNumber <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

class ABEntry
<span class="token punctuation">&#123;</span> <span class="token comment">// ABEntry = “Address Book Entry”</span>
public<span class="token operator">:</span>
    <span class="token function">ABEntry</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>address<span class="token punctuation">,</span>
            <span class="token keyword">const</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span>PhoneNumber<span class="token operator">></span> <span class="token operator">&amp;</span>phones<span class="token punctuation">)</span><span class="token punctuation">;</span>

private<span class="token operator">:</span>
    std<span class="token operator">::</span>string theName<span class="token punctuation">;</span>
    std<span class="token operator">::</span>string theAddress<span class="token punctuation">;</span>
    std<span class="token operator">::</span>list<span class="token operator">&lt;</span>PhoneNumber<span class="token operator">></span> thePhones<span class="token punctuation">;</span>
    <span class="token keyword">int</span> numTimesConsulted<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
ABEntry<span class="token operator">::</span><span class="token function">ABEntry</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>address<span class="token punctuation">,</span>
                 <span class="token keyword">const</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span>PhoneNumber<span class="token operator">></span> <span class="token operator">&amp;</span>phones<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    theName <span class="token operator">=</span> name<span class="token punctuation">;</span>       <span class="token comment">// these are all assignments,</span>
    theAddress <span class="token operator">=</span> address<span class="token punctuation">;</span> <span class="token comment">// not initializations</span>
    thePhones <span class="token operator">=</span> phones<span class="token punctuation">;</span>
    numTimesConsulted <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>这是个易于记忆的方法，但不是最好的方法。因为此构造函数并没有真正完成“初始化”，只不过是做了“赋值”的操作。C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前。也就是初始化的发生时间在这些成员的default构造函数被调用之时（比进入构造函数本体的时间更早）。<br>描写构造函数可以有更好的方法：</p>
<pre class="language-c" data-language="c"><code class="language-c">ABEntry<span class="token operator">::</span><span class="token function">ABEntry</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>address<span class="token punctuation">,</span>
                 <span class="token keyword">const</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span>PhoneNumber<span class="token operator">></span> <span class="token operator">&amp;</span>phones<span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token function">theName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token function">theAddress</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// these are now all initializations</span>
      <span class="token function">thePhones</span><span class="token punctuation">(</span>phones<span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token function">numTimesConsulted</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> </code></pre></li>
<li><p>有些初始化是必要的<br>例如在定义引用(reference)和常量(const)时，不将其初始化会导致编译器报错。</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>                <span class="token comment">//报错，需要初始化！</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> b<span class="token punctuation">;</span>                     <span class="token comment">//报错，需要初始化！</span>
<span class="token comment">//现在对其进行初始化：</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>            <span class="token comment">//编译通过</span>
<span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> c<span class="token punctuation">;</span>                 <span class="token comment">//编译通过！</span></code></pre>
<p>最省力的方法就是总是初始化，并且使用初值列初始化，省力又高效。</p>
</li>
<li><p>初始化的顺序<br>在继承关系中，基类(base class)总是先被初始化。</p>
</li>
</ol>
<p>在同一类中，成员数据的初始化顺序与其声明顺序是一致的，而不是初始化列表的顺序。因此，为了代码一致性，要保证初始化列表的顺序与成员数据声明的顺序是一样的。</p>
<pre class="language-c" data-language="c"><code class="language-c">class myClass<span class="token punctuation">&#123;</span>
  private<span class="token operator">:</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">int</span> b<span class="token punctuation">;</span>
    <span class="token keyword">int</span> c<span class="token punctuation">;</span>
  public<span class="token operator">:</span>
    <span class="token function">myClass</span><span class="token punctuation">(</span><span class="token keyword">int</span> _a<span class="token punctuation">,</span> <span class="token keyword">int</span> _b<span class="token punctuation">,</span> <span class="token keyword">int</span> _c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">//即使初始化列表是c->a->b的顺序，真正的初始化顺序还是按照a->b->c</span>
myClass<span class="token operator">::</span><span class="token function">myClass</span><span class="token punctuation">(</span><span class="token keyword">int</span> _a<span class="token punctuation">,</span> <span class="token keyword">int</span> _b<span class="token punctuation">,</span> <span class="token keyword">int</span> _c<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">c</span><span class="token punctuation">(</span>_c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">a</span><span class="token punctuation">(</span>_a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">b</span><span class="token punctuation">(</span>_b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></code></pre>
<ol>
<li>初始化非本地静态对象<br>在两个编译单元中，分别包含至少一个非本地静态对象，当这些对象发生互动时，它们的初始化顺序是不确定的，所以直接使用这些变量，就会给程序的运行带来风险。</li>
</ol>
<ul>
<li>编译单元：可以让编译器生成代码的基本单元，一般一个源代码文件就是一个编译单元。</li>
<li>非本地静态对象(non-local static object): 静态对象可以是在全局范围定义的变量，在名空间范围定义的变量，函数范围内定义为static的变量，类的范围内定义为static的变量，而除了函数中的静态对象是本地的，其他都是非本地的。静态对象存在于程序的开始到结束，所以它不是基于堆(heap)或者栈(stack)的。初始化的静态对象存在于.data中，未初始化的则存在于.bss中。<br>存在以下服务端代码和客户端代码<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//服务端</span>
class Server<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>     
<span class="token keyword">extern</span> Server server<span class="token punctuation">;</span>                 <span class="token comment">//在全局范围声明外部对象server，供外部使用</span>
<span class="token comment">//客户端</span>
class Client<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
Client<span class="token operator">::</span><span class="token function">Client</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    number <span class="token operator">=</span> server<span class="token punctuation">.</span>number<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

Client client<span class="token punctuation">;</span>                       <span class="token comment">//在全局范围定义client对象，自动调用了Client类的构造函数</span></code></pre>
以上问题在于，定义对象client自动调用了client类的构造函数，此时需要读取对象server的数据，但全局变量的不可控性让可以不能保证对象server在此时被读取时是初始化的。试想如果还有对象client1, client2等等不同的用户读写，可以不能保证当前server的数据是可以想要的。<br>解决方法: 将全局变量变为本地静态变量<br>使用一个函数，只用来定义一个本地静态变量并返回它的引用。因为C++规定在本地范围(函数范围)内定义某静态对象时，当此函数被调用，该静态变量一定会被初始化。<pre class="language-c" data-language="c"><code class="language-c">class Server<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
Server<span class="token operator">&amp;</span> <span class="token function">server</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                         <span class="token comment">//将直接的声明改为一个函数</span>
    <span class="token keyword">static</span> Server server<span class="token punctuation">;</span>
    <span class="token keyword">return</span> server<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

class Client<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
Client<span class="token operator">::</span><span class="token function">client</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        <span class="token comment">//客户端构造函数通过函数访问服务器数据</span>
    number <span class="token operator">=</span> <span class="token function">server</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>number<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
Client<span class="token operator">&amp;</span> <span class="token function">client</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        <span class="token comment">//同样将客户端的声明改为一个函数</span>
    <span class="token keyword">static</span> Client client<span class="token punctuation">;</span>
    <span class="token keyword">return</span> client<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
总结：</li>
<li>对于自由类型，要保证在定义时手动初始化</li>
<li>在定义构造函数时，要用初始化列表，避免使用在函数体内的赋值初始化。在使用初始化列表时，为了保持代码一致性，初始化列表中变量的顺序要与其声明顺序相同</li>
<li>当不同的编译单元产生互动时，要将其中非本地的静态变量变为本地的静态变量才能保证安全的读写</li>
</ul>
<h1 id="构造、析构、赋值运算-：条款-5-12"><a href="#构造、析构、赋值运算-：条款-5-12" class="headerlink" title="构造、析构、赋值运算 ：条款(5~12)"></a>构造、析构、赋值运算 ：条款(5~12)</h1><h2 id="条款5-了解C-默默编写并调用哪些函数"><a href="#条款5-了解C-默默编写并调用哪些函数" class="headerlink" title="条款5 了解C++默默编写并调用哪些函数"></a>条款5 了解C++默默编写并调用哪些函数</h2><ol>
<li>C++会为类生成默认的关键函数，如默认的构造函数，拷贝赋值运算符，拷贝构造函数以及析构函数<pre class="language-c" data-language="c"><code class="language-c">class Empty <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>             
<span class="token comment">//假定以下功能都会被调用，此定义等价于：</span>
class Empty<span class="token punctuation">&#123;</span>
  public<span class="token operator">:</span>
    <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>                                <span class="token comment">//构造函数</span>
    <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token keyword">const</span> Empty<span class="token operator">&amp;</span> empty<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>             <span class="token comment">//拷贝构造函数</span>
    <span class="token operator">~</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>                               <span class="token comment">//析构函数</span>
    Empty<span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Empty<span class="token operator">&amp;</span> empty<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>   <span class="token comment">//拷贝赋值运算符</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
对于赋值运算符，只有当代码合法且有意义，编译器才会自动生成，然而有些时候会产生错误。<pre class="language-c" data-language="c"><code class="language-c">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>
class A<span class="token punctuation">&#123;</span>
  public<span class="token operator">:</span>
    <span class="token function">A</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string<span class="token operator">&amp;</span> _name<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  private<span class="token operator">:</span>
    std<span class="token operator">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">;</span>
    <span class="token keyword">const</span> T value<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>string <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>string <span class="token function">s2</span><span class="token punctuation">(</span><span class="token string">"hi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
A<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">a1</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
A<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">a2</span><span class="token punctuation">(</span>s2<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a1<span class="token operator">=</span>a2<span class="token punctuation">;</span></code></pre>
如果按照默认的赋值运算符，会编译错误，相当于如下操作，自然不可使用。<pre class="language-c" data-language="c"><code class="language-c">string u <span class="token punctuation">,</span> v<span class="token punctuation">;</span>
string <span class="token operator">&amp;</span>a <span class="token operator">=</span> u <span class="token punctuation">,</span><span class="token operator">&amp;</span>b <span class="token operator">=</span> v<span class="token punctuation">;</span>
a <span class="token operator">=</span> b<span class="token punctuation">;</span></code></pre>
此外，当基类有将赋值运算符声明为私有时，编译器也会拒绝为它的子类生成赋值运算符，因为在子类赋值过程中，它所包含的基类也应当被赋值。但是既然被声明为基类的私有成员，子类将不能调用。</li>
</ol>
<p>总结：</p>
<ul>
<li>如果自己不声明，编译器将会自动生成默认的构造函数，拷贝构造函数，拷贝赋值运算符和析构函数。</li>
</ul>
<h2 id="条款6-明确拒绝不需要的自动生成函数"><a href="#条款6-明确拒绝不需要的自动生成函数" class="headerlink" title="条款6 明确拒绝不需要的自动生成函数"></a>条款6 明确拒绝不需要的自动生成函数</h2><p>考虑如下类：<br><pre class="language-c" data-language="c"><code class="language-c">class Widget <span class="token punctuation">&#123;</span>
 public<span class="token operator">:</span>
    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">name_</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">buf_</span><span class="token punctuation">(</span>new <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> delete buf_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

 private<span class="token operator">:</span>
    std<span class="token operator">::</span>string name_<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>buf_<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><br>默认生成的拷贝构造函数，会直接拷贝buf_的值，导致两个Widget对象指向同一个缓 冲区，这会导致析构的时候两次删除同一片区域的问题（这个问题又叫双杀问题），所以在某种情况下就需要禁止拷贝。</p>
<p>当一个父类将拷贝函数声明为私有时，编译器会拒绝为它的子类生成拷贝函数。因此可以专门使用一个父类，在其中声明拷贝操作为私有，并让可以的类继承自它。<br><pre class="language-c" data-language="c"><code class="language-c">class Uncopyable<span class="token punctuation">&#123;</span>
  protected<span class="token operator">:</span>
    <span class="token function">Uncopyable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">Uncopyable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  private<span class="token operator">:</span>
    <span class="token function">Uncopyable</span><span class="token punctuation">(</span><span class="token keyword">const</span> Uncopyable<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">//将拷贝函数转移至此</span>
    Uncopyable<span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Uncopyable<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

class House<span class="token operator">:</span>public Uncopyable<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>              <span class="token comment">//公有继承</span></code></pre><br>在c++11中，可以在函数列表后加上=delete防止拷贝。<br><pre class="language-c" data-language="c"><code class="language-c">class Base<span class="token punctuation">&#123;</span>
	public<span class="token operator">:</span>
		<span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	private<span class="token operator">:</span>
		<span class="token function">Base</span><span class="token punctuation">(</span>Base<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span>delete<span class="token punctuation">;</span>
		Base<span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span>Base<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span>delete<span class="token punctuation">;</span>
	friend <span class="token keyword">void</span> <span class="token function">friendfunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><br>总结:</p>
<ul>
<li>当不想让编译器为类自动生成某些函数时，把这些不想要的函数声明在此类的私有成员中，或者更好使用像如上例子的一个父类，并让可以的类公有继承。</li>
</ul>
<h2 id="条款7-为多态基类生成virtual析构函数"><a href="#条款7-为多态基类生成virtual析构函数" class="headerlink" title="条款7 为多态基类生成virtual析构函数"></a>条款7 为多态基类生成virtual析构函数</h2><p>对于多态基类，考虑如下情况：<br><pre class="language-c" data-language="c"><code class="language-c">class TimeKeeper                              <span class="token comment">//计时器类，用来当做基类</span>
<span class="token punctuation">&#123;</span>                              
  public<span class="token operator">:</span>
    <span class="token function">TimeKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                              <span class="token comment">//这是构造函数</span>
    <span class="token operator">~</span><span class="token function">TimeKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                             <span class="token comment">//这是析构函数</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
class AtomicClock <span class="token operator">:</span> public TimeKeeper<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>   <span class="token comment">//原子钟是一种计时器</span>
class WaterClock <span class="token operator">:</span> public TimeKeeper<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">//水钟也是一种计时器</span>

TimeKeeper<span class="token operator">*</span> <span class="token function">getTimeKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>              <span class="token comment">//用来返回一个动态分配的基类对象</span>
TimeKeeper<span class="token operator">*</span> ptk <span class="token operator">=</span> <span class="token function">getTimeKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                         <span class="token comment">//使用这个指针操作它的子类</span>
delete ptk<span class="token punctuation">;</span>                                   <span class="token comment">//使用完毕，释放资源</span></code></pre><br>C++中的new与delete常会导致内存泄漏。<br>如上代码问题在于，当你通过基类指针使用子类，使用完毕后却只从基类删除。同时这个基类的析构函数并不是虚函数(virtual)，也就是不允许子类有自己版本的析构函数，这样就只能删除子类中基类的部分，而子类衍生出来的变量和函数所占用的资源并没有被释放，这就造成了这个对象只被释放了一部分资源的现象，依然会导致内存泄漏。</p>
<p>解决办法：<br>给基类一个虚的析构函数，这样子类就允许拥有自己的析构函数，就能保证被占用的所有资源都会被释放。<br><pre class="language-c" data-language="c"><code class="language-c">class TimeKeeper
<span class="token punctuation">&#123;</span>
  public<span class="token operator">:</span>
    virtual <span class="token operator">~</span><span class="token function">TimeKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><br>但是！如果不用来当做基类，随便把它的析构函数声明为虚函数不是不必要，而是不好！</p>
<p>虚函数是用来在运行时(runtime)，自动把编译时未知的对象，比如用户输入的对象，和它所对应的函数绑定起来并调用。当一个类包含虚函数时，编译器会给这个类添加一个隐藏变量，即虚函数表指针(virtual table pointer)，用来指向一个包含函数指针的数组，即虚函数表(virtual table)。当一个虚函数被调用时，具体调用哪个函数就可以从这个表里找了。<br>问题在于，这个变量也是要占空间的！例如在32位系统里，一个地址占32位，那么这个变量就要占32位，而在64位系统就要占用64位。再举个栗子:<br><pre class="language-c" data-language="c"><code class="language-c">class Point
<span class="token punctuation">&#123;</span>
  public<span class="token operator">:</span>
    <span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  private<span class="token operator">:</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">int</span> y<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><br>这样一个Point的类包含两个整型，因此一个对象要占64位。但如果把析构函数声明为虚函数，在32位系统里就要多占32位，在64位系统里就要多占64位，那么它所占用的空间直接增大了50%到100%。这样一来，对象就刚好不能用一个64位的寄存器装下了。</p>
<p>对于标准库中的类不能随便继承，包括STL，因为这些库的并没有把析构函数定义为虚函数。<br><pre class="language-c" data-language="c"><code class="language-c">class SpecialString <span class="token operator">:</span> public std<span class="token operator">::</span>string<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>      <span class="token comment">//某个继承自标准字符串的类</span>

SpecialString<span class="token operator">*</span> pss <span class="token operator">=</span> new <span class="token function">SpecialString</span><span class="token punctuation">(</span><span class="token string">"Hi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>string<span class="token operator">*</span> ps<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
ps <span class="token operator">=</span> pss<span class="token punctuation">;</span>
delete ps<span class="token punctuation">;</span>                                          <span class="token comment">//使用完后从基类删除内存</span></code></pre><br>如上代码会导致一开始所说的内存泄露问题。</p>
<p>对于抽象类(abstract class)，抽象类是包含至少一个纯虚函数的类(pure virtual function)，而且它们不能被实例化，只能通过指针来操作，是纯粹被用来当做多态的基类的。</p>
<p>相比于具体类(concrete class)，虽然它们都可以通过父类指针来操作子类，但抽象类有更高一层的抽象，从设计的角度上能更好概括某些类的共同特性，比如”狗”相对于”边牧”，”柴犬”，”斗牛”，把”狗”当做基类显然要好过把某个品种当做基类。</p>
<p>因为多态的基类需要有虚析构函数，抽象类又需要有纯虚函数，那么在抽象类中就要把析构函数声明为纯虚函数:<br><pre class="language-c" data-language="c"><code class="language-c">class VBase
<span class="token punctuation">&#123;</span>
  public<span class="token operator">:</span>
    virtual <span class="token operator">~</span><span class="token function">VBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>              <span class="token comment">//"=0"只是一个关键字，用来声明纯虚函数，并不把任何东西设为0</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><br>同时注意，当在继承层级中某一类的析构函数被调用时，它下一级类的析构函数会被随后调用，最后一直到基类的析构函数，因此作为析构函数调用的终点，要保证有一个定义，否则链接器会报错。</p>
<p>一般来讲，可以使用基类都是为了实现多态，那么这些基类就需要虚的析构函数，比如可以的TimeKeeper类，就可以通过TimeKeeper的指针来操作例如AtomicClock这样的子类。但并不是所有的基类都是被用来实现多态的，比如可以在上一章讲过的Uncopyable类，单纯只是为了实现某个功能，而不是希望通过它的指针来操作某个对象，那么就不需要将析构函数声明为虚函数。以及某些类就不是用来当做基类的，比如标准库的string类和STL容器类，也不需要将析构函数声明为虚函数。</p>
<p>总结：</p>
<ul>
<li>用来实现多态的基类应该有声明为虚(virtual)的析构函数。如果一个基类中含有虚函数，那它就是被用来实现多态的，就需要有一个虚的析构函数</li>
<li>某些类不是被用来当做基类的，比如std::string和STL，或者某些不是用来实现多态的基类，比如上一章的Uncopyable，就不需要虚的析构函数。</li>
</ul>
<h2 id="条款8-别在析构函数中抛出异常"><a href="#条款8-别在析构函数中抛出异常" class="headerlink" title="条款8 别在析构函数中抛出异常"></a>条款8 别在析构函数中抛出异常</h2><p>先讲一下什么叫栈展开(stack unwinding)，才能更好理解C++异常(exception)的机制：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">throw</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>           <span class="token comment">//函数f1会抛出一个整型的异常代码</span>
  cout<span class="token operator">&lt;&lt;</span><span class="token string">"f1 starts"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
  <span class="token keyword">int</span> i<span class="token punctuation">;</span>                       <span class="token comment">//这个变量会在栈展开的过程中被释放资源</span>
  throw <span class="token number">100</span><span class="token punctuation">;</span>                   <span class="token comment">//抛出异常，程序开始在栈中搜索对应的异常处理器，即开始栈展开</span>
  cout<span class="token operator">&lt;&lt;</span><span class="token string">"f1 ends"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>       <span class="token comment">//这行代码不会被执行</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> f2 <span class="token function">throw</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//函数f2调用了f1，所以抛出异常的类型也是整型</span>
  cout<span class="token operator">&lt;&lt;</span><span class="token string">"f2 starts"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
  <span class="token keyword">int</span> j<span class="token punctuation">;</span>                      <span class="token comment">//这个变量也会在栈展开的过程中被释放资源</span>
  <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">//f1没有搜索到对应的异常处理，因此返回到f2搜索</span>
  cout<span class="token operator">&lt;&lt;</span><span class="token string">"f2 ends"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>      <span class="token comment">//这行代码也不会被执行</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  cout<span class="token operator">&lt;&lt;</span><span class="token string">"f3 starts"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
  try<span class="token punctuation">&#123;</span>                        <span class="token comment">//函数f3在try里调用f2，并可能会catch一个整型的异常</span>
    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>              <span class="token comment">//f2也没有找到异常处理，最后返回了f3并找到了异常处理</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"exception "</span><span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  cout<span class="token operator">&lt;&lt;</span><span class="token string">"f3 ends"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>在C++里，当有异常被抛出，调用栈(call stack)，即栈中用来储存函数调用信息的部分，会被按次序搜索，直到找到对应类型的处理程序(exception handler)。而这里的搜索顺序就是f1-&gt;f2-&gt;f3。f1没有对应类型的catch块，因此跳到了f2，但f2也没有对应类型的catch块，因此跳到f3才能处理掉这个异常。</p>
<p>以上这个寻找异常相应类型处理器的过程就叫做栈展开。同时在这一过程中，当从f1返回到f2时，f1里局部变量的资源会被清空，即调用了对象的析构函数。同样，在从f2返回到f3时，f2里局部变量也会被调用析构函数并清空资源。</p>
<p>C++并不阻止在类的析构函数中抛出异常，但这是一个非常不好的做法。因为栈展开的前提是已经有一个未处理的异常，并且栈展开会自动调用函数本地对象的析构函数，如果这时对象的析构函数时又抛出一个异常，现在就同时有两个异常出现，但C++最多只能同时处理一个异常，因此程序这时会自动调用std::terminate()函数，导致可以所谓的闪退或者崩溃。</p>
<p>如下栗子也会导致程序同时出现多个异常：<br><pre class="language-c" data-language="c"><code class="language-c">class Widget<span class="token punctuation">&#123;</span>
  public<span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>        <span class="token comment">//假设此析构函数可能会抛出异常</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Widget<span class="token operator">></span> v<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>                         <span class="token comment">//在这一行调用了v的析构函数，资源被释放</span></code></pre><br>当v被调用析构函数，它包含的所有Widget对象也都会被调用析构函数。又因为v是一个容器，如果在释放第一个元素时触发了异常，它也只能继续释放别的元素，否则会导致其它元素的资源泄露。如果在释放第二个元素的时候又触发了异常，那么程序同样会导致崩溃。不仅仅是std::vector，所有STL容器的类甚至包括数组也都会像这样因为析构函数抛出异常而崩溃程序，所以在C++中，不要让析构函数抛出异常！</p>
<p>如果不得不抛出异常呢，如下：<br><pre class="language-c" data-language="c"><code class="language-c">class DBConnection<span class="token punctuation">&#123;</span>                   <span class="token comment">//某用来建立数据库连接的类</span>
  public<span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">static</span> DBConnection <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//建立一个连接</span>
    <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">//关闭一个连接，假设可以抛出异常</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

class DBConn<span class="token punctuation">&#123;</span>                         <span class="token comment">//创建一个资源管理类来提供更好的用户接口</span>
  public<span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token operator">~</span>DBConn<span class="token punctuation">&#123;</span> db<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">]</span>            <span class="token comment">//终止时自动调用关闭连接的方法</span>
  private<span class="token operator">:</span>
    DBConnection db<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#123;</span>                                 
  DBConn <span class="token function">dbc</span><span class="token punctuation">(</span>DBConnection<span class="token operator">::</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建一个DBConn类的对象</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                
<span class="token punctuation">&#125;</span>      
<span class="token comment">//对象dbc被释放资源</span>
<span class="token comment">//但它的析构函数调用了可能会抛出异常的close()方法</span></code></pre><br>可以通过DBConn的析构函数来释放资源并关闭连接，但析构函数所调用的close()方法可能会抛出异常，那么有什么方法来解决呢？<br>有三个方法：</p>
<ul>
<li><p>栈展开的过程终止于异常被对应类型的catch块接到，因此在这种情况下，只要catch包括了所有可能的异常，析构函数就能消化掉这个异常，防止异常从析构函数里跑出来，和别的异常产生冲突。</p>
<pre class="language-c" data-language="c"><code class="language-c">DBConn<span class="token operator">::</span><span class="token operator">~</span><span class="token function">DBConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  try<span class="token punctuation">&#123;</span> 
    db<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token comment">//记录访问历史</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p>通过std::abort()函数来主动关闭程序，而不是任由程序在某个随机时刻突然崩溃，这样能减少潜在的用户风险。对于某些比较严重的异常，就可以使用这个方法。并且可以结合使用上面的方法，把能处理的异常消化掉。</p>
<pre class="language-c" data-language="c"><code class="language-c">DBConn<span class="token operator">::</span><span class="token operator">~</span><span class="token function">DBConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  try<span class="token punctuation">&#123;</span> 
    db<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token comment">//记录访问历史</span>
    std<span class="token operator">::</span><span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
<li><p>把可能抛出异常的代码移出析构函数，设计DBConn类的更安全的接口，让其他函数来承担这个风险，而且这样也可以事先在析构函数这样的紧要关头前对异常做出处理。</p>
<pre class="language-c" data-language="c"><code class="language-c">class DBConn<span class="token punctuation">&#123;</span>
  public<span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token operator">~</span><span class="token function">DBConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//当要关闭连接时，手动调用此函数</span>
  private<span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    closed <span class="token operator">=</span> true<span class="token punctuation">;</span>       <span class="token comment">//显示连接是否被手动关闭</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> DBConn<span class="token operator">::</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//当需要关闭连接，手动调用此函数</span>
  db<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  closed <span class="token operator">=</span> true<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

DBConn<span class="token operator">::</span><span class="token operator">~</span><span class="token function">DBcon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>closed<span class="token punctuation">)</span>            <span class="token comment">//析构函数虽然还是要留有备用，但不用每次都承担风险了</span>
    try<span class="token punctuation">&#123;</span>
      db<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
      <span class="token comment">//记录访问历史</span>
      <span class="token comment">//消化异常或者主动关闭</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
</li>
</ul>
<p>总结：</p>
<ul>
<li>不要让异常从析构函数里跑出来。如果析构函数的某些代码可能会抛出异常，要保证它们能在跑出析构函数之前被catch块接到，然后选择消化异常还是终止程序。</li>
<li>可以把可能抛出异常的代码从析构函数中移到别的函数里，这样就可以事先对异常做出反应。</li>
</ul>
<h2 id="条款9-不要在构造函数和析构函数中调用虚函数"><a href="#条款9-不要在构造函数和析构函数中调用虚函数" class="headerlink" title="条款9 不要在构造函数和析构函数中调用虚函数"></a>条款9 不要在构造函数和析构函数中调用虚函数</h2><p>考虑如下情况<br><pre class="language-c" data-language="c"><code class="language-c">class Transaction<span class="token punctuation">&#123;</span>                              <span class="token comment">//股市交易的基类</span>
  public<span class="token operator">:</span>
    <span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    virtual <span class="token keyword">void</span> <span class="token function">logTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">//该函数用来记录交易历史，是一个纯虚函数</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

Transaction<span class="token operator">::</span><span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">logTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                             <span class="token comment">//在基类的构造函数中调用了这个纯虚函数</span>
<span class="token punctuation">&#125;</span></code></pre><br>同时又有表示”买进”和”卖出”的类，继承自以上的”交易”:<br><pre class="language-c" data-language="c"><code class="language-c">class BuyTransaction <span class="token operator">:</span> public Transaction<span class="token punctuation">&#123;</span>
  public<span class="token operator">:</span>
    virtual <span class="token keyword">void</span> <span class="token function">logTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

class SellTransaction <span class="token operator">:</span> public Transaction<span class="token punctuation">&#123;</span>
  public<span class="token operator">:</span>
    virtual <span class="token keyword">void</span> <span class="token function">logTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><br>假设在某处定义一个“买进”类的对象：<br><pre class="language-c" data-language="c"><code class="language-c">BuyTransaction b<span class="token punctuation">;</span></code></pre><br>显然这里调用了”BuyTransaction”的构造函数。但因为在C++中，当子类开始构造时，它所包含的父类的部分要先完成构造，所以率先调用的构造函数是它的父类”Transaction”的构造函数。现在问题来了，因为父类的构造函数调用了一个纯虚函数，这就会导致即使创建的是它的子类对象，这个虚函数也不会绑定到子类的版本上，而是使用的父类版本。</p>
<p>这就”有悖常理”了，虚函数不是会自动绑定到继承层级里对应的一个类吗？其实C++这样做是有一个很好的原因的。在条款四中提到，使用未初始化的数据可能会给程序带来风险。因为在创建一个子类对象时，它的父类部分会先被创建。当父类的构造函数刚刚调用完成时，可以只能保证父类部分的数据被初始化，而不能保证衍生部分的被初始化。如果现在让这个虚函数去对应子类的版本，就可能会因为使用未初始化的数据而导致程序运行时错误。</p>
<p>事实上，正是由于这个原因，当一个子类对象在完成它自己全部成员的构造之前，C++只会把它当成父类，除了虚函数还包括typeid，dynamic_cast等，都会把当前对象当做父类，用来规避使用未初始化数据可能带来的风险。</p>
<p>同样的原理，也不要让析构函数调用虚函数。在条款7讲过，析构函数的调用顺序是从子类到父类，与构造函数的调用顺序是相反的。当子类部分的成员数据被删除时，C++同样会把当前的对象认为是父类，如果这时调用了虚函数，也会导致错误版本的虚函数被调用。</p>
<p>实际上这样在构造函数或者析构函数里直接调用虚函数，在某些编译器中是会发出警告的。不过即使无视掉这些警告，因为调用的是一个纯虚函数，通常是不会有定义的，所以在之后的链接过程中，链接器也会报错。</p>
<p>但如下的代码做了完全一样的事，编译器和链接器却都不会发出警告或报错。这样的代码相比前面的就更具有潜在危害性:<br><pre class="language-c" data-language="c"><code class="language-c">class Transaction
<span class="token punctuation">&#123;</span>
  public<span class="token operator">:</span>
    <span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>                  <span class="token comment">//调用了一个专门的init()函数</span>
    virtual <span class="token keyword">void</span> logTransaction <span class="token keyword">const</span> <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  private<span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                              <span class="token comment">//这个函数不是虚函数，而且有定义</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment">//编译器和链接器就都不会报错</span>
      <span class="token function">logTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">//但里面却包含了虚函数的代码</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><br>即使init()函数有定义而且不是虚函数，它却调用了没有定义的纯虚函数logTransaction()，这就会导致在运行过程中，一旦使用了这里的代码，程序就会崩溃。</p>
<p>就算logTransaction()函数是一个有定义的”普通的”虚函数，即没有”=0”关键字来修饰，程序虽然不会因为缺少定义而闪退，但却一样会在子类的构造过程中调用错误版本的虚函数。所以万全的解决方法就是，不管是纯虚的还是普通的，就不要在构造或者析构函数中调用虚函数。</p>
<p>但如果一定想要对象在初始化的时候完成某些任务呢？那可以就需要在父类Transaction中，把虚函数logTransaction去掉virtual关键字，变成普通的函数，然后在子类构造过程中，把某些信息传递到父类的构造函数中。<br><pre class="language-c" data-language="c"><code class="language-c">class Transaction<span class="token punctuation">&#123;</span>
  public<span class="token operator">:</span>
    explicit <span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> info<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//explicit关键字用来防止隐式转换</span>
    <span class="token keyword">void</span> <span class="token function">logTransaction</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> info<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment">//增加一个传递参数，就可以从子类获得信息了</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

Transaction<span class="token operator">::</span><span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> info<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">logTransaction</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">&#125;</span></code></pre><br>现在就可以在子类对象中如下定义构造函数了，这样就能把子类的信息传递到父类中，让父类构造函数去完成子类构造函数想做的事：<br><pre class="language-c" data-language="c"><code class="language-c">class BuyTransaction <span class="token operator">:</span> public Transaction<span class="token punctuation">&#123;</span>
  public<span class="token operator">:</span>
    <span class="token function">BuyTransaction</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token function">createLog</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  private<span class="token operator">:</span>
    <span class="token keyword">static</span> std<span class="token operator">::</span>string <span class="token function">createLog</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><br>这里createLog()就是一个辅助函数(helper function)，用来将某函数的一部分功能封装成另一个小函数，减少代码的复杂性，使代码更加可读。此外，因为这是一个子类的私有成员，父类构造函数被调用时不能保证它被初始化，所以使用static关键字可以避免意外使用了未初始化的成员数据。</p>
<p>总结：</p>
<ul>
<li>不要在构造函数或者析构函数中调用虚函数，因为这样的虚函数只会对应起来当前构造或析构的类，不会上升到它的任何子类。</li>
</ul>
<h2 id="条款10-赋值操作符返回-this的引用"><a href="#条款10-赋值操作符返回-this的引用" class="headerlink" title="条款10 赋值操作符返回*this的引用"></a>条款10 赋值操作符返回*this的引用</h2><p>c++中有如下用法：<br><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> x <span class="token punctuation">,</span> y <span class="token punctuation">,</span> z<span class="token punctuation">;</span>
x <span class="token operator">=</span> y <span class="token operator">=</span> z <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span>
<span class="token comment">//上述代码会被编译器从最右开始解析</span>
x <span class="token operator">=</span> <span class="token punctuation">(</span>y <span class="token operator">=</span> <span class="token punctuation">(</span>z <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><br>对于自定义的类，赋值操作符应遵循如下两点规则:</p>
<ul>
<li>返回类型是当前类的引用</li>
<li>返回*this给左边的变量</li>
</ul>
<p>这个规则对+=, -=, *=等操作符同样适用。C++的自有类型，例如int, double，标准库的类型，例如std::string, std::complex，它们的赋值操作符都遵循这样的规则。</p>
<p>关于this，this是用来指向当前对象的指针，只存在于类的成员函数里，用来防止成员数据和成员函数参数的歧义:</p>
<pre class="language-c" data-language="c"><code class="language-c">class MessageBox<span class="token punctuation">&#123;</span>
  public<span class="token operator">:</span>
    <span class="token function">MessageBox</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  private<span class="token operator">:</span>
    std<span class="token operator">::</span>string<span class="token operator">&amp;</span> message<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

MessageBox<span class="token operator">::</span><span class="token function">MessageBox</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> message<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  this <span class="token operator">-></span> message <span class="token operator">=</span> message<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>这里MessageBox类有一个数据成员叫message，同时它的构造函数也有一个参数叫message，此时为了避免歧义，可以用this-&gt;message来代表当前类的message成员。</p>
<p>总结：</p>
<ul>
<li>赋值操作符应返回一个指向*this的引用</li>
</ul>
<h2 id="条款11-在operator-中处理自我赋值（self-assingment）"><a href="#条款11-在operator-中处理自我赋值（self-assingment）" class="headerlink" title="条款11 在operator= 中处理自我赋值（self assingment）"></a>条款11 在operator= 中处理自我赋值（self assingment）</h2><p>自我赋值：<br><pre class="language-c" data-language="c"><code class="language-c">class Widget<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
Widget w<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
w <span class="token operator">=</span> w<span class="token punctuation">;</span>             <span class="token comment">//自赋值</span>

a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">//如果i==j,那么这行代码也构成自赋值</span>
<span class="token operator">*</span>px <span class="token operator">=</span> <span class="token operator">*</span>py<span class="token punctuation">;</span>         <span class="token comment">//如果px和py指向了同一个对象，这行代码也构成自赋值</span></code></pre><br>以上的情况都是别名(aliasing)的后果，即某个对象可以通过多于一个符号名被访问，比如上面px和py如果被声明为同一个类型，它们就可以同时可以指向同一个对象。但在一个继承层级中，即使两个对象被声明为了不同的类型，别名依然可能发生，因为基类指针或者引用可以指向任何一个它的子类，例如:</p>
<pre class="language-c" data-language="c"><code class="language-c">class Base<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
class Derived <span class="token operator">:</span> public Base<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>               <span class="token comment">//同一个继承层级中</span>

<span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token keyword">const</span> Base<span class="token operator">&amp;</span> rb<span class="token punctuation">,</span> Derived<span class="token operator">*</span> pd<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//rb与pd就可能指向同一个对象</span></code></pre>
<p>如果要手动管理资源而不使用资源管理类的话(resource managing class，见第13章)，的赋值操作符就可能不是自赋值安全的(self-assignment-safe):</p>
<p>考虑如下代码：<br><pre class="language-c" data-language="c"><code class="language-c">class Bitmap<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>
class Widget<span class="token punctuation">&#123;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  private<span class="token operator">:</span>
    Bitmap <span class="token operator">*</span>bp<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

Widget<span class="token operator">&amp;</span> Widget<span class="token operator">::</span>operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  delete pb<span class="token punctuation">;</span>
  pb <span class="token operator">=</span> new <span class="token function">Bitmap</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre><br>如果传入的参数rhs本身，就会导致delete语句把*this自己的资源释放掉，同时也释放掉了rhs的资源，最后返回的*this包含了一个损坏的数据，不能访问不能修改，甚至不能通过delete来为其释放资源，等于说这段空间就凭空消失了，所以这段代码不是自赋值安全的。</p>
<p>解决方法：</p>
<ul>
<li>1 检查传入的参数是不是*this<pre class="language-c" data-language="c"><code class="language-c">Widget<span class="token operator">&amp;</span> Widget<span class="token operator">::</span>operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>

  <span class="token keyword">if</span><span class="token punctuation">(</span>this <span class="token operator">==</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>             <span class="token comment">//先做一个身份检测</span>
    <span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span>

  delete pb<span class="token punctuation">;</span>                   <span class="token comment">//如果不是自己，再执行如下操作</span>
  pb <span class="token operator">=</span> new <span class="token function">Bitmap</span><span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">.</span>pb<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
但是这个方法有个问题，当执行完delete，执行new语句时抛出异常，会导致*this储存了一个损坏的数据。</li>
<li>2 重新排列语句<pre class="language-c" data-language="c"><code class="language-c">Widget<span class="token operator">&amp;</span> Widget<span class="token operator">::</span>operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  Bitmap <span class="token operator">*</span>pOrigin <span class="token operator">=</span> pb<span class="token punctuation">;</span>            <span class="token comment">//先保存一个原pb的备份</span>
  pb <span class="token operator">=</span> new <span class="token function">Bitmap</span><span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">.</span>pb<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//拷贝过来rhs的pb</span>
  delete pOrigin<span class="token punctuation">;</span>                  <span class="token comment">//只删除备份</span>
  <span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
这条解决方法既对自赋值安全，对异常也是安全的。如果现在new的这行抛出了异常，指针pb也不会被提前删除。同时这样的语句排列省去了上一条解决方法身份检测的步骤，因为即使传入的rhs是*this本身，最后删除的也只是备份而不是*this自己的pb。</li>
<li>3 先拷贝再调换<pre class="language-c" data-language="c"><code class="language-c">class Widget<span class="token punctuation">&#123;</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//把rhs和*this的数据成员互相调换</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

Widget<span class="token operator">&amp;</span> widget<span class="token operator">::</span>operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  Widget <span class="token function">temp</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//拷贝rhs</span>
  <span class="token function">swap</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">//将*this的数据与这个拷贝的数据调换</span>
  <span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//还可以使用另一种形式</span>
Widget<span class="token operator">&amp;</span> Widget<span class="token operator">::</span><span class="token function">operator</span><span class="token punctuation">(</span>Widget rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
这样的代码虽然可能违反了函数要使用常量引用传递的惯例，但这样做确实能减少源代码和目标代码的长度，增加了效率。</li>
</ul>
<p>总结：</p>
<ul>
<li>赋值操作符要考虑到自赋值，使用参数身份检测，排列语句，先拷贝再调换的方法来确保代码是自赋值安全的。</li>
<li>同样当一个函数使用多个参数时，也要确保函数能在这些参数同时指向同一个对象时可以工作正常。</li>
</ul>
<h2 id="条款12-完整拷贝对象"><a href="#条款12-完整拷贝对象" class="headerlink" title="条款12 完整拷贝对象"></a>条款12 完整拷贝对象</h2><p>C++有两种拷贝函数(copying function): 拷贝构造函数(copy constructor)和拷贝赋值操作符(copy assignment operator)。如果在自己定义的类中不声明这些拷贝函数，编译器会自动为你生成。如果我们声明了自己的拷贝函数，程序将会执行我们自己的拷贝函数。</p>
<p>查看以下例子：<br><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">logCall</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> funcName<span class="token punctuation">)</span><span class="token punctuation">;</span>
class Customer<span class="token punctuation">&#123;</span>
  public<span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">Customer</span><span class="token punctuation">(</span><span class="token keyword">const</span> Customer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Customer<span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Customer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
  private<span class="token operator">:</span>
    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

Customer<span class="token operator">::</span><span class="token function">Customer</span><span class="token punctuation">(</span><span class="token keyword">const</span> Customer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">name</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">//使用初始化列表</span>
  <span class="token function">logCall</span><span class="token punctuation">(</span><span class="token string">"Customer copy constructor"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

Customer<span class="token operator">&amp;</span> Customer<span class="token operator">::</span>operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Customer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token function">logCall</span><span class="token punctuation">(</span><span class="token string">"Customer copy assignment operator"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  name <span class="token operator">=</span> rhs<span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token comment">//拷贝数据</span>
  <span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span>       <span class="token comment">//返回*this，见第10章</span>
<span class="token punctuation">&#125;</span></code></pre><br>如果新增一个数据成员：<br><pre class="language-c" data-language="c"><code class="language-c">class Date<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
class Cutomer<span class="token punctuation">&#123;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  private<span class="token operator">:</span>
    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>
    Data lastTransaction<span class="token punctuation">;</span>     <span class="token comment">//新增了一个交易日期的数据成员</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><br>如果依然使用相同的两种拷贝函数，只能得到一个部分拷贝对象。</p>
<p>C++的这两种拷贝函数有相似的功能和代码，如果想要节省代码，可以写另一个函数来给每个成员赋值，一般叫做init()</p>
<p>总结：</p>
<ul>
<li>拷贝函数要照顾到类的所有部分，包括所有的数据成员和它的基类部分</li>
<li>不要用一个拷贝函数来实现另一个拷贝函数，两种拷贝函数的语义不同。如果要节省代码，可以另写一个init()函数让两个拷贝函数来调用。</li>
</ul>
<h1 id="资源管理-条款-13-17"><a href="#资源管理-条款-13-17" class="headerlink" title="资源管理 条款(13~17)"></a>资源管理 条款(13~17)</h1><h2 id="条款13-用对象来管理资源"><a href="#条款13-用对象来管理资源" class="headerlink" title="条款13  用对象来管理资源"></a>条款13  用对象来管理资源</h2><p>资源是一个很宽泛的概念，但总体来讲，资源是我们可以用来使用，并且使用完之后要返还给系统的东西。在C++中，资源多数是指动态分配的内存。如果你只用new来分配内存却不在使用完后delete掉，将会导致内存泄漏。</p>
<p>其他资源比如文件描述符(file descriptor)，Mutex锁，GUI中的字体(font)和画刷(brush)，网络接口(socket)，但不论资源是什么，我们一定要保证在使用过后要及时释放，否则就会造成资源泄露。当我们的代码变得越来越复杂，比如增加了异常抛出，函数不同的返回路径，手动管理资源将会变得费时费力，因此我们需要用对象来管理资源。</p>
<p>假设我们在为不同类型的投资写一个库:<br><pre class="language-c" data-language="c"><code class="language-c">class Investment<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>            <span class="token comment">//Investment继承层级的基类</span>
Investment<span class="token operator">*</span> <span class="token function">createInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//返回一个动态分配的Investment层级对象指针</span></code></pre><br>返回一个指针就说明我们要负责在用毕后及时释放资源:<br><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  Intestment<span class="token operator">*</span> pInv <span class="token operator">=</span> <span class="token function">createInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//分配</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                    <span class="token comment">//使用</span>
  delete pInv<span class="token punctuation">;</span>                           <span class="token comment">//释放</span>
<span class="token punctuation">&#125;</span></code></pre><br>如果中间部分存在并触发了一个return语句，最后的delete语句便会被跳过。如果用在循环里，中间存在并触发了break或goto语句，delete也不会被执行。同样如果中间的代码抛出了异常，这个指针也不会被删除掉。如果这个动态分配的对象没有被清理掉，不仅仅是它占用的内存资源泄露，它所占有的所有资源也将泄露。</p>
<p>解决方法：<br>使用引用计数的智能指针(Reference-Counting Smart Pointer, RCSP)，它在运行时会统计有多少对象指向当前的资源，然后当没有任何对象指向当前资源时便会自动释放，<code>shared_ptr</code>可以在STL容器中使用。<br><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">pInv</span><span class="token punctuation">(</span><span class="token function">createInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span>  <span class="token comment">//无需手动释放</span>

std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">pInv1</span><span class="token punctuation">(</span><span class="token function">createInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>investment<span class="token operator">></span> <span class="token function">pInv2</span><span class="token punctuation">(</span>pInv1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//pInv1保持不变</span>
pInv1 <span class="token operator">=</span> pInv2<span class="token punctuation">;</span>                                  <span class="token comment">//pInv2保持不变</span></code></pre><br>使用智能指针只是用对象管理资源的方法之一，而且也存在着局限性。例如我们不能使用标准库的智能指针来指向一个动态分配的数组。</p>
<p>总结：</p>
<ul>
<li>防止资源泄露，从RAII做起。获取资源在构造过程中，释放资源在析构过程中。</li>
<li><code>std::shared_ptr</code>和<code>auto_ptr</code>是两个常用的RAII类。一般情况下<code>std1::shared_ptr</code>是更好的选择，因为它的拷贝不会影响到其它对象，并且支持STL容器。</li>
</ul>
<h2 id="条款14-资源管理类的拷贝"><a href="#条款14-资源管理类的拷贝" class="headerlink" title="条款14 资源管理类的拷贝"></a>条款14 资源管理类的拷贝</h2><p>对于堆之外的资源，例如Mutex锁，智能指针就不太好用。<br><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span>Mutex<span class="token operator">*</span> pm<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//锁住pm指向的锁</span>
<span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span>Mutex<span class="token operator">*</span> pm<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//解锁pm指向的锁</span></code></pre><br>同时我们有一个符合RAII规范的类来管理这些锁，RAII即获取资源在对象构造过程中，释放资源在对象析构过程中:<br><pre class="language-c" data-language="c"><code class="language-c">class Lock
<span class="token punctuation">&#123;</span>
public<span class="token operator">:</span>
    explicit <span class="token function">Lock</span><span class="token punctuation">(</span>Mutex <span class="token operator">*</span>pm<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">mutexPtr</span><span class="token punctuation">(</span>pm<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">lock</span><span class="token punctuation">(</span>mutexPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>                             <span class="token comment">//在构造时获取资源，上锁</span>
    <span class="token operator">~</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">unlock</span><span class="token punctuation">(</span>mutexPtr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//在析构时释放资源，解锁</span>
private<span class="token operator">:</span>
    Mutex <span class="token operator">*</span>mutexPtr<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><br>例如访问临界区(critical section), 临界区即线程必须互斥地访问某些资源，这些资源必须只能由最多一个线程访问，我们就需要以RAII的方式来进行操作:<br><pre class="language-c" data-language="c"><code class="language-c">Mutex m<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#123;</span>              <span class="token comment">//创建一个代码块来定义临界区</span>
  Lock <span class="token function">ml</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//构造锁ml，锁住m</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>          <span class="token comment">//执行临界区操作</span>
<span class="token punctuation">&#125;</span>              <span class="token comment">//临界区结束，调用ml的析构函数，解锁</span></code></pre><br>到现在为止以上的用法都是没有问题的，如果锁被拷贝了呢？<br><pre class="language-c" data-language="c"><code class="language-c">Lock <span class="token function">ml1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//m在ml1的构造过程中被锁住</span>
Lock <span class="token function">ml2</span><span class="token punctuation">(</span>ml1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//把ml1拷贝进ml2，会发生什么?</span></code></pre><br>在创建自己的RAII资源管理类时，我们必须要思考需要如何规定这个类的拷贝行为。对于这个问题，我们有如下选择:</p>
<ul>
<li>禁止拷贝<br>如条款6中的把拷贝函数声明为私有来禁止拷贝</li>
<li>给资源引用计数：<br>有时需要一直持有一个资源直到最后一个对象使用完毕，要实现这样的功能，必须有一个计数器来统计当前有多少对象在使用这个资源。当生成一个拷贝时加一，当删除一个拷贝时减一，和<code>shared_ptr</code>是一样的原理。<br>可以替代裸指针把<code>shared_ptr</code>作为RAII对象的数据成员来实现这个功能，将<code>mutexPtr</code>的类型从<code>Mutex*</code>变成<code>shared_ptr&lt;Mutex&gt;</code>。我们知道默认下的<code>shared_ptr</code>在引用计数为零时会删除掉它所包含的指针，但对于<code>Mutex</code>锁，我们想要的是解锁而不是删除掉，否则我们是没有办法解开一个被删除的锁的。<pre class="language-shared_ptr```提供了一个特殊的可定义函数，删除器(deleter)，即在引用计数为零时调用的函数，是```shared_ptr```构造函数的一个附加参数。这个函数在```auto_ptr```中是不存在的，因此它不能有自定义的删除行为，只能删除掉它包括的指针。" data-language="shared_ptr```提供了一个特殊的可定义函数，删除器(deleter)，即在引用计数为零时调用的函数，是```shared_ptr```构造函数的一个附加参数。这个函数在```auto_ptr```中是不存在的，因此它不能有自定义的删除行为，只能删除掉它包括的指针。"><code class="language-shared_ptr```提供了一个特殊的可定义函数，删除器(deleter)，即在引用计数为零时调用的函数，是```shared_ptr```构造函数的一个附加参数。这个函数在```auto_ptr```中是不存在的，因此它不能有自定义的删除行为，只能删除掉它包括的指针。">&#96;&#96;&#96;c
class Lock&#123;
  public:
    explicit Lock(Mutex* pm)
    :mutexPtr(pm, unlock)    &#x2F;&#x2F;将unlock函数绑定到删除器
    &#123;lock(mutexPtr.get());&#125;
    &#x2F;&#x2F;这里其实不需要定义析构函数
  private:
    std::shared_ptr&lt;Mutex&gt; mutexPtr; &#x2F;&#x2F;使用shared_ptr，不使用裸指针
&#125;;</code></pre></li>
<li><p>深拷贝封装的资源：<br>有时候我们可以拥有某个资源的多份拷贝，那么我们的资源管理类就要确保每一份拷贝都要在使用周期结束后释放资源，并且每一份拷贝互不干涉，因此拷贝这样的对象就要拷贝它包含的所有资源，进行深拷贝(deep copy)。例如当对象包含一个指针，我们必须先生成一个指针的拷贝，分配一个新的内存空间再把数据拷贝过来，这就是深拷贝。如果是浅拷贝，拷贝则直接使用了本体的指针成员，没有生成指针的拷贝，那么两个对象的指针成员就会指向同一个地址，删除拷贝就会导致本体被删除。</p>
</li>
<li><p>转移所有权：<br>有时候想要只有一个对象来持有这个资源，因此进行拷贝的时候，资源的所有权就要从本体转移到拷贝上，本体不再持有资源</p>
</li>
</ul>
<p>总结：</p>
<ul>
<li>拷贝RAII资源管理类的对象要根据它所包含的资源来具体考虑，我们想要资源展现出如何的拷贝行为，资源管理类就要展现出同样的拷贝行为。</li>
<li>常用的RAII类的拷贝行为有禁止拷贝，使用引用计数，拷贝资源，转移所有权，但也可以用其他做法来符合特殊需要。</li>
</ul>
<h2 id="条款15-提供对原始资源的访问"><a href="#条款15-提供对原始资源的访问" class="headerlink" title="条款15 提供对原始资源的访问"></a>条款15 提供对原始资源的访问</h2><p>使用条款13中的投资栗子：<br><pre class="language-c" data-language="c"><code class="language-c">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">pInv</span><span class="token punctuation">(</span><span class="token function">createInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//某个Investment的智能指针对象</span></code></pre><br>现有函数：<br><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">daysHeld</span><span class="token punctuation">(</span><span class="token keyword">const</span> Investment<span class="token operator">*</span> pi<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回某个Investment对象的持有时间</span></code></pre><br>如果直接把智能指针对象传入上面的函数中：<br><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> days <span class="token operator">=</span> <span class="token function">daysHeld</span><span class="token punctuation">(</span>pInv<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><br>这样编译器会报错，因为函数需要裸指针类型的参数，而你传入的是智能指针类型。你需要做的也很简单，把智能指针转换为裸指针，使用隐式转换或者显式转换。</p>
<p>shared_ptr有一个成员函数get()，用来执行显式转换，返回智能指针对象所包含的裸指针:</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> days <span class="token operator">=</span> <span class="token function">daysHeld</span><span class="token punctuation">(</span>pInv<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>shared_ptr重载了指针的解引用运算符，即-&gt;和*，这意味着我们可以通过它们来实现隐式转换：</p>
<pre class="language-c" data-language="c"><code class="language-c">class Investment<span class="token punctuation">&#123;</span>  <span class="token comment">//定义Investment继承层次的基类</span>
  public<span class="token operator">:</span>
    boos <span class="token function">isTaxFree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

Investment<span class="token operator">*</span> <span class="token function">createInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//用来返回指向Investment对象的指针</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">pi1</span><span class="token punctuation">(</span><span class="token function">createInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//使用shared_ptr管理资源</span>
bool taxable1 <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span>pi1<span class="token operator">-></span><span class="token function">isTaxFree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//使用->操作符接触资源</span></code></pre>
<p>有时我们需要把RAII资源管理对象所封装的原始资源拿出来，我们可以定义一个转换函数，将资源管理类隐式或显式转换为原始资源。例如要实现对C API中的字体类型(font)的资源管理:<br><pre class="language-c" data-language="c"><code class="language-c">FontHandle <span class="token function">getFont</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//C API定义的分配字体函数</span>
<span class="token keyword">void</span> <span class="token function">releaseFont</span><span class="token punctuation">(</span>FontHandle fh<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//C API定义的释放字体函数</span></code></pre></p>
<p>现在我们定义自己的RAII资源管理类：<br><pre class="language-c" data-language="c"><code class="language-c">class Font<span class="token punctuation">&#123;</span>
  public<span class="token operator">:</span>
    explicit <span class="token function">Font</span><span class="token punctuation">(</span>FontHandle fh<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token comment">//C只能使用值传递</span>
    <span class="token function">f</span><span class="token punctuation">(</span>fh<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">//构造时获取资源</span>
    <span class="token operator">~</span><span class="token function">Font</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">releaseFont</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token comment">//析构时释放资源</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  private<span class="token operator">:</span>
    FontHandle f<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><br>如果我们要使用某些C API只能使用FontHandle类型，我们就需要把Font类型显式转换为FontHandle类型，因此我们定义一个显式转换的函数get():<br><pre class="language-c" data-language="c"><code class="language-c">class Font<span class="token punctuation">&#123;</span>
  public<span class="token operator">:</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  FontHandle <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> f<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token comment">//显式转换函数</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><br>这样写有两个缺点，第一个就是每次显示转换都需要使用get()函数；第二个<br><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">changeFontSize</span><span class="token punctuation">(</span>FontHandle f<span class="token punctuation">,</span> <span class="token keyword">int</span> newSize<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//改变字体大小的C API</span>
Font <span class="token function">f</span><span class="token punctuation">(</span><span class="token function">getFont</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> newFontSize<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token function">changeFontSize</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> newFontSize<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//需要使用get()来显式转换</span></code></pre></p>
<p>总结：</p>
<ul>
<li>API通常需要使用原始资源作为参数，因此我们的RAII资源管理类要保证它所封装的资源是对外界可接触的。</li>
<li>可以通过隐式转换或显式转换来实现对外接触。显式转换总体上更安全，隐式转换则对用户更加方便。</li>
</ul>
<h2 id="条款16-成对使用new和delete时需要使用对应的形式"><a href="#条款16-成对使用new和delete时需要使用对应的形式" class="headerlink" title="条款16 成对使用new和delete时需要使用对应的形式"></a>条款16 成对使用new和delete时需要使用对应的形式</h2><p>考虑如下栗子：<br><pre class="language-c" data-language="c"><code class="language-c">std<span class="token operator">::</span>string <span class="token operator">*</span>strArr <span class="token operator">=</span> new std<span class="token operator">::</span>string<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//动态分配100元素的字符串数组</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token comment">//使用</span>
delete strArr<span class="token punctuation">;</span>  <span class="token comment">//释放</span></code></pre><br>这样只会释放第一个元素。</p>
<p>当使用<code>new</code>运算符的时候会发生两件事，申请的内存空间会先被分配出来，然后一个或者多个对象的构造函数被调用来填满这些空间。当使用<code>delete</code>的时候，则是先调用这些对象的析构函数，最后释放内存资源。</p>
<pre class="language-delete```要删除多少个对象取决于在当前内存空间中调用多少个析构函数，那么编译器就需要知道到底是删除单个对象还是一个数组，因为单个对象和一个数组的对象有不同的内存布局：数组的内存除了它所包含的对象，还包括了一个额外的数，即数组的大小，用来告诉编译器调用多少个析构函数:" data-language="delete```要删除多少个对象取决于在当前内存空间中调用多少个析构函数，那么编译器就需要知道到底是删除单个对象还是一个数组，因为单个对象和一个数组的对象有不同的内存布局：数组的内存除了它所包含的对象，还包括了一个额外的数，即数组的大小，用来告诉编译器调用多少个析构函数:"><code class="language-delete```要删除多少个对象取决于在当前内存空间中调用多少个析构函数，那么编译器就需要知道到底是删除单个对象还是一个数组，因为单个对象和一个数组的对象有不同的内存布局：数组的内存除了它所包含的对象，还包括了一个额外的数，即数组的大小，用来告诉编译器调用多少个析构函数:">&#96;&#96;&#96;c
int a[5] &#x3D; &#123;0&#125;;
int *b &#x3D; new int[5];
std::cout &lt;&lt; sizeof(a) &lt;&lt; &quot; &quot; &lt;&lt; sizeof(b) &lt;&lt; &quot;\n&quot;;

&#x2F;&#x2F;结果： 20 8</code></pre>
<p>总结：</p>
<ul>
<li>如果在<code>new</code>语句中使用了[ ]，就必须在对应的<code>delete</code>语句中也使用[ ]。如果在new语句中没有使用[ ]，就不要在对应的<code>delete</code>语句中使用[ ]。</li>
</ul>
<h2 id="条款17-以独立语句将newed对象置入智能指针"><a href="#条款17-以独立语句将newed对象置入智能指针" class="headerlink" title="条款17 以独立语句将newed对象置入智能指针"></a>条款17 以独立语句将newed对象置入智能指针</h2><p>考虑以下代码：<br><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">priority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">processWidget</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> pw<span class="token punctuation">,</span> <span class="token keyword">int</span> priority<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">processWidget</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span>new Widget<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">priority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><br>C++中，一条语句里面的函数调用顺序是不确定的，所以代码可以拆分成三条语句：<br><pre class="language-c" data-language="c"><code class="language-c">new Widget
<span class="token function">priority</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
std<span class="token operator">::</span>tr1<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><br>如果编译器首先执行了第三条语句，那么就会导致new Widget创建的对象还没加入到shared_ptr中，会造成资源泄漏。正确的做法应该是：<br><pre class="language-c" data-language="c"><code class="language-c">std<span class="token operator">::</span>tr1<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">pw</span><span class="token punctuation">(</span>new Widget<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">processWidget</span><span class="token punctuation">(</span>pw<span class="token punctuation">,</span> <span class="token function">priority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></p>
<p>总结：</p>
<ul>
<li>以独立语句将newed对象置入智能指针类，如果不这样做，一旦异常抛出可能回导致资源泄露。</li>
</ul>
<h1 id="设计与申明-条款-18"><a href="#设计与申明-条款-18" class="headerlink" title="设计与申明 条款(18 ~ )"></a>设计与申明 条款(18 ~ )</h1><h2 id="条款18-让接口容易被使用，难以被误用"><a href="#条款18-让接口容易被使用，难以被误用" class="headerlink" title="条款18 让接口容易被使用，难以被误用"></a>条款18 让接口容易被使用，难以被误用</h2><h3 id="1、设计不容易被错误使用的接口"><a href="#1、设计不容易被错误使用的接口" class="headerlink" title="1、设计不容易被错误使用的接口"></a>1、设计不容易被错误使用的接口</h3><p>考虑如下代码：</p>
<pre class="language-c" data-language="c"><code class="language-c">class Date<span class="token punctuation">&#123;</span>
  public<span class="token operator">:</span>
  <span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">int</span> month<span class="token punctuation">,</span><span class="token keyword">int</span> day<span class="token punctuation">,</span><span class="token keyword">int</span> year<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>像这样的接口极其容易用错，很多这种错误可以通过引入新类型加以更正：<br><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Day</span><span class="token punctuation">&#123;</span>
  explicit <span class="token function">Day</span><span class="token punctuation">(</span><span class="token keyword">int</span> d<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">val</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
  <span class="token keyword">int</span> vla<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">struct</span> <span class="token class-name">Month</span><span class="token punctuation">&#123;</span>
  explicit <span class="token function">Month</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">val</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
  <span class="token keyword">int</span> val<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">struct</span> <span class="token class-name">Year</span><span class="token punctuation">&#123;</span>
  explicit <span class="token function">Year</span><span class="token punctuation">(</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">val</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
  <span class="token keyword">int</span> val<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
class Date<span class="token punctuation">&#123;</span>
  public<span class="token operator">:</span>
  <span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">const</span> Month<span class="token operator">&amp;</span> m<span class="token punctuation">,</span> <span class="token keyword">const</span> Day<span class="token operator">&amp;</span> d<span class="token punctuation">,</span> <span class="token keyword">const</span> Year<span class="token operator">&amp;</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span>

Date <span class="token function">d</span><span class="token punctuation">(</span><span class="token function">Month</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Day</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Year</span><span class="token punctuation">(</span><span class="token number">1995</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用这种方法更加不容易出错，使用封装好的更加好</span></code></pre><br>下述是一个更加安全的方式：<br><pre class="language-c" data-language="c"><code class="language-c">class Month<span class="token punctuation">&#123;</span>
  public<span class="token operator">:</span>
   <span class="token keyword">static</span> Month <span class="token function">Jan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">Month</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
   <span class="token keyword">static</span> Month <span class="token function">Feb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">Month</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span>

Date <span class="token function">d</span><span class="token punctuation">(</span>Month<span class="token operator">::</span><span class="token function">Mar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Day</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">Year</span><span class="token punctuation">(</span><span class="token number">1955</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></p>
<h3 id="2、使得自己的types的行为和内置types一致"><a href="#2、使得自己的types的行为和内置types一致" class="headerlink" title="2、使得自己的types的行为和内置types一致"></a>2、使得自己的types的行为和内置types一致</h3><p>对于STL容器来说，这些接口都十分一致，这使得极其容易被调用。比如<code>string</code> 类型 和<code>vector</code>类型，都有<code>size</code>方法。</p>
<h3 id="3、阻止误用"><a href="#3、阻止误用" class="headerlink" title="3、阻止误用"></a>3、阻止误用</h3><p>如在条款13中引入了一个对象<br><pre class="language-c" data-language="c"><code class="language-c">Investment<span class="token operator">*</span> <span class="token function">createInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><br>为了避免资源泄露，这个返回的指针必须删除，那就开启了客户端两次犯错机会：没有删除指针，或删除同一个指针超过一次。<br>事实上，对于设计的较好的接口来说，其一般原则就是先发制人，如<br><pre class="language-c" data-language="c"><code class="language-c">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">createInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></p>
<h3 id="4、shared-ptr-支持定制删除器"><a href="#4、shared-ptr-支持定制删除器" class="headerlink" title="4、shared_ptr 支持定制删除器"></a>4、shared_ptr 支持定制删除器</h3><p><code>shared_ptr</code>这个性质可以消除DLL问题，即对象在动态连接程序库（DLL）中被new创建，却在另一个DLL内被delete销毁。</p>
<p>如：一个DLL（A）对外暴露的接口函数入参是vector&amp;，功能是返回一个对象的列表。另一个DLL（B）在调用这个接口之后崩溃。</p>
<p>接口入参设计成vector本来是想利用STL容器变长的特点，结果聪明反被聪明误。vector在添加对象时，如果内部申请的内存空间不够存放新对象，则会重新申请内存。这就导致了从B传入的vector其实是在A中申请了内存，而在B中销毁，导致不正确地释放内存。</p>
<p>如果使用<code>shared_ptr</code>来包装参数，利用其引用计数及定制析构的特性，保证内存哪里申请就哪里释放，就可以解决这个问题。</p>
<p>总结：</p>
<ul>
<li>好的接口总是不容易使用出错的，在编码过程中最好努力实现这些特性。</li>
<li>最好让自己的types的行为和内置types行为一致</li>
<li>阻止误用的方法：建立新类型，限制类型操作，束缚对象值，消除客户的资源管理责任。</li>
<li><code>shared_ptr</code> 支持定制删除器，可访问DLL问题和自动解除互斥锁。</li>
</ul>
<h2 id="条款19-设计class像设计type"><a href="#条款19-设计class像设计type" class="headerlink" title="条款19 设计class像设计type"></a>条款19 设计class像设计type</h2><p>类的设计就是类型设计，当你定义一个类之前，需要面对这些问题：</p>
<ul>
<li>这个新的类型如何创建和销毁？new还是new []？</li>
<li>初始化和赋值之间又怎样的区别？它们确实是不同的函数调用，参见：条款4</li>
<li>如果该类型的对象被传值而不是传引用，意味着怎样的语义？记住：传值时调用的是拷贝构造函数！</li>
<li>该类型合理的取值范围是？在类的成员函数、赋值和构造函数中需要做相应的范围检查！</li>
<li>你的新类型能融合到继承图中吗？如果你继承自已有的类，你的类将被它们限制（尤其是虚函数限定）；如果你希望其他类来继承该类型，那么你的方法是否需要声明为virtual？尤其是析构函数。</li>
<li>你的新类型允许怎样的类型转换？你可能需要将构造函数声明为explicit来避免隐式类型转换。参见：条款15：资源管理类需要提供对原始资源的访问</li>
<li>哪些运算符对你的新类型是有意义的？参见：条款 6：禁用那些不需要的缺省方法</li>
<li>谁可以访问你的成员方法？私有、保护、共有成员限定符；友元类、友元函数。</li>
<li>你想提供哪些潜在的接口？它们往往关乎异常安全、效率、资源使用等，这些潜在的接口将会影响你的实现。</li>
<li>你的类型有多么通用？如果它是非常通用的类型，你可以考虑通过模板把它定义成一系列的类。</li>
<li>你真的需要这个新的类型吗？如果你为了扩展一个类而继承了它，那么定义一个非成员函数或者模板能否更好地解决问题？</li>
</ul>
<p>总结：<br><code>class</code>设计就是<code>type</code>设计，需要考虑上述问题。</p>
<h2 id="条款20-传递常量引用比传值更好"><a href="#条款20-传递常量引用比传值更好" class="headerlink" title="条款20 传递常量引用比传值更好"></a>条款20 传递常量引用比传值更好</h2>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/30/Program-Static-Analysis-Note/" rel="prev" title="Program Static Analysis Note">
      <i class="fa fa-chevron-left"></i> Program Static Analysis Note
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/09/29/%E9%9D%A2%E7%BB%8F/" rel="next" title="面经">
      面经 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC-%EF%BC%9A%E6%9D%A1%E6%AC%BE-1-4"><span class="nav-text">让自己习惯C++ ：条款(1~4)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE1-%E5%B0%86C-%E7%9C%8B%E4%BD%9C%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6"><span class="nav-text">条款1 将C++看作一个语言联邦</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE2-%E5%B0%BD%E9%87%8F%E7%94%A8const%EF%BC%8Cenum%EF%BC%8Cinline-%E6%9B%BF%E6%8D%A2-define"><span class="nav-text">条款2 尽量用const，enum，inline 替换 #define</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE3-%E5%A4%9A%E7%94%A8const"><span class="nav-text">条款3 多用const</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE4-%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E7%BB%8F%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">条款4 确定对象被使用前已经被初始化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97-%EF%BC%9A%E6%9D%A1%E6%AC%BE-5-12"><span class="nav-text">构造、析构、赋值运算 ：条款(5~12)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE5-%E4%BA%86%E8%A7%A3C-%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="nav-text">条款5 了解C++默默编写并调用哪些函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE6-%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D%E4%B8%8D%E9%9C%80%E8%A6%81%E7%9A%84%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0"><span class="nav-text">条款6 明确拒绝不需要的自动生成函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE7-%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E7%94%9F%E6%88%90virtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">条款7 为多态基类生成virtual析构函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE8-%E5%88%AB%E5%9C%A8%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="nav-text">条款8 别在析构函数中抛出异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE9-%E4%B8%8D%E8%A6%81%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">条款9 不要在构造函数和析构函数中调用虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE10-%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%94%E5%9B%9E-this%E7%9A%84%E5%BC%95%E7%94%A8"><span class="nav-text">条款10 赋值操作符返回*this的引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE11-%E5%9C%A8operator-%E4%B8%AD%E5%A4%84%E7%90%86%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%EF%BC%88self-assingment%EF%BC%89"><span class="nav-text">条款11 在operator&#x3D; 中处理自我赋值（self assingment）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE12-%E5%AE%8C%E6%95%B4%E6%8B%B7%E8%B4%9D%E5%AF%B9%E8%B1%A1"><span class="nav-text">条款12 完整拷贝对象</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-%E6%9D%A1%E6%AC%BE-13-17"><span class="nav-text">资源管理 条款(13~17)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE13-%E7%94%A8%E5%AF%B9%E8%B1%A1%E6%9D%A5%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90"><span class="nav-text">条款13  用对象来管理资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE14-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E7%9A%84%E6%8B%B7%E8%B4%9D"><span class="nav-text">条款14 资源管理类的拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE15-%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="nav-text">条款15 提供对原始资源的访问</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE16-%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8new%E5%92%8Cdelete%E6%97%B6%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E5%AF%B9%E5%BA%94%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="nav-text">条款16 成对使用new和delete时需要使用对应的形式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE17-%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86newed%E5%AF%B9%E8%B1%A1%E7%BD%AE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-text">条款17 以独立语句将newed对象置入智能指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%94%B3%E6%98%8E-%E6%9D%A1%E6%AC%BE-18"><span class="nav-text">设计与申明 条款(18 ~ )</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE18-%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E4%BD%BF%E7%94%A8%EF%BC%8C%E9%9A%BE%E4%BB%A5%E8%A2%AB%E8%AF%AF%E7%94%A8"><span class="nav-text">条款18 让接口容易被使用，难以被误用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E8%AE%BE%E8%AE%A1%E4%B8%8D%E5%AE%B9%E6%98%93%E8%A2%AB%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-text">1、设计不容易被错误使用的接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BD%BF%E5%BE%97%E8%87%AA%E5%B7%B1%E7%9A%84types%E7%9A%84%E8%A1%8C%E4%B8%BA%E5%92%8C%E5%86%85%E7%BD%AEtypes%E4%B8%80%E8%87%B4"><span class="nav-text">2、使得自己的types的行为和内置types一致</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E9%98%BB%E6%AD%A2%E8%AF%AF%E7%94%A8"><span class="nav-text">3、阻止误用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81shared-ptr-%E6%94%AF%E6%8C%81%E5%AE%9A%E5%88%B6%E5%88%A0%E9%99%A4%E5%99%A8"><span class="nav-text">4、shared_ptr 支持定制删除器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE19-%E8%AE%BE%E8%AE%A1class%E5%83%8F%E8%AE%BE%E8%AE%A1type"><span class="nav-text">条款19 设计class像设计type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE20-%E4%BC%A0%E9%80%92%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8%E6%AF%94%E4%BC%A0%E5%80%BC%E6%9B%B4%E5%A5%BD"><span class="nav-text">条款20 传递常量引用比传值更好</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ATT_POWER</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yglsaltfish" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yglsaltfish" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ATT_POWER</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">313k</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script src="https://cdn.jsdelivr.net/npm/live2d-widget@^3.1.3/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
