<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yglsaltfish.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="学习muduo笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="muduo 库学习">
<meta property="og:url" content="https://yglsaltfish.github.io/2021/12/09/muduo-%E5%BA%93%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="ATT_POWER的博客">
<meta property="og:description" content="学习muduo笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-12-09T02:51:42.000Z">
<meta property="article:modified_time" content="2022-11-28T03:48:48.501Z">
<meta property="article:author" content="ATT_POWER">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://yglsaltfish.github.io/2021/12/09/muduo-%E5%BA%93%E5%AD%A6%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>muduo 库学习 | ATT_POWER的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ATT_POWER的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yglsaltfish.github.io/2021/12/09/muduo-%E5%BA%93%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ATT_POWER">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ATT_POWER的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          muduo 库学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-09 10:51:42" itemprop="dateCreated datePublished" datetime="2021-12-09T10:51:42+08:00">2021-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-28 11:48:48" itemprop="dateModified" datetime="2022-11-28T11:48:48+08:00">2022-11-28</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <div class="post-description">学习muduo笔记</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="网络编程相关学习"><a href="#网络编程相关学习" class="headerlink" title="网络编程相关学习"></a>网络编程相关学习</h1><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><h3 id="select、poll、epoll-区别"><a href="#select、poll、epoll-区别" class="headerlink" title="select、poll、epoll 区别"></a>select、poll、epoll 区别</h3><ul>
<li>调用函数</li>
<li>select和poll都是一个函数，epoll是一组函数</li>
<li>文件描述符数量<ul>
<li>select通过线性表描述文件描述符集合，文件描述符有上限，一般是1024，但可以修改源码，重新编译内核。在linux/posix_types.h头文件有这样的声明：<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__FD_SETSIZE</span>    <span class="token expression"><span class="token number">1024</span></span></span></code></pre>
表示select最多同时监听1024个fd。</li>
<li>poll是链表描述，突破了文件描述符上限，最大可以打开文件的数目；</li>
<li>epoll通过红黑树描述，最大可以打开文件的数目，可以通过命令ulimit -n number修改，仅对当前终端有效</li>
</ul>
</li>
<li>将文件描述符从用户传给内核<ul>
<li>select和poll通过将所有文件描述符拷贝到内核态，每次调用都需要拷贝</li>
<li>epoll通过epoll_create建立一棵红黑树，通过epoll_ctl将要监听的文件描述符注册到红黑树上</li>
</ul>
</li>
<li>内核判断就绪的文件描述符<ul>
<li>select和poll通过遍历文件描述符集合，判断哪个文件描述符上有事件发生</li>
<li>epoll_create时，内核除了帮我们在epoll文件系统里建了个红黑树用于存储以后epoll_ctl传来的fd外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。</li>
<li>epoll是根据每个fd上面的回调函数(中断函数)判断，只有发生了事件的socket才会主动的去调用 callback函数，其他空闲状态socket则不会，若是就绪事件，插入list</li>
</ul>
</li>
<li>应用程序索引就绪文件描述符<ul>
<li>select/poll只返回发生了事件的文件描述符的个数，若知道是哪个发生了事件，同样需要遍历</li>
<li>epoll返回的发生了事件的个数和结构体数组，结构体包含socket的信息，因此直接处理返回的数组即可</li>
</ul>
</li>
<li>工作模式<ul>
<li>select和poll都只能工作在相对低效的LT模式下</li>
<li>epoll则可以工作在ET高效模式，并且epoll还支持EPOLLONESHOT事件，该事件能进一步减少可读、可写和异常事件被触发的次数。 </li>
</ul>
</li>
<li>应用场景<ul>
<li>当所有的fd都是活跃连接，使用epoll，需要建立文件系统，红黑书和链表对于此来说，效率反而不高，不如selece和poll</li>
<li>当监测的fd数目较小，且各个fd都比较活跃，建议使用select或者poll</li>
<li>当监测的fd数目非常大，成千上万，且单位时间只有其中的一部分fd处于就绪状态，这个时候使用epoll能够明显提升性能</li>
</ul>
</li>
</ul>
<h3 id="epoll接口"><a href="#epoll接口" class="headerlink" title="epoll接口"></a>epoll接口</h3><ul>
<li><p>int epoll_create(int size);<br>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>
</li>
<li><p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);<br>epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。第一个参数是epoll_create()的返回值，第二个参数表示动作，用三个宏来表示：</p>
<ul>
<li>EPOLL_CTL_ADD：注册新的fd到epfd中；</li>
<li>EPOLL_CTL_MOD：修改已经注册的fd的监听事件；</li>
<li>EPOLL_CTL_DEL：从epfd中删除一个fd；</li>
</ul>
<p>第三个参数是需要监听的fd，第四个参数是告诉内核需要监听什么事，struct epoll_event结构如下：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">union</span> epoll_data <span class="token punctuation">&#123;</span>
  <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
  <span class="token keyword">int</span> fd<span class="token punctuation">;</span>
  __uint32_t u32<span class="token punctuation">;</span>
  __uint64_t u64<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token class-name">epoll_data_t</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token punctuation">&#123;</span>
    __uint32_t events<span class="token punctuation">;</span> <span class="token comment">/* Epoll events */</span>
    <span class="token class-name">epoll_data_t</span> data<span class="token punctuation">;</span> <span class="token comment">/* User data variable */</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
<p>events可以是以下几个宏的集合：</p>
<ul>
<li>EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</li>
<li>EPOLLOUT：表示对应的文件描述符可以写；</li>
<li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</li>
<li>EPOLLERR：表示对应的文件描述符发生错误；</li>
<li>EPOLLHUP：表示对应的文件描述符被挂断；</li>
<li>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</li>
<li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</li>
<li>EPOLLRDHUP：代表对端断开连接，可以使得对端断开连接的异常在底层进行处理了，不用再移交到上层。</li>
</ul>
</li>
<li>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);<br>等待事件的产生，类似于select()调用。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。<h3 id="ET、LT、EPOLLONESHOT"><a href="#ET、LT、EPOLLONESHOT" class="headerlink" title="ET、LT、EPOLLONESHOT"></a>ET、LT、EPOLLONESHOT</h3></li>
<li>LT水平触发模式<ul>
<li>epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序可以不立即处理该事件。</li>
<li>当下一次调用epoll_wait时，epoll_wait还会再次向应用程序报告此事件，直至被处理</li>
</ul>
</li>
<li>ET边缘触发模式<ul>
<li>epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序必须立即处理该事件</li>
<li>必须要一次性将数据读取完，使用非阻塞I/O，读取到出现eagain</li>
</ul>
</li>
<li>EPOLLONESHOT<ul>
<li>一个线程读取某个socket上的数据后开始处理数据，在处理过程中该socket上又有新数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个socket</li>
<li>一个socket连接在任一时刻都只被一个线程处理：通过epoll_ctl对该文件描述符注册epolloneshot事件，一个线程处理socket时，其他线程将无法处理，<strong>当该线程处理完后，需要通过epoll_ctl重置epolloneshot事件</strong></li>
</ul>
</li>
</ul>
<h2 id="处理非活跃链接"><a href="#处理非活跃链接" class="headerlink" title="处理非活跃链接"></a>处理非活跃链接</h2><ul>
<li>非活跃：指客户端（这里是浏览器）与服务器端建立连接后，长时间不交换数据，一直占用服务器端的文件描述符，导致连接资源的浪费。</li>
<li>定时事件：指固定一段时间之后触发某段代码，由该段代码处理一个事件，如从内核事件表删除事件，并关闭文件描述符，释放连接资源。</li>
<li>定时器，是指利用结构体或其他形式，将多种定时事件进行封装起来。这里只涉及一种定时事件，即定期检测非活跃连接，这里将该定时事件与连接资源封装为一个结构体定时器。</li>
<li>定时器容器，是指使用某种容器类数据结构，将上述多个定时器组合起来，便于对定时事件统一管理。具体的，项目中使用升序链表将所有定时器串联组织起来。</li>
</ul>
<h3 id="定时方法"><a href="#定时方法" class="headerlink" title="定时方法"></a>定时方法</h3><p>在tinyWebserver项目中，服务器主循环为每一个连接创建一个定时器，并对每个连接进行定时。另外，利用升序时间链表容器将所有定时器串联起来，若主循环接收到定时通知，则在链表中依次执行定时任务。<br>Linux下有三种定时方法：</p>
<ul>
<li>socket选项SO_RECVTIMEO和SO_SNDTIMEO</li>
<li>SIGALRM信号</li>
<li>I/O复用系统调用的超时参数</li>
</ul>
<p>项目中使用的是SIGAKRAM信号</p>
<h3 id="相关api"><a href="#相关api" class="headerlink" title="相关api"></a>相关api</h3><h4 id="sigaction结构体"><a href="#sigaction结构体" class="headerlink" title="sigaction结构体"></a>sigaction结构体</h4><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sigaction</span>
  <span class="token punctuation">&#123;</span>
    <span class="token comment">/* Signal handler.  */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">defined __USE_POSIX199309 <span class="token operator">||</span> defined __USE_XOPEN_EXTENDED</span></span>
    <span class="token keyword">union</span>
      <span class="token punctuation">&#123;</span>
	<span class="token comment">/* Used if SA_SIGINFO is not set.  */</span>
	__sighandler_t sa_handler<span class="token punctuation">;</span>
	<span class="token comment">/* Used if SA_SIGINFO is set.  */</span>
	<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>sa_sigaction<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token class-name">siginfo_t</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
    __sigaction_handler<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token macro-name">sa_handler</span>	<span class="token expression">__sigaction_handler<span class="token punctuation">.</span>sa_handler</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token macro-name">sa_sigaction</span>	<span class="token expression">__sigaction_handler<span class="token punctuation">.</span>sa_sigaction</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
    __sighandler_t sa_handler<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

    <span class="token comment">/* Additional set of signals to be blocked.  */</span>
    __sigset_t sa_mask<span class="token punctuation">;</span>

    <span class="token comment">/* Special flags.  */</span>
    <span class="token keyword">int</span> sa_flags<span class="token punctuation">;</span>

    <span class="token comment">/* Restore handler.  */</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>sa_restorer<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
<ul>
<li>sa_handler是一个函数指针，指向信号处理函数</li>
<li>sa_sigaction同样是信号处理函数，有三个参数，可以获得关于信号更详细的信息</li>
<li>sa_mask用来指定在信号处理函数执行期间需要被屏蔽的信号</li>
<li>sa_flags用于指定信号处理的行为<ul>
<li>SA_RESTART，使被信号打断的系统调用自动重新发起</li>
<li>SA_NOCLDSTOP，使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号</li>
<li>SA_NOCLDWAIT，使父进程在它的子进程退出时不会收到 SIGCHLD 信号，这时子进程如果退出也不会成为僵尸进程</li>
<li>SA_NODEFER，使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号</li>
<li>SA_RESETHAND，信号处理之后重新设置为默认的处理方式</li>
<li>SA_SIGINFO，使用 sa_sigaction 成员而不是 sa_handler 作为信号处理函数</li>
</ul>
</li>
<li>sa_restorer一般不使用</li>
</ul>
<h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><ul>
<li><p>sigaciton 函数</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span>
<span class="token keyword">int</span> <span class="token function">sigaction</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token operator">*</span>act<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token operator">*</span>oldact<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ul>
<li>signum表示操作的信号。</li>
<li>act表示对信号设置新的处理方式。</li>
<li>oldact表示信号原来的处理方式。</li>
<li>返回值，0 表示成功，-1 表示有错误发生。</li>
</ul>
</li>
<li><p>sigfillset函数</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sigfillset</span><span class="token punctuation">(</span><span class="token class-name">sigset_t</span> <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>w</code></pre>
<p>用来将参数set信号集初始化，然后把所有的信号加入到此信号集里。</p>
</li>
<li>SIGALRM、SIGTERM信号<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIGALRM</span>  <span class="token expression"><span class="token number">14</span>     </span><span class="token comment">//由alarm系统调用产生timer时钟信号</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SIGTERM</span>  <span class="token expression"><span class="token number">15</span>     </span><span class="token comment">//终端发送的终止信号</span></span></code></pre></li>
<li>alarm函数<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">alarm</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> seconds<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
设置信号传送闹钟，即用来设置信号SIGALRM在经过参数seconds秒数后发送给目前的进程。如果未设置信号SIGALRM的处理函数，那么alarm()默认处理终止进程.</li>
<li>socketpair函数<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">socketpair</span><span class="token punctuation">(</span><span class="token keyword">int</span> domain<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">,</span> <span class="token keyword">int</span> sv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ul>
<li>domain表示协议族，PF_UNIX或者AF_UNIX等等，主要用来IPC。</li>
<li>type表示协议，可以是SOCK_STREAM或者SOCK_DGRAM，SOCK_STREAM基于TCP，SOCK_DGRAM基于UDP</li>
<li>protocol表示类型，只能为0</li>
<li>sv[2]表示套节字柄对，该两个句柄作用相同，均能进行读写双向操作</li>
<li>返回结果， 0为创建成功，-1为创建失败</li>
</ul>
</li>
<li>send 函数<pre class="language-c" data-language="c"><code class="language-c"><span class="token class-name">ssize_t</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
当套接字发送缓冲区变满时，send通常会阻塞，除非套接字设置为非阻塞模式，当缓冲区变满时，返回EAGAIN或者EWOULDBLOCK错误，此时可以调用select函数来监视何时可以发送数据。</li>
</ul>
<h2 id="日志相关"><a href="#日志相关" class="headerlink" title="日志相关"></a>日志相关</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul>
<li>生产者-消费者模型，并发编程中的经典模型。以多线程为例，为了实现线程间数据同步，生产者线程与消费者线程共享一个缓冲区，其中生产者线程往缓冲区中push消息，消费者线程从缓冲区中pop消息。</li>
<li>阻塞队列，将生产者-消费者模型进行封装，使用循环数组实现队列，作为两者共享的缓冲区。</li>
<li>日志：由服务器自动创建，并记录运行状态，错误信息，访问数据的文件。<ul>
<li>同步日志：日志写入函数与工作线程串行执行，由于涉及到I/O操作，当单条日志比较大的时候，同步模式会阻塞整个处理流程，服务器所能处理的并发能力将有所下降，尤其是在峰值的时候，写日志可能成为系统的瓶颈。</li>
<li>将所写的日志内容先存入阻塞队列，写线程从阻塞队列中取出内容，写入日志。</li>
</ul>
</li>
<li>单例模式：保证一个类只创建一个实例，同时提供全局访问的方法。</li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式，简单来说就是保证一个类最多存在一个实例，并且这种保证是来自于设计者，而不是使用者。而实现这样需求的办法就是：让类的构造函数私有，在类内创建一个静态对象，并创建一个公有的静态方法访问这个对象。<br>单例模式的实现有懒汉模式和饿汉模式。下面是这两种模式的实现。</p>
<ul>
<li><p>饿汉模式：是线程安全的，所以在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现（不用锁机制，开销小），可以实现更好的性能。</p>
<pre class="language-c" data-language="c"><code class="language-c">class Singleton
<span class="token punctuation">&#123;</span>
private<span class="token operator">:</span>
    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i am single"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">static</span> Singleton <span class="token operator">*</span>instance<span class="token punctuation">;</span>

public<span class="token operator">:</span>
    <span class="token keyword">static</span> Singleton <span class="token operator">*</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

Singleton <span class="token operator">*</span>Singleton<span class="token operator">::</span>instance <span class="token operator">=</span> new <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Singleton <span class="token operator">*</span>one <span class="token operator">=</span> Singleton<span class="token operator">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Singleton <span class="token operator">*</span>two <span class="token operator">=</span> Singleton<span class="token operator">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>one <span class="token operator">==</span> two<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"单例！"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">/*
结果：
i am single
单例！
*/</span></code></pre>
</li>
<li><p>懒汉模式：第一次用才去实例化，访问量较小时，采用懒汉模式；非线程安全，当多线程访问时可能会创建多个实例。</p>
<pre class="language-c" data-language="c"><code class="language-c">class Singleton
<span class="token punctuation">&#123;</span>
private<span class="token operator">:</span>
    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i am single"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">static</span> Singleton <span class="token operator">*</span>instance<span class="token punctuation">;</span>

public<span class="token operator">:</span>
    <span class="token keyword">static</span> Singleton <span class="token operator">*</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> nullptr<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            instance <span class="token operator">=</span> new <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"first"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"second"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

Singleton <span class="token operator">*</span>Singleton<span class="token operator">::</span>instance <span class="token operator">=</span> new <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Singleton <span class="token operator">*</span>one <span class="token operator">=</span> Singleton<span class="token operator">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Singleton <span class="token operator">*</span>two <span class="token operator">=</span> Singleton<span class="token operator">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>one <span class="token operator">==</span> two<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"单例！"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">/*
i am single
first
second
单例！
*/</span></code></pre>
</li>
<li><p>使用懒汉模式下加锁：仅仅在判断是否为nullptr前，加了一个锁。这样效率会低，因为不管是否instance已经实例化，每次都要加锁进入临界区后才能做判断是否为nullptr。所以就有了下面的 double checked locking</p>
<pre class="language-c" data-language="c"><code class="language-c">class Singleton
<span class="token punctuation">&#123;</span>
private<span class="token operator">:</span>
    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i am single"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">static</span> Singleton <span class="token operator">*</span>instance<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token class-name">pthread_mutex_t</span> mutex<span class="token punctuation">;</span>

public<span class="token operator">:</span>
    <span class="token keyword">static</span> Singleton <span class="token operator">*</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> nullptr<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            instance <span class="token operator">=</span> new <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"first"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"second"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token class-name">pthread_mutex_t</span> Singleton<span class="token operator">::</span>mutex<span class="token punctuation">;</span>
Singleton <span class="token operator">*</span>Singleton<span class="token operator">::</span>instance <span class="token operator">=</span> nullptr<span class="token punctuation">;</span></code></pre></li>
<li>懒汉模式下双加锁：<pre class="language-c" data-language="c"><code class="language-c">class Singleton
<span class="token punctuation">&#123;</span>
private<span class="token operator">:</span>
    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i am single"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">static</span> Singleton <span class="token operator">*</span>instance<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token class-name">pthread_mutex_t</span> mutex<span class="token punctuation">;</span>

public<span class="token operator">:</span>
    <span class="token keyword">static</span> Singleton <span class="token operator">*</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        
        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> nullptr<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> nullptr<span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                instance <span class="token operator">=</span> new <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                cout <span class="token operator">&lt;&lt;</span> <span class="token string">"first"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span>
                cout <span class="token operator">&lt;&lt;</span> <span class="token string">"second"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
            <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre></li>
<li><p>DCL靠不住？<br>在muduo那本书中有写道：人们一直认为double checked locking是王道，有“神牛”指出由于乱序执行的影响，DCL（double checked locking）是靠不住的。<br>对于</p>
<pre class="language-c" data-language="c"><code class="language-c">instance <span class="token operator">=</span> new <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>编译器会分如下几步：<br>1、Singleton对象分配空间。<br>2、在分配的空间中构造对象<br>3、使instance指向分配的空间<br>其中2、3步是有可能交换的<br>就有可能发生这样的情况：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token number">1</span>、线程A进入了getInstance函数，并且执行了step1和step3，然后挂起。这时的状态是：instance不为nullptr，但instance指向的内存去没有对象！
<span class="token number">2</span>、线程B进入了getInstance函数，发现instance不为nullptr，就直接<span class="token keyword">return</span> instance。</code></pre>
</li>
<li><p>c++11 解决了上述问题<br>在《Effective C++》提出了使用函数内的local static对象，如下所示。</p>
<pre class="language-c" data-language="c"><code class="language-c">class Singleton
<span class="token punctuation">&#123;</span>
private<span class="token operator">:</span>
  <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  <span class="token operator">~</span><span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Singleton<span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
public<span class="token operator">:</span>
  <span class="token keyword">static</span> Singleton<span class="token operator">&amp;</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
  <span class="token punctuation">&#123;</span>
    <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>
    <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
<ul>
<li>non-local static对象（函数外）<br>C++规定，non-local static 对象的初始化发生在main函数执行之前，也即main函数之前的单线程启动阶段，所以不存在线程安全问题。但C++没有规定多个non-local static 对象的初始化顺序，尤其是来自多个编译单元的non-local static对象，他们的初始化顺序是随机的。</li>
<li><p>local static 对象（函数内）<br>对于local static 对象，其初始化发生在控制流第一次执行到该对象的初始化语句时。多个线程的控制流可能同时到达其初始化语句。</p>
<p>在C++11之前，在多线程环境下local static对象的初始化并不是线程安全的。具体表现就是：如果一个线程正在执行local static对象的初始化语句但还没有完成初始化，此时若其它线程也执行到该语句，那么这个线程会认为自己是第一次执行该语句并进入该local static对象的构造函数中。这会造成这个local static对象的重复构造，进而产生内存泄露问题。所以，local static对象在多线程环境下的重复构造问题是需要解决的。</p>
<p>而C++11则在语言规范中解决了这个问题。C++11规定，在一个线程开始local static 对象的初始化后到完成初始化前，其他线程执行到这个local static对象的初始化语句就会等待，直到该local static 对象初始化完成。</p>
</li>
<li><p>注意点<br>1、c++静态变量（const整数类型除外）一定要在类外进行定义和初始化（类内的只是声明，非初始化，不会分配内存）</p>
<p>2、单例模式的析构函数中不要释放（delete）单例对象，而是应该定义一个静态的嵌套类对象去析构单例对象。因为delete对象时，先要调用对象的析构函数，这会造成在析构函数中去调用析构函数的递归死循环，最后耗尽栈空间</p>
<p>3、单例的析构函数最好是私有的，否则别人可能会delete你的instance</p>
<p>4、GetInstance()肯定是static的，因为它不属于某个对象，最关键的是你也不能构造出类对象去调用它，所以必须是static的</p>
<p>5、由于GetInstance是static的，所以它内部用到的锁，也得是static的，不能属于类对象才行。</p>
</li>
</ul>
</li>
</ul>
<h1 id="性能相关"><a href="#性能相关" class="headerlink" title="性能相关"></a>性能相关</h1><h2 id="写入时复制，Copy-on-write"><a href="#写入时复制，Copy-on-write" class="headerlink" title="写入时复制，Copy-on-write"></a>写入时复制，Copy-on-write</h2><p>如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。<br>在muduo库中使用share_ptr实现copy-on-write</p>
<h1 id="Linux-网络编程相关"><a href="#Linux-网络编程相关" class="headerlink" title="Linux 网络编程相关"></a>Linux 网络编程相关</h1><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>P、V操作。<br>假设有信号量SV，对它的P、V操作含义如下：</p>
<ul>
<li>P(SV)，如果SV的值大于0，就将它减1; 如果SV的值为0，则挂起进程的执行。</li>
<li>V(SV)，如果有其他进程因为等待SV而挂起，则唤醒之; 如果没有，则将SV加1。<br>Linux信号量API定义在<code>sys/sem.h</code>处，主要包含3个系统调用，<code>semget</code>，<code>semop</code>，<code>semctl</code>。</li>
</ul>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存是最高效的IPC机制，因为它不涉及进程之间的任何数据传输。这种高效率带来的问题是，我们必须用其他辅助手段来同步进程对共享内存的访问，否则会产生竞态条件。因此，共享内存通常和其他进程间通信方式一起使用。<br>Linux共享内存的API定义在<code>sys/shm.h</code>头文件中，包括4个系统调用：<code>shmget</code>, <code>shmat</code>, <code>shmdt</code>, <code>shmctl</code>。</p>
<p>还可以使用<code>mmap</code>和<code>munmap</code>函数，这个主要用于父进程与子进程之间的匿名内存共享。<code>mmap</code>函数用于申请一段内存空间，将这段内存作为进程间通信的共享内存，也可以将文件直接映射道其中。<code>mumap</code>则是释放这段内存空间。<code>shm_open</code>则可以实现无关进程之间的内存共享。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>两进程之间传递二进制块数据的一种简单有效方式。</p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="posix信号量"><a href="#posix信号量" class="headerlink" title="posix信号量"></a>posix信号量</h3><p><code>posix</code>信号量函数的名字都以<code>sem_</code>开头。</p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁用于保护关键代码段，确保独占式的访问，有点像二进制信号量。用于同步线程对共享数据的访问。</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>用于在线程之间同步共享数据的值，这个提供了一种线程间的通知机制；当某个共享数据达到某个值的时候，唤醒等待这个共享数据的线程。</p>
<h1 id="muduo-库相关学习"><a href="#muduo-库相关学习" class="headerlink" title="muduo 库相关学习"></a>muduo 库相关学习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a target="_blank" rel="noopener" href="https://github.com/chenshuo/muduo">muduo</a>是chenshuo大佬开源的一个基于<a target="_blank" rel="noopener" href="https://youjiali1995.github.io/network/muduo/">reactor pattern的多线程网络库</a>，链接中有他的设计目标。</p>
<p>网络库一般关注3个方面：</p>
<ul>
<li>模型：Linux 下一般都是 Reactor 模式，常用的线程模型有<ul>
<li>Redis 的 one loop one thread</li>
<li>Nginx 的 one loop per process + SO_REUSEPORT</li>
<li>Muduo 的 one loop per thread + threadpool</li>
</ul>
</li>
<li>性能：一般模型确定下来，性能也就大差不差了，这点主要是实现上面考虑的，是追求极致的性能还是保证代码的易读性。</li>
<li>接口：既要保证通用性能够提供多种模型的选择和全面的功能，又要保证接口的易用性。</li>
</ul>
<p>Muduo 使用的是 one loop per thread + threadpool，即配置多个线程，每个线程跑一个 eventloop，一个线程只负责接受连接并分发给其他线程，之后该连接的所有 i/o 操作 都由该线程处理，threadpool 可以用来处理耗时长的任务。</p>
<h2 id="整体分析"><a href="#整体分析" class="headerlink" title="整体分析"></a>整体分析</h2><p>Reactor 模式涉及的类：</p>
<ul>
<li>Channal： 封装 I/O 事件和回调，可以代表多种实体：listening fd、timer fd、event fd 等。</li>
<li>Poller：I/O Multiplexing 的基类，封装底层的系统调用(poll(2) 和 epoll(2))。根据 Channel 更新事件，并返回活跃的 Channel。</li>
<li>Eventloop：整合 Channel 和 Poller，提供更高层的接口，如定时器。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/02/%E5%9F%BA%E4%BA%8Epython%E7%9A%84ping%E5%92%8Ctraceroute%E5%AE%9E%E7%8E%B0/" rel="prev" title="基于python的ping和traceroute实现">
      <i class="fa fa-chevron-left"></i> 基于python的ping和traceroute实现
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/30/Program-Static-Analysis-Note/" rel="next" title="Program Static Analysis Note">
      Program Static Analysis Note <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0"><span class="nav-text">网络编程相关学习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll"><span class="nav-text">epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#select%E3%80%81poll%E3%80%81epoll-%E5%8C%BA%E5%88%AB"><span class="nav-text">select、poll、epoll 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll%E6%8E%A5%E5%8F%A3"><span class="nav-text">epoll接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ET%E3%80%81LT%E3%80%81EPOLLONESHOT"><span class="nav-text">ET、LT、EPOLLONESHOT</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E9%9D%9E%E6%B4%BB%E8%B7%83%E9%93%BE%E6%8E%A5"><span class="nav-text">处理非活跃链接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E6%96%B9%E6%B3%95"><span class="nav-text">定时方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3api"><span class="nav-text">相关api</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sigaction%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">sigaction结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-text">相关函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E7%9B%B8%E5%85%B3"><span class="nav-text">日志相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-text">相关概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-text">单例模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3"><span class="nav-text">性能相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E5%85%A5%E6%97%B6%E5%A4%8D%E5%88%B6%EF%BC%8CCopy-on-write"><span class="nav-text">写入时复制，Copy-on-write</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3"><span class="nav-text">Linux 网络编程相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-text">进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-text">共享内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-text">消息队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-text">线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#posix%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-text">posix信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-text">互斥锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-text">条件变量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#muduo-%E5%BA%93%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0"><span class="nav-text">muduo 库相关学习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E5%88%86%E6%9E%90"><span class="nav-text">整体分析</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ATT_POWER</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yglsaltfish" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yglsaltfish" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ATT_POWER</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">319k</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script src="https://cdn.jsdelivr.net/npm/live2d-widget@^3.1.3/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
